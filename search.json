[{"title":"ä¿ç ”ç»éªŒè´´","path":"/2024/09/29/ä¿ç ”ç»éªŒè´´/","content":"2024å¹´ï¼ˆ2025å±Šï¼‰å››éè®¡ç®—æœºä¿ç ”ç»éªŒè´´ï¼ˆæµ™è½¯ï¼ŒåŒ—é‚®ï¼Œé‡å¤§ï¼Œæˆç”µï¼Œè¥¿ç”µæ­ï¼Œæ·±å¤§ï¼‰å‰è¨€ä»Šå¹´æ˜¯å¯¹å››éåœ°ç‹±çº§å¤–ä¿éš¾åº¦çš„ä¸€å¹´ï¼ˆä»¥åä¼šæ›´éš¾ğŸ¤¡ï¼‰ï¼Œå¤§éƒ¨åˆ†å­¦æ ¡ä¿ç ”ç‡æå‡ï¼Œç››è¡Œæœ¬æ ¡ä¿æŠ¤ï¼Œå·¥ç¨‹ç¡•åšè®¡åˆ’å ç”¨å¤§é‡åé¢ï¼Œå¾ˆå¤šå­¦æ ¡å¼€å§‹ä¼˜åŒ–ç”Ÿæºè´¨é‡ï¼Œä½†æ‰€å¹¸æˆ‘çš„ç»“æœä¹Ÿè¿˜ä¸é”™ã€‚ ä¸ªäººæƒ…å†µå­¦æ ¡ï¼šæŸè¥¿å—åœ°åŒºå››é ä¸“ä¸šï¼šè½¯ä»¶å·¥ç¨‹ rkï¼šå‰äº”å­¦æœŸæ’å3&#x2F;360ï¼ˆå¤ä»¤è¥æ ¹æœ¬è¿‡ä¸äº†ï¼‰ï¼Œå…­å­¦æœŸç»¼åˆæ’å1&#x2F;530ï¼ˆæ’åå‡ºçš„å¤ªæ™šäº†ï¼Œå¾ˆå¤šå¥½å­¦æ ¡å·²ç»æˆªæ­¢äº†ï¼‰ã€‚ å››å…­çº§ï¼š4çº§490ï¼Œ6çº§æ²¡è¿‡ï¼ˆå¤ä»¤è¥è¢«æ‹’å¾—å¿«å¥”æºƒäº†ï¼‰ï¼Œé¢„æ¨å…450ï¼ˆå‹‰å¼ºèƒ½ç”¨ï¼‰ ç«èµ›ï¼šè“æ¡¥æ¯å›½ä¸€ï¼Œè½¯ä»¶æ¯å›½ä¸‰ï¼Œæ•°æ¨¡çœä¸€ï¼ˆå¤§éƒ¨åˆ†è€å¸ˆä¸çœ‹ï¼Œç”šè‡³æœ‰è€å¸ˆé—®è“æ¡¥æ¯æ˜¯ä»€ä¹ˆæ¯”èµ›ğŸ¤¡ï¼‰ ç§‘ç ”ï¼šğŸˆšï¼Œæå¤§çš„çŸ­æ¿ rkâ‰ˆé¡¶çº§ç§‘ç ”&gt;6çº§&gt;ç«èµ› ç›®æ ‡ï¼šä¸­9æˆ–åŒ—é‚®ã€‚ æœ€ç»ˆå»å‘ï¼šæµ™æ±Ÿå¤§å­¦è½¯ä»¶å­¦é™¢ï¼Œäººå·¥æ™ºèƒ½ã€‚ å¤ä»¤è¥å…¥è¥æƒ…å†µä¸æ˜¯rk1+æ²¡è¿‡6çº§ï¼Œå¤ä»¤è¥æå…¶æƒ¨æ·¡ï¼ŒçœŸçš„å¿«å´©æºƒäº†ã€‚ å­¦æ ¡ å­¦é™¢ çŠ¶æ€ å¤‡æ³¨ å—äº¬å¤§å­¦ æ™ºèƒ½è½¯ä»¶ æœªå…¥ æŠ•ç€ç© å—äº¬å¤§å­¦ è½¯ä»¶ æœªå…¥ åŒæ€ åŒ—äº¬é‚®ç”µå¤§å­¦ è®¡ç®—æœº é¢è¯•å¯„ é¢è¯•15minï¼Œå¯„äº† æµ™æ±Ÿå¤§å­¦ è½¯ä»¶ ä¼˜è¥ é¢„æ¨å…å…¥åœºåˆ¸ è¥¿åŒ—å·¥ä¸šå¤§å­¦ è½¯ä»¶ æœªå…¥ ä¸æ‡‚ ä¸­å±±å¤§å­¦ è½¯ä»¶ æœªå…¥ æŠ•ç€ç© ç”µå­ç§‘æŠ€å¤§å­¦ æ™ºèƒ½è®¡ç®— æœªå…¥ æŠ•ç€ç© å±±ä¸œå¤§å­¦ è½¯ä»¶ å®£è®²è¥ æµ·è¥ ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ å…ˆç ”é™¢ æœªå…¥ å‘äº†20å°é‚®ä»¶ï¼Œæ— æœ åŒ—äº¬å¸ˆèŒƒå¤§å­¦ äººå·¥æ™ºèƒ½ æœªå…¥ æŠ•ç€ç© åŒ—äº¬ç†å·¥å¤§å­¦ ç æµ· æœªå…¥ æŠ•ç€ç© åŒ—äº¬äº¤é€šå¤§å­¦ è®¡ç®—æœº æœªå…¥ ä¸æ‡‚ åå—ç†å·¥å¤§å­¦ è½¯ä»¶ æœªå…¥ ä¸æ‡‚ æ·±åœ³å¤§å­¦ è®¡ç®—æœº ä¼˜è¥ å€™è¡¥ç¬¬äºŒæ‰¹å…¥äº† é‡åº†å¤§å­¦ è®¡ç®—æœº æœªå…¥ å¡åŒä¸€æµ é‡åº†å¤§å­¦ å·¥ç¨‹å¸ˆ æœªå…¥ åŒæ€ é‡åº†å¤§å­¦ è½¯ä»¶ æœªå…¥ ä¸‰æ€ åŒ—äº¬èˆªç©ºèˆªå¤©å¤§å­¦ è®¡ç®—æœº æœªå…¥ æŠ•ç€ç© åŒ—äº¬èˆªç©ºèˆªå¤©å¤§å­¦ è½¯ä»¶ æœºè¯•å¯„ ä¸æ˜¯acmer ä»ä¸Šé¢çš„è¡¨å¯ä»¥çœ‹åˆ°ï¼Œå¤ä»¤è¥ååˆ†æƒ¨çƒˆï¼Œåªæ‹¿åˆ°äº†æ·±å¤§çš„offerå’Œæµ™è½¯é¢„æ¨å…çš„å…¥åœºåˆ¸ã€‚ åŒ—äº¬é‚®ç”µå¤§å­¦è®¡ç®—æœºï¼Œå¯„äº†å…¥äº†11ç»„ï¼Œè¯´æ˜¯ä»200äººé‡Œé€‰äº†40äººï¼Œæœ€ç»ˆå½•å–8äººã€‚çº¿ä¸Š15åˆ†é’Ÿé¢è¯•ï¼Œ8åˆ†é’Ÿè‡ªæˆ‘ä»‹ç»ï¼Œç„¶åæ˜¯æé—®é¡¹ç›®ï¼Œç¬¬ä¸€æ¬¡é¢è¯•ï¼Œå‡†å¤‡ä¸å……åˆ†ï¼Œç»“æœå°±æ˜¯å¯„äº†ã€‚ æµ™è½¯ï¼Œä¼˜è¥çº¿ä¸Šï¼Œæ€»å…±å…¥äº†2700äººï¼Œæˆ‘é€‰çš„æ˜¯å¤§æ•°æ®åˆ†è¥ï¼Œç„¶åé‡Œé¢è¿˜è¦å†åˆ†å›¢é˜Ÿã€‚æˆ‘ä»¬å›¢é˜Ÿæ˜¯é˜…è¯»ä¸€ç¯‡è®ºæ–‡ï¼Œç„¶ååšä¸€ä¸ªæ±‡æŠ¥+é¢è¯•ï¼Œå‡†å¤‡äº†ä¸€ä¸ªæ˜ŸæœŸï¼Œä¼˜äº†ã€‚ä»Šå¹´å‡ºç°äº†å“è¶Šè¥å‘˜ï¼ˆåªèƒ½æ˜¯985å’ŒåŒ—é‚®è¥¿ç”µï¼‰ç›¸å½“äºé“offerï¼Œç„¶åæ˜¯ä¼˜ç§€è¥å‘˜ï¼ˆé¢„æ¨å…å…¥åœºåˆ¸ï¼‰ï¼Œä»Šå¹´çš„barå¼‚å¸¸çš„é«˜ï¼Œå¯¹äºåŒéå’Œ211åŸºæœ¬é ä¼˜è¥æ‰èƒ½è¿›é¢„æ¨å…ã€‚ä¼˜ç§€è¥å‘˜å æ¯”10%ï¼Œå“è¶Šè¥å‘˜å æ¯”3%ã€‚ æ·±åœ³å¤§å­¦ï¼Œä¼˜è¥å”¯ä¸€ä¸€ä¸ªçº¿ä¸‹çš„å¤ä»¤è¥ï¼Œç”±äºæ˜¯æ— æ¡ä»¶æŠ¥é”€800å…ƒï¼Œå…¥è¥é—¨æ§›è¾ƒé«˜ï¼Œå€™è¡¥äº†ä¸¤è½®è¿›å»äº†ã€‚é¦–å…ˆå°±æ˜¯å¬è®²åº§ï¼Œç¬¬ä¸€å¤©æ™šä¸Šæ¨¡æ‹Ÿæœºè¯•ï¼Œç¬¬äºŒå¤©æ™šä¸Šæ­£å¼æœºè¯•ï¼Œéš¾åº¦ä¸€èˆ¬æ•°æ®ç»“æ„çš„æ°´å¹³ï¼Œåé¢æœ‰ä¸€ç‚¹ç‚¹éš¾ï¼Œæœ€å70åˆ†ï¼Œç¬¬ä¸‰å¤©ä¸‹åˆæ˜¯é¢è¯•ã€‚é¢è¯•æ–¹å¼ä¸ºç¾¤é¢ï¼Œåˆ†åˆ°å„ä¸ªå›¢é˜Ÿé‡Œï¼Œä»¥åœ†æ¡Œä¼šè®®çš„æ–¹å¼èŠå¤©ï¼Œæœ€åæ‹¿åˆ°ä¼˜è¥offerï¼ˆç–‘ä¼¼æœºè¯•ä¸çˆ†é›¶å°±ç»™ï¼‰ã€‚ ä¸å¾—ä¸è¯´ï¼Œæ·±å¤§æ˜¯çœŸçš„æœ‰é’±ï¼Œå¦‚æœä¸æ˜¯å››éå°±å¥½äº†ã€‚ é¢„æ¨å…å…¥è¥æƒ…å†µ å­¦æ ¡ å­¦é™¢ çŠ¶æ€ å¤‡æ³¨ æµ™æ±Ÿå¤§å­¦ è½¯ä»¶å­¦é™¢ å€™è¡¥3 æœ€ç»ˆå»å‘ å—äº¬å¤§å­¦ è½¯ä»¶å­¦é™¢ æœªå…¥ æŠ•ç€ç© å—äº¬å¤§å­¦ æ™ºèƒ½è½¯ä»¶ æœªå…¥ æŠ•ç€ç© ä¸­å—å¤§å­¦ è®¡ç®—æœº æœªå…¥ æœ‰ç‚¹è¿· æ¹–å—å¤§å­¦ å·¥ç¨‹ç¡•åš æœªå…¥ æœ‰ç‚¹è¿· æ¹–å—å¤§å­¦ ä¿¡æ¯å­¦é™¢ æœªå…¥ æœ‰ç‚¹è¿· ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ ç§‘å­¦å²› æœªå…¥ æœ‰ç‚¹è¿· ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ å·¥ç¨‹ç¡•åš æœªå…¥ æŠ•ç€ç© å±±ä¸œå¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ æ—¶é—´å¤ªé•¿å’Œé‡å¤§å†²çªäº† å¤§è¿ç†å·¥å¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ å’Œæµ™è½¯å†²çªäº† åŒæµå¤§å­¦ å·¥ç¨‹ç¡•åš æœªå…¥ æŠ•ç€ç© è¥¿å®‰ç”µå­ç§‘æŠ€å¤§å­¦ å“å·¥ å·²å…¥,å¯„ ä½“éªŒäº†ä¸€ä¸‹ å—äº¬èˆªç©ºèˆªå¤©å¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ å’Œæµ™è½¯å†²çªäº† ç”µå­ç§‘æŠ€å¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ æµ™è½¯å€™è¡¥åˆ°äº†ï¼Œæ²¡å» é‡åº†å¤§å­¦ è®¡ç®—æœº å€™è¡¥,é¸½ ä½“éªŒäº†ä¸€ä¸‹ åŒ—äº¬é‚®ç”µå¤§å­¦ è®¡ç®—æœº è¢«é¸½ è¢«è€å¸ˆé¸½äº†ğŸ¤¡ï¼Œåæœ‰æƒŠå–œ å¯ä»¥çœ‹åˆ°ï¼Œé¢„æ¨å…çš„æ—¶å€™æˆ‘æ¨å…æ’åæé«˜ï¼Œå…¥è¥æƒ…å†µä¹Ÿç¨å¾®å¥½ç‚¹äº†ã€‚ä½†ç”±äºä»Šå¹´å¤§éƒ¨åˆ†å­¦æ ¡æå‡ç”Ÿæºè´¨é‡ï¼Œé¢„æ¨å…ä»ç„¶è‰°éš¾ã€‚ æµ™è½¯æµ™è½¯æ˜¯æˆ‘é¢„æ¨å…çš„ç¬¬ä¸€ç«™ï¼Œä¹Ÿæ˜¯æˆ‘çš„æœ€ç»ˆå»å‘ã€‚ ä»Šå¹´barå¾ˆé«˜ï¼Œç”±äºæœ‰å¤ä»¤è¥çš„ä¼˜è¥ï¼Œè¿‡äº†åˆç­›ï¼Œä»Šå¹´åŒérk1åŸºæœ¬è¿›ä¸å»ã€‚é¢„æ¨å…æ€»å…±ç­›äº†è¿‘800äººï¼Œçº¿ä¸‹æ¥äº†540äººï¼Œç”Ÿæºæ˜æ˜¾æ¯”å»å¹´æé«˜äº†ï¼Œå¤§æ¦‚90%éƒ½æ˜¯9çˆ·ã€‚ æµ™è½¯å¤è¯•åˆ†ä¸ºæœºè¯•å’Œé¢è¯•ï¼Œæœºè¯•å æ¯”15%ï¼Œç¬¬ä¸€å¤©æ™šä¸Šå¼€å§‹æœºè¯•ï¼Œå…±4é“é¢˜ï¼Œéš¾åº¦ä»¥æ­¤é€’å¢ï¼Œé¢˜ç›®èƒŒæ™¯å‡ä¸èµ¤å£ç›¸å…³ï¼ˆè€ƒå¯Ÿäº†ç®€å•æ•°å­¦ï¼Œdfsï¼Œdpï¼ŒäºŒåˆ†ï¼‰ï¼Œéš¾åº¦æ¯”å»å¹´ç•¥å¤§ï¼Œä½†æ˜¯akäººæ•°æ›´å¤šäº†ï¼Œæˆ‘1ä¸ªåŠå°æ—¶akï¼Œæ’å40+ï¼Œç­‰åˆ°ç»“æŸæ—¶ï¼Œçº¦130ä¸ªakï¼Œ90åˆ†ä»¥ä¸Šçš„200+ã€‚å¬è¯´å¾€å¹´æ˜¯æŒ‰æœºè¯•ç»™é¢è¯•æˆç»©ï¼Œä½†ä»Šå¹´æœºè¯•æ²¡æœ‰åŒºåˆ†åº¦äº†ï¼ˆå¤ªå·äº†ğŸ¤¡ï¼‰ï¼Œè€Œä¸”è€å¸ˆé¢è¯•çš„æ—¶å€™å¥½åƒçœ‹ä¸åˆ°ä½ çš„æœºè¯•æˆç»©ã€‚ 20å·æœºè¯•ï¼Œé¢è¯•æ’åˆ°22å·äº†ï¼Œæ—¶é—´20åˆ†é’Ÿï¼Œæœ‰ä¸ªè®¡æ—¶å™¨ã€‚æµ™è½¯ä¸åŒçš„ç»„é¢è¯•é£æ ¼å¾ˆä¸åŒã€‚æˆ‘ä»¬ç»„é¦–å…ˆæ¥ä¸ª1åˆ†é’Ÿè‹±æ–‡è‡ªæˆ‘ä»‹ç»ï¼Œç„¶åå¼€å§‹ç”¨pptè®²5-8åˆ†é’Ÿã€‚æ¥ä¸‹æ¥é—®ä¸“ä¸šè¯¾ï¼Œæˆ‘é€‰æ‹©äº†è®¡ç½‘ï¼Œé—®äº†ä¸¤ä¸ªé—®é¢˜ï¼Œæ²¡å¬æ‡‚ï¼ˆğŸ¤¡ï¼‰ï¼Œç„¶åæ¢äº†æ•°æ®ç»“æ„ã€‚æ€ä¹ˆæ±‚æ ‘çš„ç›´å¾„ï¼Œæ€ä¹ˆæ±‚å›¾çš„ç›´å¾„ï¼Œæ ‘çš„ç›´å¾„å’Œå›¾çš„ç›´å¾„æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚å¦‚ä½•ç»´æŠ¤æ•°ç»„ä¸­çš„æœ€å¤§å€¼ï¼Œå¦‚ä½•å¿«é€Ÿæ±‚å‡ºä¸­ä½æ•°ã€‚ç”¨è¿‡stlå§ï¼Œå¦‚æœéœ€è¦ä¸€ä¸ªè‡ªåŠ¨æ’åºçš„é›†åˆï¼Œå¯ä»¥æœ‰é‡å¤çš„å…ƒç´ ï¼Œåº”è¯¥ç”¨ä»€ä¹ˆã€‚multisetæ’å…¥ä¸¤æ¬¡2ï¼Œeraseä¸€æ¬¡2ï¼Œç»“æœæ˜¯ä»€ä¹ˆã€‚sortå‡½æ•°ä»å°åˆ°å¤§æ’åºï¼Œæ¯”è¾ƒæ€ä¹ˆå†™ï¼Œå¦‚æœæŠŠ&lt;æ”¹æˆ&lt;&#x3D;æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚ç­”çš„ç¨€çƒ‚ï¼Œç„¶åå¼€å§‹é—®é¡¹ç›®ï¼Œé¡¹ç›®é‡Œæœ‰ä¸ªæŠŠnä¸ªæ¨¡å‹åˆ†é…åˆ°mä¸ªè®¾å¤‡ï¼Œæˆ‘ä½¿ç”¨çš„çº¿æ€§è§„åˆ’ï¼Œè€å¸ˆè¯´è¿™æ˜¯ä¸€ä¸ªç®—æ³•é—®é¢˜ï¼Œåº”è¯¥ç”¨ä»€ä¹ˆç®—æ³•è§£å†³ï¼Œï¼ˆå®Œå…¨ä¸æ‡‚ğŸ¤¡ï¼‰ï¼Œç„¶ååˆé—®äº†ä¸€äº›é¡¹ç›®çš„ç»†èŠ‚ã€‚æœ€åé—®åˆ°ï¼Œå¤ä»¤è¥åœ¨å“ªä¸ªè¥ï¼Œå“ªä¸ªè¯¾é¢˜ç»„ï¼Œå¹²äº†äº›ä»€ä¹ˆã€‚å°±è¿™æ ·ç»“æŸäº†ã€‚ æ€»ä¹‹é¢å´©äº†ï¼Œå‡ºæ¥åæ•´ä¸ªäººéƒ½ä¸å¥½äº†ï¼Œé‚£ä¸ªä¸»é—®çš„è€å¸ˆåº”è¯¥æ˜¯æ‰“acmçš„ï¼Œçœ‹è§æˆ‘ç®—æ³•ä¸é”™ï¼Œç›´æ¥é—®åˆ°åº•ã€‚ã€‚ã€‚å¯æˆ‘ä¸æ˜¯acmerå•ŠğŸ˜­ã€‚åœ¨å¤–é¢åäº†ä¸€ä¼šå„¿ï¼Œæ„Ÿè§‰å¤©å¡Œäº†ï¼Œç„¶åå°±å»æ­å·è¥¿æ¹–æ•£æ•£å¿ƒï¼Œé¡ºä¾¿å‚åŠ è¥¿ç”µæ­çš„å¤è¯•ï¼ˆæœ¬æ¥æ‰“ç®—å¦‚æœç¨³äº†çš„è¯ï¼Œå°±ä¸å‚åŠ äº†ï¼‰ã€‚ 25å·å‡ºäº†ç»“æœï¼Œæ’å190+&#x2F;540ï¼Œå€™è¡¥ç¬¬ä¸‰ï¼Œç„¶åç¬¬äºŒå¤©å°±è¡¥åˆ°äº†ï¼Œä¸€æ­¥ç™»å¤©ï¼Œè·¨è¶ŠåŒéã€åŒä¸€æµã€211ã€æ™®é€š985è¿™äº›å­¦é™¢æ­§è§†é“¾ç›´æ¥æ¥åˆ°é¡¶æµ985æ°´å¹³ã€‚ psï¼šæµ™è½¯æ˜å¹´å°±æ¢æ–°æ ¡åŒºäº†ï¼Œæ¥äº†å¾ˆå¤šæ–°å¯¼å¸ˆï¼Œç”Ÿæºè´¨é‡ä¹Ÿä¸Šæ¥äº†ï¼Œä»¥åä¼šè¶Šæ¥è¶Šå¥½ï¼Œ24å…¥æµ™è½¯&#x3D;49å…¥å…šï¼ è¥¿ç”µæ­æ¥ä¸Šï¼Œé¢å®Œäº†æµ™è½¯ï¼Œæ„Ÿè§‰å¤§å¯„ï¼Œå°±å»æ­å·é¢è¥¿ç”µæ­äº†ï¼Œå‡†å¤‡æ‹¿ä¸ªä¿åº•ã€‚ è¥¿ç”µæ­éœ€è¦å…ˆè”ç³»å¯¼å¸ˆï¼Œè¿™ä¸ªè€å¸ˆæ˜¯æˆ‘åœ¨æŠ¥å®Œç³»ç»Ÿåä¸»åŠ¨æ‰¾æˆ‘çš„ï¼Œç®€å•èŠäº†ä¸€ä¸‹ï¼Œæ–¹å‘ä¹Ÿè¿˜è¡Œï¼Œç„¶åå°±é€‰ä»–äº†ã€‚ å¤è¯•åˆ†ä¸ºç¬”è¯•å’Œé¢è¯•ï¼Œç¬”è¯•å†…å®¹ä¸ºé€šä¿¡ï¼Œæ•°æ®ç»“æ„ï¼Œè®¡ç»„ï¼Œè®¡ç½‘ï¼Œå¯†ç å­¦ã€‚åªä¼šå†™æ•°æ®ç»“æ„ã€‚ é¢è¯•å…ˆè‹±è¯­è‡ªæˆ‘ä»‹ç»ï¼Œç„¶åç”¨è‹±è¯­ä»‹ç»ä¸€ä¸ªé¡¹ç›®ã€‚æ¥ç€å°±æ˜¯é—®é¡¹ç›®çš„ä¸€äº›ç»†èŠ‚ã€‚æœ€åè¿˜æœ‰æ€æ”¿é¢˜ï¼Œæ²¡ç­”ä¸Šæ¥ğŸ¤¡ã€‚ é¢å®Œæ„Ÿè§‰æ¯”è¾ƒæ°´ï¼Œç„¶åè¿‡äº†å‡ å¤©ä¹Ÿæ²¡æ¶ˆæ¯ï¼Œæˆ‘ä¹Ÿæ²¡å»è”ç³»è€å¸ˆï¼Œå…¸å‹çš„å­¦æ ¡å’Œå­¦ç”Ÿäº’é¸½ğŸ•Šï¸ï¼Œåæ­£æˆ‘æœ‰æµ™è½¯offeräº†ï¼Œä¸ç®¡ä»–äº†ã€‚ é‡å¤§è®¡ç®—æœºé‡å¤§ä»Šå¹´barå¾ˆè¿·ï¼Œè®¡ç®—æœºå¡rk1ï¼Œè½¯ä»¶å¡åŒä¸€æµï¼Œè€Œä¸”å¤è¯•è´¹150å…ƒã€‚ 26å·é¢è¯•ï¼Œäº¤äº†é’±éƒ½é¸½äº†1&#x2F;3ã€‚é¢è¯•å†…å®¹ï¼šå…ˆè‹±è¯­è‡ªæˆ‘ä»‹ç»ï¼Œç„¶åå£è¯­å¯¹è¯ï¼ŒåŠå…¶ç®€å•ï¼Œæ„Ÿè§‰åƒæ˜¯å°å­¦ç”Ÿå¯¹è¯ï¼Œé—®äº†æˆ‘çš„sportsã€‚ç„¶åä¸“ä¸šè¯¾é—®äº†æ•°ç»„å¦‚ä½•æŸ¥è¯¢å›ºå®šåŒºé—´çš„å’Œï¼Œä½¿ç”¨å‰ç¼€å’Œã€‚æ¥ç€é—®é¡¹ç›®ï¼Œé‡å¤§çš„è€å¸ˆæ˜¯å”¯ä¸€ä¸€ä¸ªé—®äº†æˆ‘æ•°æ¨¡çš„é¡¹ç›®ï¼Œé—®çš„è¿˜æ¯”è¾ƒç»†ã€‚ç„¶åé—®äº†æˆ‘æŠ¥äº†å“ªäº›å­¦æ ¡ï¼Œæœ‰ä»€ä¹ˆofferï¼Œå…¶å®å½“æ—¶æˆ‘è¿˜æ˜¯0fferã€‚ç„¶åå°±ç»“æŸäº†ã€‚ ç”±äºçŸ¥é“æµ™è½¯è‚¯å®šèƒ½è¡¥åˆ°ï¼Œæ‰€ä»¥é‡å¤§é¢è¯•ä¹Ÿæ²¡æ€ä¹ˆä¸Šå¿ƒï¼Œè€Œä¸”é—®çš„ä¹Ÿæ¯”è¾ƒæ°´ã€‚ ç¬¬äºŒå¤©å‘Šè¯‰æˆ‘å€™è¡¥ï¼Œæ²¡æœ‰åå•ã€‚928ä¸‹åˆæ‰“ç”µè¯è¯´æˆ‘å€™è¡¥åˆ°äº†ï¼Œè®¡ç®—æœºå­¦ç¡•ï¼Œç„¶åæˆ‘æ‹’äº†ã€‚ psï¼šå¾€å¹´ç‚¹å‡»å°±é€çš„é‡å¤§ä¸è§äº†ã€‚ã€‚ã€‚ å†³æˆ˜929ä»Šå¹´ç³»ç»Ÿåˆæ”¹äº†ï¼Œ928ä¸Šåˆ9ç‚¹å¡«å¿—æ„¿ï¼Œ929ä¸Šåˆ9ç‚¹æ‹›ç”Ÿå•ä½å¼€å§‹å½•å–ï¼Œæ‰€ä»¥ä»Šå¹´çš„é¸½å­ä¼šåœ¨928å…ˆé£ä¸€æ‰¹ï¼Œç„¶å929å†é£ä¸€æ‰¹ã€‚ é¦–å…ˆç§‘æ™®ä¸€ä¸‹æ¨å…ç³»ç»Ÿ ä¸€ä¸ªå­¦ç”Ÿå¯ä»¥å¡«å†™ä¸‰ä¸ªç‹¬ç«‹å¿—æ„¿ ä¸€ä¸ªé™¢æ ¡å¯ä»¥ç»™å­¦ç”Ÿå‘æ”¾å¤è¯•ã€æ‹Ÿå½•å–é€šçŸ¥ å…ˆæ¥å—å¤è¯•ï¼Œå†æ¥å—æ‹Ÿå½•å– ä½†å¤è¯•ã€æ‹Ÿå½•å–ï¼Œéƒ½æ˜¯æœ‰æ—¶æ•ˆæ€§çš„ï¼Œæ¯”å¦‚10åˆ†é’Ÿå†…æ²¡æœ‰æ¥å—ï¼Œæ‹›ç”ŸåŠå¯èƒ½ä¼šæ”¶å›ä½ çš„offer åªè¦ä½ æ¥å—äº†æ‹Ÿå½•å–ï¼Œä½ çš„ä¿ç ”ç”Ÿæ¶¯å°±ä¼šç»“æŸ 9æœˆ28æ—¥9ç‚¹~9æœˆ29æ—¥9ç‚¹è¿™æ®µæ—¶é—´ï¼Œå­¦ç”Ÿå¯ä»¥å¡«å†™å¿—æ„¿ æ¯ä¸ªå¿—æ„¿å¡«å†™ä¹‹åè‡ªåŠ¨ä¸Šé”ï¼Œ48å°æ—¶ä¸å¯ä»¥ä¿®æ”¹ï¼ˆä½†æ˜¯é™¢æ ¡æ•™åŠ¡è€å¸ˆï¼Œå¯ä»¥å¸®ä½ è§£é”ä½ çš„å¿—æ„¿ï¼‰ 9æœˆ29æ—¥9ç‚¹ä¹‹åé™¢æ ¡æ‰å¯ä»¥å¼€å§‹å‘æ”¾å¤è¯•ã€æ‹Ÿå½•å–é€šçŸ¥ æ¯ä¸ªå¿—æ„¿æ˜¯å¹³è¡Œçš„ï¼Œé™¢æ ¡çœ‹ä¸åˆ°ä½ æ˜¯ç¬¬å‡ ä¸ªå¡«å†™çš„è¿™ä¸ªå¿—æ„¿ ä½†æ˜¯é™¢æ ¡ç»™ä½ å‘æ”¾é€šçŸ¥çš„æ—¶å€™ï¼Œå¯ä»¥çœ‹åˆ°ä½ æ¥å—äº†å“ªäº›å­¦æ ¡çš„å¤è¯• é¸½é“¾ååº”ï¼šè¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£çš„ç°è±¡ åŸå› 1ï¼š å¯ä»¥ç†è§£ä¸º28å®šå¾‹ï¼Œ80%çš„offeråœ¨20%çš„äººä¸­ï¼Œä½†ä¹Ÿä¸å®Œå…¨æ˜¯ã€‚ åŸå› 2ï¼š æ¯”å¦‚å­¦ç”ŸAèƒ½åœ¨å¦å¤§å¤ä»¤è¥æ‹¿åˆ°ç¬¬1ï¼Œé‚£ä¹ˆä»–ç»ä¸å¯èƒ½åªæœ‰å¦å¤§è¿™ä¸ªofferï¼ŒAå¾ˆå¯èƒ½åœ¨åç§‘æ‹¿åˆ°offerç¬¬20æˆ–30ï¼Œäººå¤§æ‹¿åˆ°offerç¬¬60è¿™æ ·ï¼Œè€Œå¤æ—¦æ‹¿åˆ°å€™è¡¥åå•ç¬¬5ã€‚ ç»“æœAå‰é¢å‚åŠ å¤æ—¦å¤ä»¤è¥çš„äººåˆåŒæ—¶æ‹¿åˆ°æ¸…åŒ—ã€è®¡ç®—æ‰€çš„offeräº†ï¼Œçº·çº·é‡Šæ”¾å¤æ—¦offerï¼Œç„¶åAè¢«å€™è¡¥åˆ°äº†ï¼Œäºæ˜¯Aå°±é‡Šæ”¾å¦å¤§ã€åç§‘ã€äººå¤§çš„offerã€‚åœ¨å‰é¢ä¸‰ä¸ªå­¦æ ¡çš„äººï¼Œåˆå› ä¸ºAçš„é‡Šæ”¾è¢«å€™è¡¥åˆ°äº†ã€‚ ç„¶åè¿™äº›è¢«å€™è¡¥åˆ°çš„äººï¼Œç»§ç»­å¾€ä¸‹ä¸€å±‚é‡Šæ”¾offerï¼Œæ¯”å¦‚è¥¿ç”µã€å—èˆªç­‰ï¼Œæœ€åå€™è¡¥å’Œé¸½å­å°±ä¼šåƒæ ‘å½¢ç»“æ„ä¸€æ ·ç–¯ç‹‚ä¸‹ä¼ ã€‚ å› ä¸º929ä¹‹å‰æ‹¿çš„offeréƒ½ä¸æ˜¯é“offerï¼Œå­¦ç”Ÿè‡ªå·±ä¹Ÿå¯èƒ½è¢«å¼±comé¸½ï¼Œéœ€è¦æ‹¿å¼ºcomé™¢æ ¡ä¿åº•ã€‚ä»¥åŠå¯èƒ½å­¦ç”Ÿè‡ªèº«ä¹Ÿæœ‰å¤šä¸ªæ¢¦æ ¡ï¼Œéƒ½ä¼šå°è¯•æ‹¿offerã€‚ åŸå› 3ï¼š è¿™ä¸ªç°è±¡å¾€å¾€å‡ºç°åœ¨æ‹›ç”ŸåŠå¼€å§‹å½•å–æ—¶ï¼Œæ¯•ç«Ÿæ¯ä¸ªäººåªèƒ½å»è¯»ä¸€ä¸ªå­¦æ ¡ï¼Œä½ å¯èƒ½æœ‰å·®ä¸€ç‚¹çš„å­¦æ ¡Bçš„å‡†offerï¼Œä¹Ÿæœ‰æ¢¦æ ¡Cçš„å€™è¡¥ã€‚ æ¯”å¦‚å·®ä¸€ç‚¹å­¦æ ¡ï¼Œè¦æ±‚ä½ 1åˆ†é’Ÿæ¥å—æ‹Ÿå½•å–ï¼Œå¦åˆ™ä½œåºŸã€‚é‚£ä¹ˆä½ é¢å¯¹çš„åªæœ‰å››ç§ç»“æœ æ¥å—ï¼Œä½ æ²¡æœ‰å€™è¡¥åˆ°ï¼Œä¸€ä¸ªå¾ˆæ£’çš„ç»“æœï¼Œä½ æœ€ç»ˆå»äº†å­¦æ ¡B æ¥å—ï¼Œä½ å€™è¡¥åˆ°äº†ï¼Œä½ ç—›å¤±æ¢¦æ ¡éå¸¸é—æ†¾ï¼Œä½†å¥½åƒè¿˜èƒ½æ¥å—ï¼Œä½ æœ€ç»ˆå»äº†å­¦æ ¡B æ‹’ç»ï¼Œä½ ç­‰åˆ°äº†å€™è¡¥ï¼Œä¸Šå²¸æ¢¦æ ¡ï¼Œä½ æœ€ç»ˆå»äº†æ¢¦æ ¡C æ‹’ç»ï¼Œä½ æ²¡æœ‰ç­‰åˆ°å€™è¡¥ï¼Œä¸€ç¬é—´æ²¡æœ‰ä¹¦è¯»äº†ï¼Œæˆä¸ºloser å¾ˆå¤šäººæ‹…å¿ƒæ²¡æœ‰ä¹¦è¯»è€Œæ¥å—äº†æ‹Ÿå½•å–ï¼Œå‡è®¾å€™è¡¥åˆ°æ—¶å·²ç»ç³»ç»Ÿå·²ç»é”äº†ï¼Œåªèƒ½ç»§ç»­å¾€ä¸‹æ»šåŠ¨å€™è¡¥é˜Ÿåˆ— ä¸€äº›è§é—»1ã€å¥½å¤šå­¦æ ¡é¸½ç©¿äº†ï¼Œè¯¥ï¼ 2ã€åœ£ç»å°±æ˜¯åœ£ç»ï¼ 3ã€ä¸€å®šè¦æµ·æŠ•ï¼ 4ã€å°½é‡ä¸è¦é¸½è€å¸ˆï¼Œè¦é¸½æ—©ç‚¹é¸½ï¼Œåˆ«ç­‰åˆ°å½•å–é‚£å¤©ä¸´æ—¶é¸½ï¼Œä½ è‡ªå·±çˆ½äº†ï¼Œä¸‹ä¸€å±Šå­¦å¼Ÿå­¦å¦¹é­æ®ƒäº†ï¼Œæ›´ä¸è¦é›†é‚®ï¼ 5ã€8æœˆè”ç³»äº†ä¸€ä¸ªåŒ—é‚®è€å¸ˆï¼ˆ15ç»„ï¼‰ï¼Œè¿˜è¿›ç»„æ‰“å·¥ä¸€æ®µæ—¶é—´ï¼Œç„¶åä¸­ç§‹èŠ‚æŠŠæˆ‘é¸½äº†ã€‚ã€‚ã€‚928çš„æ—¶å€™åˆè·Ÿæˆ‘è¯´æœ‰å­¦ç¡•åé¢ğŸ¤¡ã€‚ 6ã€ä»Šå¹´æƒ³å¤–ä¿çœŸçš„æŒºéš¾çš„ï¼Œæˆ‘ä»¬å­¦é™¢å»äº†ä¸å°‘211ï¼Œç”šè‡³è¿˜æœ‰æœ¬æ ¡ã€‚ 7ã€è¿˜æœ‰å¥½å¤šååœºé¢ï¼Œæœ€åå‡ å¤©ä¹å­çœŸå¤šï¼Œå¼ºçƒˆå»ºè®®åŠ å…¥ç»¿ç¾¤ 943826679 å¦å¤–ï¼Œç»™è¿˜åœ¨å‡†å¤‡ä¿ç ”çš„uuä»¬å‘Šè¯«ï¼š é¦–å…ˆï¼Œé“­è®°ä½å¹¸å­˜è€…åå·® å…¶æ¬¡ï¼Œé€‰æ‹©å¤§äºåŠªåŠ› ä¸è¦ç›²ç›®è‡ªä¿¡ï¼Œä¸è¦æ„ŸåŠ¨è‡ªæˆ‘å¼çš„åŠªåŠ› ä¸è¦å­¤æ³¨ä¸€æ·ï¼Œå¤šä¸€ç‚¹é€‰é¡¹ï¼Œæœ‰æ—¶å€™çœŸçš„è¿æ°”&gt;å®åŠ› æ€»ç»“ä¸‰å¹´çš„é•¿è·‘ç»ˆäºç”»ä¸Šäº†å¥å·ï¼Œæœ€åé‚£ä¸€æ®µæ—¶é—´éƒ½åœ¨ç„¦è™‘ï¼Œç»ˆç©¶è¿˜æ˜¯æŒºè¿‡æ¥äº†ã€‚åœ¨å››é0ç§‘ç ”çš„æƒ…å†µå’Œä»Šå¹´åœ°ç‹±çº§çš„å¤–ä¿å½¢åŠ¿ä¸‹ï¼Œæ„Ÿè§‰å·²ç»æ˜¯æˆ‘èƒ½æ‰¾åˆ°çš„æœ€ä¼˜è§£äº†ã€‚ä¸€ä¸ªä¸ªé€‰æ‹©å¡‘é€ äº†äººç”Ÿï¼Œè¿™æ¬¡all in æµ™è½¯ï¼Œå¸Œæœ›ä¸€åˆ‡éƒ½æ˜¯æœ€å¥½çš„å®‰æ’ã€‚ æœ€åï¼Œæ„¿æ‰€æœ‰çš„ä¿ç ”erä»¬ï¼Œæœ€ç»ˆéƒ½å–å¾—å¿ƒä»ªçš„offerï¼Œä¸Šå²¸æ¢¦æ ¡","tags":["ä¿ç ”","è®¡ç®—æœº"],"categories":["ä¿ç ”"]},{"title":"æ´›è°·é¢˜å•","path":"/2024/09/19/æ´›è°·é¢˜å•/","content":"æ´›è°·ç»¼åˆé¢˜å•è¯•æœºé¢˜ ä¸‰é“è¯•æœºé¢˜ç›®ã€‚ P1000 è¶…çº§ç›ä¸½æ¸¸æˆ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot; ******** &quot;; cout&lt;&lt;&quot; ************ &quot;;\tcout&lt;&lt;&quot; ####....#. &quot;; cout&lt;&lt;&quot; #..###.....##.... &quot;; cout&lt;&lt;&quot; ###.......###### ### ### &quot;; cout&lt;&lt;&quot; ........... #...# #...# &quot;; cout&lt;&lt;&quot; ##*####### #.#.# #.#.# &quot;; cout&lt;&lt;&quot; ####*******###### #.#.# #.#.# &quot;; cout&lt;&lt;&quot; ...#***.****.*###.... #...# #...# &quot;; cout&lt;&lt;&quot; ....**********##..... ### ### &quot;; cout&lt;&lt;&quot; ....**** *****.... &quot;; cout&lt;&lt;&quot; #### #### &quot;; cout&lt;&lt;&quot; ###### ###### &quot;; cout&lt;&lt;&quot;############################################################## &quot;; cout&lt;&lt;&quot;#...#......#.##...#......#.##...#......#.##------------------# &quot;; cout&lt;&lt;&quot;###########################################------------------# &quot;; cout&lt;&lt;&quot;#..#....#....##..#....#....##..#....#....##################### &quot;; cout&lt;&lt;&quot;########################################## #----------# &quot;; cout&lt;&lt;&quot;#.....#......##.....#......##.....#......# #----------# &quot;; cout&lt;&lt;&quot;########################################## #----------# &quot;; cout&lt;&lt;&quot;#.#..#....#..##.#..#....#..##.#..#....#..# #----------# &quot;; cout&lt;&lt;&quot;########################################## ############ &quot;; return 0;&#125; P1001 A+B Problem 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b; return 0;&#125; P1008 ä¸‰è¿å‡» 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool st[10];string str;void dfs(int x) &#123;\tif (x == 9) &#123; int a = stoi(str.substr(0, 3)); int b = stoi(str.substr(3, 3)); int c = stoi(str.substr(6, 3)); if (a * 2 == b &amp;&amp; a * 3 == c) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; &#125;\t&#125;\tfor (int i = 1; i &lt; 10; i++) &#123; if (!st[i]) &#123; st[i] = true; str.push_back(i + &#x27;0&#x27;); dfs(x + 1); st[i] = false; str.pop_back(); &#125;\t&#125;&#125;int main()&#123;\tdfs(0);\treturn 0;&#125; å…¥é—¨é˜¶æ®µ æœ¬éƒ¨åˆ†å†…å®¹é’ˆå¯¹å…¥é—¨ OIer ï¼Œä¸»è¦æ˜¯è¯­è¨€åŸºç¡€å†…å®¹ã€‚ ä»é›¶å¼€å§‹ è¯­è¨€åŸºç¡€é¢˜ã€‚ P1421 å°ç‰ä¹°æ–‡å…· 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b;\tcin &gt;&gt; a &gt;&gt; b;\tint c = a * 10 + b;\tcout &lt;&lt; c / 19; return 0;&#125; P1909 ä¹°é“…ç¬” 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a1, a2, b1, b2, c1, c2, res1, res2, res3, res;\tcin &gt;&gt; n &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2 &gt;&gt; c1 &gt;&gt; c2;\tif (n % a1 == 0) res1 = n / a1 * a2;\telse res1 = (n / a1 + 1) * a2;\tif (n % b1 == 0) res2 = n / b1 * b2;\telse res2 = (n / b1 + 1) * b2;\tif (n % c1 == 0) res3 = n / c1 * c2;\telse res3 = (n / c1 + 1) * c2;\tres = min(res1, min(res2, res3));\tcout &lt;&lt; res; return 0;&#125; P1089 æ´¥æ´¥çš„å‚¨è“„è®¡åˆ’ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123;\tint x, rem = 0; double res; for (int i = 1; i &lt;= 12; i++) &#123; cin &gt;&gt; x; rem = rem + 300 - x; if (rem &lt; 0) &#123; cout &lt;&lt; -i; return 0; &#125; else if (rem &gt;= 100) &#123; res += (rem / 100) * 100; rem %= 100; &#125;\t&#125;\tcout &lt;&lt; res * 1.2 + rem; return 0;&#125; P1085 ä¸é«˜å…´çš„æ´¥æ´¥ 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123;\tint a, b;\tint res = 0, mind = 0;\tfor (int i = 1; i &lt;= 7; i++) &#123; cin &gt;&gt; a &gt;&gt; b; int t = min(0, 8 - a - b); if (mind &gt; t) &#123; res = i; mind = t; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1035 çº§æ•°æ±‚å’Œ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123;\tint k;\tcin &gt;&gt; k;\tdouble t;\tfor (int i = 1; i &lt; 10000000; i++) &#123; t += 1.0 / i; if (t &gt; k) &#123; cout &lt;&lt; i; break; &#125;\t&#125; return 0;&#125; P1980 è®¡æ•°é—®é¢˜ #include &lt;iostream&gt; using namespace std; int main() &#123; int n, x, res = 0; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; i++) &#123; int t = i; while (t &gt; 0) &#123; if (t % 10 == x) res++; t /= 10; &#125; &#125; cout &lt;&lt; res; return 0; &#125; 1234567891011121314151617181920212223242526272829303132- [P1014 Cantorè¡¨](https://www.luogu.com.cn/problem/P1014)```c++#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1000;string g[N][N];int main() &#123;\tint n, i = 1, j = 1, t = 1, flag = 1;\tcin &gt;&gt; n;\twhile (t &lt; n) &#123; if (flag == 1) &#123; j++; flag = 2; &#125; else if (flag == 2) &#123; i++; j--; if(j == 1) flag = 3; &#125; else if (flag == 3) &#123; i++; flag = 4; &#125; else if (flag == 4) &#123; i--; j++; if (i == 1) flag = 1; &#125; t++;\t&#125;\tcout &lt;&lt; i &lt;&lt; &quot;/&quot; &lt;&lt; j; return 0;&#125; P1307 æ•°å­—åè½¬ 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;\tstring n;\tcin &gt;&gt; n;\tif (n[0] == &#x27;-&#x27;) &#123; cout &lt;&lt; &#x27;-&#x27;; n = n.substr(1);\t&#125; else if (n == &quot;0&quot;) &#123; cout &lt;&lt; 0; return 0;\t&#125;\treverse(n.begin(), n.end());\twhile (n[0] == &#x27;0&#x27;) &#123; n.erase(0, 1);\t&#125;\tcout &lt;&lt; n; return 0;&#125; ä¼˜åŒ– 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123;\tint n, m = 0;\tcin &gt;&gt; n;\twhile (n) &#123; m = m * 10 + n % 10; n /= 10;\t&#125;\tcout &lt;&lt; m; return 0;&#125; æ•°ç»„åŸºç¡€ æ•°ç»„å¯ä»¥ç”¨äºå­˜å‚¨å¤§é‡çš„ä¿¡æ¯ã€‚ P1046 é™¶é™¶æ‘˜è‹¹æœ 1234567891011121314#include &lt;iostream&gt;using namespace std;int nums[11], n, res;int main() &#123; for (int i = 0; i &lt; 10; i++) &#123; cin &gt;&gt; nums[i];\t&#125;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; 10; i++) &#123; if (n + 30 &gt;= nums[i]) res++;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1047 æ ¡é—¨å¤–çš„æ ‘ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;bool nums[10001];int main() &#123; int n, m, l, r; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r; for (int j = l; j &lt;= r; j++) nums[j] = true;\t&#125;\tint res = 0;\tfor (int i = 0; i &lt;= n; i++) if (!nums[i]) res++;\tcout &lt;&lt; res; return 0;&#125; P1427 å°é±¼çš„æ•°å­—æ¸¸æˆ 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; vector&lt;int&gt; nums; int x; while (true) &#123; cin &gt;&gt; x; if (x == 0) break; nums.push_back(x);\t&#125;\treverse(nums.begin(), nums.end());\tfor (auto it: nums) cout &lt;&lt; it &lt;&lt; &quot; &quot;; return 0;&#125; P2141 ç å¿ƒç®—æµ‹éªŒ 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int nums[101];bool st[20001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; st[nums[i]] = true;\t&#125;\tset&lt;int&gt; res;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[i] == nums[j]) continue; if (st[nums[i] + nums[j]]) res.insert(nums[i] + nums[j]); &#125;\t&#125;\tcout &lt;&lt; res.size(); return 0;&#125; P5594 ã€XR-4ã€‘æ¨¡æ‹Ÿèµ› 123456789101112131415161718#include &lt;iostream&gt;#include &lt;set&gt; using namespace std;set&lt;int&gt; nums[1001];int main() &#123; int n, m, k, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; nums[x].insert(j); &#125;\t&#125;\tfor (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; nums[i].size() &lt;&lt; &quot; &quot;;\t&#125; return 0;&#125; å­—ç¬¦ä¸²åŸºç¡€ å­—ç¬¦ä¸²æ˜¯ç‰¹æ®Šçš„æ•°ç»„ï¼Œä½†å®ƒä¹Ÿæœ‰å¾ˆå¤šè‡ªèº«çš„ç‰¹ç‚¹ã€‚ P5015 æ ‡é¢˜ç»Ÿè®¡ 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;\tstring s; getline(cin, s); int res = 0;\tfor (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] != &#x27; &#x27; &amp;&amp; s[i] != &#x27; &#x27;) res++;\t&#125; cout &lt;&lt; res; return 0;&#125; P1055 ISBNå·ç  12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123;\tint a, b, c;\tchar d, e;\tscanf(&quot;%d-%d-%d-%c&quot;, &amp;a, &amp;b, &amp;c, &amp;d);\tint t = (a + (b / 100) * 2 + (b % 100 / 10) * 3 + (b % 10) * 4 + (c / 10000) * 5 + (c % 10000 / 1000) * 6 + (c % 1000 / 100) * 7 + (c % 100 / 10) * 8 + (c % 10) * 9 ) % 11;\tif (t == 10) e = &#x27;X&#x27;;\telse e = &#x27;0&#x27; + t;\tif (d == e) cout &lt;&lt; &quot;Right&quot;;\telse cout &lt;&lt; a &lt;&lt; &quot;-&quot; &lt;&lt; b &lt;&lt; &quot;-&quot; &lt;&lt; c &lt;&lt; &quot;-&quot; &lt;&lt; e; return 0;&#125; P1308 ç»Ÿè®¡å•è¯æ•° 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;\tstring p, s;\tcin &gt;&gt; p;\tgetchar();\tfor (int i = 0; i &lt; p.size(); i++) p[i] = tolower(p[i]);\tint id = -1, cnt = 0, j = 0;\tgetline(cin, s);\tfor (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27; &#x27;) continue; int j = i; for (;j &lt; s.size(); j++) &#123; if (s[j] == &#x27; &#x27;) break; s[j] = tolower(s[j]); &#125; if (p == s.substr(i, j - i)) &#123; if (id == -1) id = i; cnt++; &#125; i = j;\t&#125;\tif (id == -1) cout &lt;&lt; id;\telse cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; id; return 0;&#125; P2010 å›æ–‡æ—¥æœŸ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int days[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int main() &#123;\tint date1, date2, res = 0;\tcin &gt;&gt; date1 &gt;&gt; date2;\tfor (int i = 1; i &lt;=12; i++) &#123; for (int j = 1; j &lt;= days[i]; j++) &#123; int t = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10; t = t * 10000 + i * 100 + j; if (t &gt;= date1 &amp;&amp; t &lt;= date2) res++; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1012 æ‹¼æ•° 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string nums[21];bool cmp(string a, string b) &#123;\treturn a + b &gt; b + a;&#125;int main() &#123;\tint n;\tcin &gt;&gt; n;\tstring a;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i];\t&#125;\tsort(nums, nums + n, cmp);\tfor (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i];\t&#125; return 0;&#125; P5587 æ‰“å­—ç»ƒä¹  1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt; s, t;int main() &#123;\tstring str;\twhile(getline(cin, str)) &#123; if (str == &quot;EOF&quot;) break; string a; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;&lt;&#x27;) &#123; if (!a.empty()) a.pop_back(); &#125; else a.push_back(str[i]); &#125; s.push_back(a);\t&#125;\twhile(getline(cin, str)) &#123; if (str == &quot;EOF&quot;) break; string a; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;&lt;&#x27;) &#123; if (!a.empty()) a.pop_back(); &#125; else a.push_back(str[i]); &#125; t.push_back(a);\t&#125;\tint time, cnt = 0;\tcin &gt;&gt; time;\tfor (int i = 0; i &lt; t.size(); i++) &#123; for (int j = 0; j &lt; min(s[i].size(), t[i].size()); j++) &#123; if (s[i][j] == t[i][j]) cnt++; &#125;\t&#125;\tcout &lt;&lt; cnt * 60 / time; return 0;&#125; å‡½æ•°ï¼Œé€’å½’åŠé€’æ¨ è¿™æ˜¯åˆå­¦è€…æœ€éš¾ç†è§£çš„éƒ¨åˆ†ï¼Œå»ºè®®ç”»å‡ºé€’å½’å›¾æ¥ç†è§£é€’å½’çš„è¿‡ç¨‹ã€‚ P1028 æ•°çš„è®¡ç®— 123456789101112131415#include &lt;iostream&gt;using namespace std;int nums[1001];int main() &#123;\tint n;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i / 2; j++) &#123; nums[i] += nums[j]; &#125; nums[i]++;\t&#125;\tcout &lt;&lt; nums[n]; return 0;&#125; P1036 é€‰æ•° 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[21], n, k, res;bool st[10000001];void dfs(int a, int start, int t) &#123;\tif (a == k) &#123; if (!st[t]) res++; return;\t&#125;\tfor (int i = start; i &lt; n; i++) &#123; dfs(a + 1, i + 1, t + nums[i]);\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; k;\tst[0] = st[1] = true;\tfor (int i = 2; i &lt; 10000001; i++) &#123; if (!st[i]) &#123; for (int j = i + i; j &lt; 10000001; j += i) st[j] = true; &#125;\t&#125;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tdfs(0, 0, 0);\tcout &lt;&lt; res; return 0;&#125; P1464 Function 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;typedef long long LL;LL dp[21][21][21];int main() &#123;\tfor (int i = 0; i &lt; 21; i++) &#123; for (int j = 0; j &lt; 21; j++) &#123; dp[0][i][j] = dp[i][0][j] = dp[i][j][0] = 1; &#125;\t&#125;\tfor (int i = 1; i &lt; 21; i++) &#123; for (int j = 1; j &lt; 21; j++) &#123; for (int k = 1; k &lt; 21; k++) &#123; if (i &lt; j &amp;&amp; j &lt; k) &#123; dp[i][j][k] = dp[i][j][k-1] + dp[i][j-1][k-1] - dp[i][j-1][k]; &#125; else &#123; dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j-1][k-1]; &#125; &#125; &#125;\t&#125;\tLL a, b, c;\twhile (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) &#123; if (a == -1 &amp;&amp; b == -1 &amp;&amp; c == -1) break; if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) printf(&quot;w(%lld, %lld, %lld) = 1 &quot;, a, b, c); else if (a &gt; 20 || b &gt; 20 || c &gt; 20) printf(&quot;w(%lld, %lld, %lld) = %lld &quot;, a, b, c, dp[20][20][20]); else printf(&quot;w(%lld, %lld, %lld) = %lld &quot;, a, b, c, dp[a][b][c]);\t&#125; return 0;&#125; P5534 ã€XR-3ã€‘ç­‰å·®æ•°åˆ— 123456789#include &lt;iostream&gt;using namespace std;int main() &#123;\tlong long a, b, c;\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\tlong long res = c * a + c * (c - 1) * (b - a) / 2;\tcout &lt;&lt; res; return 0;&#125; P1192 å°é˜¶é—®é¢˜ 12345678910111213141516#include &lt;iostream&gt;using namespace std;const int MOD = 100003;int dp[100001];int main() &#123;\tint n, k;\tcin &gt;&gt; n &gt;&gt; k;\tfor (int i = 1; i &lt;= k; i++) dp[i] = 1;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = i - 1; j &gt; max(i - k - 1, 0); j--) &#123; dp[i] = (dp[i] + dp[j]) % MOD; &#125;\t&#125;\tcout &lt;&lt; dp[n]; return 0;&#125; P1025 æ•°çš„åˆ’åˆ† dfs 12345678910111213141516#include &lt;iostream&gt;using namespace std;int n, k, res;void dfs(int cnt, int s, int t) &#123;\tif (cnt == k &amp;&amp; t == n) res++;\tif (cnt == k) return;\tfor (int i = s; t + i*(k - cnt) &lt;= n; i++) &#123; dfs(cnt + 1, i, t + i);\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; k;\tdfs(0, 1, 0);\tcout &lt;&lt; res; return 0;&#125; dp 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int dp[201][7];int main() &#123;\tint n, k;\tcin &gt;&gt; n &gt;&gt; k;\tfor (int i = 1; i &lt;= n; i++) &#123; dp[i][1] = 1;\t&#125;\tfor (int i = 2; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= k; j++) &#123; dp[i][j] += dp[i - 1][j - 1]; if (i &gt; j) dp[i][j] += dp[i - j][j]; &#125;\t&#125;\tcout &lt;&lt; dp[n][k]; return 0;&#125; P4994 ç»ˆäºç»“æŸçš„èµ·ç‚¹ 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int fib[10000001];int main() &#123;\tint m;\tcin &gt;&gt; m;\tfib[0] = 0;\tfib[1] = 1;\tfor (int i = 2; i &lt; 10000001; i++) &#123; fib[i] = (fib[i - 1] + fib[i - 2]) % m;\t&#125;\tint res = 0;\tfor (int i = 1; i &lt; 10000000; i++) &#123; if (fib[i] == 0 &amp;&amp; fib[i + 1] == 1) &#123; res = i; break; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; åŸºç¡€ç®—æ³• è¿™ä¸€éƒ¨åˆ†çš„å†…å®¹åŒ…å«äº† OI ä¸­çš„åŸºç¡€ç®—æ³•ï¼Œä¾›å„ä½å·©å›ºåŸºç¡€ã€‚ å½“ç„¶ï¼Œè¿™é‡Œé¢ä¹Ÿæœ‰ä¸€äº›éš¾åº¦æ¯”è¾ƒé«˜çš„é¢˜ç›®ã€‚ æ¨¡æ‹Ÿ æ¨¡æ‹Ÿï¼Œé¡¾åæ€ä¹‰å°±æ˜¯é¢˜ç›®è¦æ±‚ä½ åšä»€ä¹ˆä½ å°±åšä»€ä¹ˆï¼Œè¿™æ ·çš„é¢˜ç›®å¾ˆè€ƒéªŒé€‰æ‰‹çš„ä»£ç ç»„ç»‡èƒ½åŠ›ã€‚ è¿™é‡Œä¸ä»…ä»…æœ‰éå¸¸åŸºç¡€çš„æ¨¡æ‹Ÿï¼Œä¹Ÿæœ‰ä¸€äº›éå¸¸å¤æ‚çš„é¢˜ç›®ã€‚ P1003 é“ºåœ°æ¯¯ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int gg[100001][4];int main() &#123;\tint n, a, b, g, k, x, y, res = -1;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; g &gt;&gt; k; gg[i][0] = a; gg[i][1] = a + g; gg[i][2] = b; gg[i][3] = b + k;\t&#125;\tcin &gt;&gt; x &gt;&gt; y;\tfor (int i = n; i &gt; 0; i--) &#123; if (x &gt;= gg[i][0] &amp;&amp; x &lt;= gg[i][1] &amp;&amp; y &gt;= gg[i][2] &amp;&amp; y &lt;= gg[i][3]) &#123; res = i; break; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1067 å¤šé¡¹å¼è¾“å‡º 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main() &#123;\tint n, x;\tcin &gt;&gt; n &gt;&gt; x;\tif (n == 0) &#123; cout &lt;&lt; x; return 0;\t&#125;\tif (x &gt; 1) cout &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; n;\telse if (x == 1) cout &lt;&lt; &quot;x^&quot; &lt;&lt; n;\telse if (x == -1) cout &lt;&lt; &quot;-x^&quot; &lt;&lt; n;\telse if (x &lt; -1) cout &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; n;\tfor (int i = n - 1; i &gt; 1; i--) &#123; cin &gt;&gt; x; if (x &gt; 1) cout &lt;&lt; &quot;+&quot; &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; i; else if (x == 1) cout &lt;&lt; &quot;+x^&quot; &lt;&lt; i; else if (x == -1) cout &lt;&lt; &quot;-x^&quot; &lt;&lt; i; else if (x &lt; -1) cout &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; i;\t&#125;\tcin &gt;&gt; x;\tif (x &gt; 1) cout &lt;&lt; &quot;+&quot; &lt;&lt; x &lt;&lt; &quot;x&quot;;\telse if (x == 1) cout &lt;&lt; &quot;+x&quot;;\telse if (x == -1) cout &lt;&lt; &quot;-x&quot;;\telse if (x &lt; -1) cout &lt;&lt; x &lt;&lt; &quot;x&quot;;\tcin &gt;&gt; x;\tif (x &gt; 0) cout &lt;&lt; &quot;+&quot; &lt;&lt; x;\telse if (x &lt; 0) cout &lt;&lt; x; return 0;&#125; ä¼˜åŒ–ç‰ˆ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int n, x; cin &gt;&gt; n; for (int i = n; i &gt;= 0; i--) &#123; cin &gt;&gt; x; if (x) &#123; if (x &gt; 0 &amp;&amp; i != n) cout &lt;&lt; &quot;+&quot;; if (abs(x) &gt; 1 || i == 0) cout &lt;&lt; x; if (x == -1 &amp;&amp; i) cout &lt;&lt; &quot;-&quot;; if (i &gt; 1) cout &lt;&lt; &quot;x^&quot; &lt;&lt; i; if (i == 1) cout &lt;&lt; &quot;x&quot;; &#125; &#125; return 0;&#125; P1328 ç”Ÿæ´»å¤§çˆ†ç‚¸ç‰ˆçŸ³å¤´å‰ªåˆ€å¸ƒ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int a[401], b[401];int main() &#123; int n, na, nb; cin &gt;&gt; n &gt;&gt; na &gt;&gt; nb; for (int i = 0; i &lt; na; i++) cin &gt;&gt; a[i];\tfor (int i = 0; i &lt; nb; i++) cin &gt;&gt; b[i];\tfor (int i = na; i &lt; n + na; i += na) &#123; for (int j = 0; j &lt; na; j++) a[i + j] = a[j];\t&#125;\tfor (int i = nb; i &lt; n + nb; i += nb) &#123; for (int j = 0; j &lt; nb; j++) b[i + j] = b[j];\t&#125;\tint resa = 0, resb = 0;\tfor (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i]) continue; if (a[i] == 0 &amp;&amp; b[i] == 2 || a[i] == 0 &amp;&amp; b[i] == 3 || a[i] == 1 &amp;&amp; b[i] == 0 || a[i] == 1 &amp;&amp; b[i] == 3 || a[i] == 2 &amp;&amp; b[i] == 1 || a[i] == 2 &amp;&amp; b[i] == 4 || a[i] == 3 &amp;&amp; b[i] == 2 || a[i] == 3 &amp;&amp; b[i] == 4 || a[i] == 4 &amp;&amp; b[i] == 0 || a[i] == 4 &amp;&amp; b[i] == 1) resa++; else resb++;\t&#125;\tcout &lt;&lt; resa &lt;&lt; &quot; &quot; &lt;&lt; resb &lt;&lt; endl; return 0;&#125; ä¼˜åŒ–ç‰ˆ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int v[5][5] = &#123;&#123;0, 0, 1, 1, 0&#125;, &#123;1, 0, 0, 1, 0&#125;, &#123;0, 1, 0, 0, 1&#125;, &#123;0, 0, 1, 0, 1&#125;, &#123;1, 1, 0, 0, 0&#125;&#125;;int a[201], b[201];int main() &#123; int n, na, nb, resa = 0, resb = 0; cin &gt;&gt; n &gt;&gt; na &gt;&gt; nb; for (int i = 0; i &lt; na; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; nb; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) &#123; resa += v[a[i % na]][b[i % nb]]; resb += v[b[i % nb]][a[i % na]];\t&#125;\tcout &lt;&lt; resa &lt;&lt; &quot; &quot; &lt;&lt; resb &lt;&lt; endl; return 0;&#125; P1563 ç©å…·è°œé¢˜ 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct node&#123;\tbool flag;\tstring name;&#125; nums[100001];int main() &#123; int n, m, a, s; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i].flag &gt;&gt; nums[i].name;\tint start = 0;\tfor (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; s; if (nums[start].flag ^ a) start = (start + s) % n; else start = (start - s + n) % n;\t&#125;\tcout &lt;&lt; nums[start].name; return 0;&#125; P1042 ä¹’ä¹“çƒ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;vector&lt;pair&lt;int, int&gt; &gt; res1, res2;int main() &#123;\tstring str;\tint a = 0, b = 0, c = 0, d = 0;\tbool flag = true; while (flag &amp;&amp; getline(cin, str)) &#123; for (auto ch: str) &#123; if (ch == &#x27;W&#x27;) &#123; a++; c++; if (a &gt;= 11 &amp;&amp; a - b &gt;= 2) &#123; res1.push_back(&#123;a, b&#125;); a = 0; b = 0; &#125; if (c &gt;= 21 &amp;&amp; c - d &gt;= 2) &#123; res2.push_back(&#123;c, d&#125;); c = 0; d = 0; &#125; &#125; else if (ch == &#x27;L&#x27;) &#123; b++; d++; if (b &gt;= 11 &amp;&amp; b - a &gt;= 2) &#123; res1.push_back(&#123;a, b&#125;); a = 0; b = 0; &#125; if (d &gt;= 21 &amp;&amp; d - c &gt;= 2) &#123; res2.push_back(&#123;c, d&#125;); c = 0; d = 0; &#125; &#125; else if (ch == &#x27;E&#x27;) &#123; flag = false; break; &#125; &#125;\t&#125;\tif (a || b) res1.push_back(&#123;a, b&#125;);\telse res1.push_back(&#123;0, 0&#125;);\tif (c || d) res2.push_back(&#123;c, d&#125;);\telse res2.push_back(&#123;0, 0&#125;);\tfor (auto it: res1) cout &lt;&lt; it.first &lt;&lt; &quot;:&quot; &lt;&lt; it.second &lt;&lt; endl;\tcout &lt;&lt; endl;\tfor (auto it: res2) cout &lt;&lt; it.first &lt;&lt; &quot;:&quot; &lt;&lt; it.second &lt;&lt; endl; return 0;&#125; P1179 æ•°å­—ç»Ÿè®¡ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123;\tint l, r, res = 0;\tcin &gt;&gt; l &gt;&gt; r;\tfor (int i = l; i &lt;= r; i++) &#123; int t = i; while (t &gt; 1) &#123; if (t % 10 == 2) res++; t /= 10; &#125;\t&#125; cout &lt;&lt; res; return 0;&#125; P2615 ç¥å¥‡çš„å¹»æ–¹ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int nums[40][40];int main() &#123;\tint n;\tcin &gt;&gt; n;\tnums[0][n/2] = 1;\tfor (int i = 2; i &lt;= n * n; i++) &#123; bool flag = false; int j = 0, k = 0; for (j = 0; j &lt; n; j++) &#123; for (k = 0; k &lt; n; k++) &#123; if (nums[j][k] == i - 1) &#123; flag = true; break; &#125; &#125; if (flag) break; &#125; if (j == 0 &amp;&amp; k != n-1) nums[n-1][k+1] = i; if (j != 0 &amp;&amp; k == n-1) nums[j-1][0] = i; if (j == 0 &amp;&amp; k == n-1) nums[1][k] = i; if (j != 0 &amp;&amp; k != n-1) &#123; if (nums[j-1][k+1]) nums[j+1][k] = i; else nums[j-1][k+1] = i; &#125;\t&#125;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; nums[i][j]; if (j != n - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125;\t&#125; return 0;&#125; P3952 æ—¶é—´å¤æ‚åº¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool st[101][256], isin[101];int main() &#123;\tint t, n, com;\tstring O, x, y;\tchar op, val;\tcin &gt;&gt; t;\tfor (int i = 0; i &lt; t; i++) &#123; fill(st[0], st[0] + 101 * 256, false); fill(isin, isin + 101, false); bool flag = true, flag2 = true; cin &gt;&gt; n &gt;&gt; O; if (O[2] == &#x27;1&#x27;) com = 0; else com = stoi(O.substr(4)); int cnt = 0, maxn = 0, cur = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; op; if (op == &#x27;F&#x27;) &#123; cnt++; cin &gt;&gt; val &gt;&gt; x &gt;&gt; y; for (int j = 0; j &lt; cnt; j++) &#123; if (st[j][val]) &#123; flag = false; break; &#125; &#125; st[cnt][val] = true; if (x != &quot;n&quot; &amp;&amp; y == &quot;n&quot; ) &#123; bool flag3 = true; cur++; for (int j = 0; j &lt; cnt; j++) &#123; if (isin[j]) &#123; flag3 = false; break; &#125; &#125; if (flag3) maxn = max(maxn, cur); &#125; else if (x == &quot;n&quot; &amp;&amp; y != &quot;n&quot; || x != &quot;n&quot; &amp;&amp; y != &quot;n&quot; &amp;&amp; stoi(x) &gt; stoi(y)) &#123; isin[cnt] = true; &#125; &#125; else if (op == &#x27;E&#x27;) &#123; isin[cnt] = false; for (int i = 0; i &lt; 256; i++) st[cnt][i] = false; cnt--; if (cnt &lt; 0) &#123; flag = false; cnt = 0; &#125; cur--; if (cur &lt; 0) cur = 0; &#125; &#125; if (!flag || cnt != 0) cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; else if (maxn == com) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;\t&#125; return 0;&#125; æ’åºç®—æ³• é€šè¿‡æ’åºï¼Œæˆ‘ä»¬å¯ä»¥å°†æ•°æ®æœ‰åºåŒ–ï¼Œè¿™è®©æˆ‘ä»¬å¯¹æ•°æ®çš„å¤„ç†æ–¹ä¾¿äº†å¾ˆå¤šã€‚ P1177 ã€æ¨¡æ¿ã€‘å¿«é€Ÿæ’åº 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];void quick_sort(int l, int r) &#123;\tif (l &gt;= r) return;\tint i = l - 1, j = r + 1, t = nums[l + r &gt;&gt; 1];\twhile (i &lt; j) &#123; do i++; while (nums[i] &lt; t); do j--; while (nums[j] &gt; t); if (i &lt; j) swap(nums[i], nums[j]);\t&#125;\tquick_sort(l, j);\tquick_sort(j + 1, r);&#125;int main() &#123;\tint n;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tquick_sort(0, n - 1);\tfor (int i = 0; i &lt; n; i++) cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;; return 0;&#125; P1059 æ˜æ˜çš„éšæœºæ•° 12345678910111213141516#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; nums;int main() &#123;\tint n, x;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; nums.insert(x);\t&#125;\tcout &lt;&lt; nums.size() &lt;&lt; endl;\tfor (auto it: nums) cout &lt;&lt; it &lt;&lt; &quot; &quot;; return 0;&#125; P1068 åˆ†æ•°çº¿åˆ’å®š 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tint num, score;&#125; nums[5001];bool cmp(node &amp;a, node &amp;b) &#123;\tif (a.score != b.score) return a.score &gt; b.score;\treturn a.num &lt; b.num;&#125;int main() &#123;\tint n, m;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i].num &gt;&gt; nums[i].score;\tsort(nums, nums + n, cmp);\tint t = m * 1.5;\twhile (t &lt; n) &#123; if (nums[t].score == nums[t-1].score) t++; else break;\t&#125;\tcout &lt;&lt; nums[t - 1].score &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; endl;\tfor (int i = 0; i &lt; t; i++) &#123; cout &lt;&lt; nums[i].num &lt;&lt; &quot; &quot; &lt;&lt; nums[i].score &lt;&lt; endl;\t&#125; return 0;&#125; P1051 è°æ‹¿äº†æœ€å¤šå¥–å­¦é‡‘ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tstring name;\tint score1, score2, paper, money;\tchar ganbu, poor;&#125; nums[101];bool cmp(const node &amp;a, const node &amp;b) &#123;\treturn a.money &gt; b.money;&#125;int main() &#123;\tint n, sum = 0;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; int money = 0; cin &gt;&gt; nums[i].name &gt;&gt; nums[i].score1 &gt;&gt; nums[i].score2 &gt;&gt; nums[i].ganbu &gt;&gt; nums[i].poor &gt;&gt; nums[i].paper; if (nums[i].score1 &gt; 80 &amp;&amp; nums[i].paper &gt;= 1) money += 8000; if (nums[i].score1 &gt; 85 &amp;&amp; nums[i].score2 &gt; 80) money += 4000; if (nums[i].score1 &gt; 90) money += 2000; if (nums[i].score1 &gt; 85 &amp;&amp; nums[i].poor == &#x27;Y&#x27;) money += 1000; if (nums[i].score2 &gt; 80 &amp;&amp; nums[i].ganbu == &#x27;Y&#x27;) money += 850; nums[i].money = money; sum += money;\t&#125;\tstable_sort(nums, nums + n, cmp);\tcout &lt;&lt; nums[0].name &lt;&lt; &quot; &quot; &lt;&lt; nums[0].money &lt;&lt; &quot; &quot; &lt;&lt; sum; return 0;&#125; P1309 ç‘å£«è½® 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tint num, v, score;&#125; nums[200001], a[100001], b[100001];bool cmp(const node &amp;a, const node &amp;b) &#123;\tif (a.score != b.score) return a.score &gt; b.score;\telse return a.num &lt; b.num;&#125;int n;void merge() &#123;\tint id = 0, i = 0, j = 0;\twhile (i &lt; n &amp;&amp; j &lt; n) &#123; if (a[i].score &gt; b[j].score || a[i].score == b[j].score &amp;&amp; a[i].num &lt; b[j].num) nums[id++] = a[i++]; else nums[id++] = b[j++];\t&#125;\twhile (i &lt; n) nums[id++] = a[i++];\twhile (j &lt; n) nums[id++] = b[j++];&#125;int main() &#123;\tint r, q;\tscanf(&quot;%d %d %d&quot;, &amp;n, &amp;r, &amp;q);\tfor (int i = 0; i &lt; 2 * n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i].score); nums[i].num = i + 1;\t&#125;\tfor (int i = 0; i &lt; 2 * n; i++) scanf(&quot;%d&quot;, &amp;nums[i].v);\tsort(nums, nums + 2 * n, cmp);\tfor (int i = 0; i &lt; r; i++) &#123; int t = 0; for (int j = 0; j &lt; 2 * n; j += 2) &#123; if (nums[j].v &gt; nums[j+1].v) &#123; nums[j].score++; a[t] = nums[j]; b[t++] = nums[j+1]; &#125; else &#123; nums[j+1].score++; a[t] = nums[j+1]; b[t++] = nums[j]; &#125; &#125; merge();\t&#125;\tprintf(&quot;%d&quot;, nums[q - 1].num); return 0;&#125; P1908 é€†åºå¯¹ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[500001];long long res;void merge_sort(int l, int r) &#123;\tif (l &gt;= r) return;\tint mid = l + r &gt;&gt; 1;\tmerge_sort(l, mid);\tmerge_sort(mid + 1, r);\tvector&lt;int&gt; t;\tint i = l, j = mid + 1;\twhile (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (nums[i] &lt;= nums[j]) t.push_back(nums[i++]); else &#123; res += mid - i + 1; t.push_back(nums[j++]); &#125;\t&#125;\twhile (i &lt;= mid) t.push_back(nums[i++]);\twhile (j &lt;= r) t.push_back(nums[j++]);\tfor (int k = l; k &lt;= r; k++) nums[k] = t[k - l];&#125;int main() &#123;\tint n;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i];\t&#125;\tmerge_sort(0, n - 1);\tcout &lt;&lt; res;\treturn 0;&#125; äºŒåˆ†ç­”æ¡ˆ å¯¹ä¸€ä¸ªæ»¡è¶³å•è°ƒæ€§è´¨çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨äºŒåˆ†ç­”æ¡ˆçš„æ–¹æ³•æ¥è§£å†³ã€‚ P1024 ä¸€å…ƒä¸‰æ¬¡æ–¹ç¨‹æ±‚è§£ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;double a, b, c, d, nums[201];double f(double x) &#123;\treturn a * x * x * x + b * x * x + c * x + d;&#125;void check(double l, double r, bool flag) &#123;\twhile (r - l &gt; 1e-6) &#123; double mid = (l + r) / 2; if (flag) &#123; if (f(mid) &gt; 0) r = mid; else l = mid; &#125; else &#123; if (f(mid) &lt; 0) r = mid; else l = mid; &#125;\t&#125;\tprintf(&quot;%.2f &quot;, l);&#125;int main() &#123;\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\tdouble i = -100;\tbool flag = false, flag2 = true;\tif (f(-100) &lt; 0) flag = true;\twhile (i &lt;= 100) &#123; if (flag2) &#123; if (f(i) * f(-100) &lt; 0) &#123; check(i - 0.5, i, flag); flag2 = false; &#125; &#125; else &#123; if (f(i) * f(-100) &gt; 0) &#123; check(i - 0.5, i, !flag); flag2 = true; &#125; &#125; i += 0.5;\t&#125;\treturn 0;&#125; P2678 è·³çŸ³å¤´ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int l, n, m, nums[50005], res;bool check(int x) &#123;\tint cnt = 0, now = 0;\tfor (int i = 1; i &lt;= n+1; i++) &#123; if (nums[i] - nums[now] &lt; x) cnt++; else now = i;\t&#125;\tif (cnt &gt; m) return false;\treturn true;&#125;int main() &#123;\tcin &gt;&gt; l &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; nums[i];\tnums[n+1] = l;\tint i = 1, j = l;\twhile (i &lt; j) &#123; int mid = i + j + 1 &gt;&gt; 1; if (check(mid)) i = mid; else j = mid - 1;\t&#125;\tcout &lt;&lt; i;\treturn 0;&#125; P1902 åˆºæ€å¤§ä½¿ dfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = &#123;-1, 1, 0, 0&#125;, dy[4] = &#123;0, 0, -1, 1&#125;;bool visit[1005][1005], flag;void dfs(int a, int b) &#123;\tif (a == n - 1) &#123; flag = true; return;\t&#125;\tfor (int i = 0; i &lt; 4; i++) &#123; x = a + dx[i], y = b + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !visit[x][y] &amp;&amp; g[x][y] &lt;= mid) &#123; visit[x][y] = true; dfs(x, y); visit[x][y] = false; if (flag) return; &#125;\t&#125;&#125;bool check() &#123;\tflag = false;\tmemset(visit, false, sizeof(visit));\tdfs(0, 0);\treturn flag;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tint l = 1000, r = 0;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); &#125;\t&#125;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check()) r = mid; else l = mid + 1;\t&#125;\tcout &lt;&lt; r;\treturn 0;&#125; bfs 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = &#123;-1, 1, 0, 0&#125;, dy[4] = &#123;0, 0, -1, 1&#125;;bool visit[1005][1005];bool bfs() &#123;\tmemset(visit, false, sizeof(visit));\tqueue&lt;pair&lt;int, int&gt; &gt; q;\tq.push(&#123;0, 0&#125;);\twhile (!q.empty()) &#123; int a = q.front().first, b = q.front().second; q.pop(); for (int i = 0; i &lt; 4; i++) &#123; x = a + dx[i], y = b + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !visit[x][y] &amp;&amp; g[x][y] &lt;= mid) &#123; q.push(&#123;x, y&#125;); visit[x][y] = true; if (x == n - 1) return true; &#125; &#125;\t&#125;\treturn false;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tint l = 1000, r = 0;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); &#125;\t&#125;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (bfs()) r = mid; else l = mid + 1;\t&#125;\tcout &lt;&lt; r;\treturn 0;&#125; P1314 èªæ˜çš„è´¨ç›‘å‘˜ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;typedef long long LL;LL s, res = 1e12, t;int n, m, w[200005], v[200005], sums[200005], cnts[200005], q[200005][2], mid;bool check() &#123;\tt = 0;\tfor (int i = 1; i &lt;= n; i++) &#123; if (w[i-1] &gt;= mid) &#123; sums[i] = sums[i-1] + v[i-1]; cnts[i] = cnts[i-1] + 1; &#125; else &#123; sums[i] = sums[i-1]; cnts[i] = cnts[i-1]; &#125;\t&#125;\tfor (int k = 0; k &lt; m; k++) &#123; int l = q[k][0], r = q[k][1]; t += (cnts[r] - cnts[l-1]) * (sums[r] - sums[l-1]);\t&#125;\tres = min(res, abs(t-s));\tif (t &gt; s) return true;\treturn false;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];\tfor (int i = 0; i &lt; m; i++) cin &gt;&gt; q[i][0] &gt;&gt; q[i][1];\tint l = 1, r = 1e6;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check()) l = mid + 1; else r = mid; &#125;\tcout &lt;&lt; res &lt;&lt; endl;\treturn 0;&#125; P1083 å€Ÿæ•™å®¤ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;long long n, m, w[1000005], d[1000005], s[1000006], t[1000005], diff[1000005], nums[1000005], mid;bool check() &#123;\tfill(diff, diff + 1000005, 0);\tfor (int i = 1; i &lt;= mid; i++) &#123; diff[s[i]] += d[i]; diff[t[i] + 1] -= d[i];\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; nums[i] = nums[i - 1] + diff[i]; if (nums[i] &gt; w[i]) return false;\t&#125; return true;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; d[i] &gt;&gt; s[i] &gt;&gt; t[i];\tint l = 1, r = n + 1;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check()) l = mid + 1; else r = mid; &#125;\tif (r &gt; n) cout &lt;&lt; 0;\telse cout &lt;&lt; &quot;-1 &quot; &lt;&lt; l &lt;&lt; endl;\treturn 0;&#125; P4343 è‡ªåŠ¨åˆ·é¢˜æœº 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;typedef long long LL;LL n, m, mid, nums[100005];LL check() &#123;\tLL cnt = 0, t = 0;\tfor (int i = 0; i &lt; n; i++) &#123; t += nums[i]; t = max&lt;LL&gt;(0, t); if (t &gt;= mid) &#123; t = 0; cnt++; &#125;\t&#125;\treturn cnt;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tLL l = 1, r = 1e18;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check() &gt; m) l = mid + 1; else r = mid; &#125;\tmid = l;\tif (check() != m) &#123; cout &lt;&lt; -1; return 0;\t&#125;\tcout &lt;&lt; l &lt;&lt; &quot; &quot;;\tr = 1e18;\twhile (l &lt; r) &#123; mid = l + r + 1&gt;&gt; 1; if (check() &lt; m) r = mid - 1; else l = mid; &#125;\tcout &lt;&lt; r;\treturn 0;&#125; åˆ†æ²» åˆ†æ²»ï¼Œå³åˆ†è€Œæ²»ä¹‹ï¼Œå°†å¤§é—®é¢˜åˆ†è§£ä¸ºå°é—®é¢˜ï¼Œåˆ†åˆ«æ±‚è§£ï¼Œæœ€ååˆå¹¶ç»“æœã€‚ P1226 å¿«é€Ÿå¹‚||å–ä½™è¿ç®— 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a, int b, int p) &#123;\tLL res = 1, t = a;\twhile (b) &#123; if (b &amp; 1) res = (res * t) % p; t = (t * t) % p; b &gt;&gt;= 1;\t&#125;\tres %= p;\treturn res;&#125;int main() &#123; LL a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; printf(&quot;%d^%d mod %d=%d&quot;, a, b, p, qmi(a, b, p)); return 0;&#125; P1010 å¹‚æ¬¡æ–¹ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void fun(int x) &#123;\twhile (x &gt;= 1) &#123; int t = 1, cnt = 0; do &#123; t *= 2; cnt++; &#125; while (x &gt;= t); int a = cnt - 1; if (a == 0) cout &lt;&lt; &quot;2(0)&quot;; else if (a == 1) cout &lt;&lt; &quot;2&quot;; else &#123; cout &lt;&lt; &quot;2(&quot;; fun(a); cout &lt;&lt; &quot;)&quot;; &#125; x -= t / 2; if (x != 0) cout &lt;&lt; &quot;+&quot;;\t&#125;&#125;int main() &#123; int n; cin &gt;&gt; n; fun(n); return 0;&#125; P1429 å¹³é¢æœ€è¿‘ç‚¹å¯¹ï¼ˆåŠ å¼ºç‰ˆï¼‰ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;vector&lt;vector&lt;LL&gt;&gt; nums;bool cmp(vector&lt;LL&gt; &amp;a, vector&lt;LL&gt; &amp;b) &#123;\treturn a[2] &lt; b[2];&#125;int main() &#123; int n, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums.push_back(&#123;a, b, a + b&#125;);\t&#125;\tsort(nums.begin(), nums.end(), cmp);\tLL res = 1e12;\tfor (int i = 1; i &lt; n; i++) &#123; for (int k = 1; k &lt; 5; k++) &#123; int j = i - k; if (j &lt; 0) break; res = min((nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]), res); &#125;\t&#125;\tprintf(&quot;%.4f&quot;, sqrt(res)); return 0;&#125; P3612 Secret Cow Code 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;int main() &#123; string str; LL n, i; cin &gt;&gt; str &gt;&gt; n; while (n &gt; str.size()) &#123; i = str.size(); while (n &gt; i) i *= 2; i /= 2; n -= (i + 1); if (n == 0) n = i; cout &lt;&lt; n &lt;&lt; endl;\t&#125;\tcout &lt;&lt; str[n - 1]; return 0;&#125; è´ªå¿ƒ è´ªå¿ƒï¼ŒæŒ‡çš„æ˜¯å†³ç­–æ—¶éƒ½é‡‡å–å½“å‰æœ€ä¼˜è§£çš„ç®—æ³•ã€‚æœ‰çš„æ—¶å€™ï¼Œè¿™æ ·åšç¡®å®å¯ä»¥è·å¾—æœ€ä¼˜è§£ã€‚ P1208 Mixing Milk 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef pair&lt;int, int&gt; PII;PII nums[5005];int main() &#123; int n, m, price, cnt; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; nums[i].first &gt;&gt; nums[i].second;\tsort(nums, nums + m);\tint res = 0, id = 0;\twhile (n &gt; 0) &#123; if (n &gt;= nums[id].second) &#123; res += nums[id].first * nums[id].second; n -= nums[id].second; &#125; else &#123; res += n * nums[id].first; n = 0; &#125; id++;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P4995 è·³è·³ï¼ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;int nums[305];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tsort(nums, nums + n);\tLL res = 0;\tint l = 0, r = n - 1, cur = 0;\twhile (l &lt; r) &#123; res += (nums[r] - cur) * (nums[r] - cur); cur = nums[r--]; if (l == r) &#123; res += (nums[r] - cur) * (nums[r] - cur);; break; &#125; res += (nums[l] - cur) * (nums[l] - cur); cur = nums[l++]; if (l == r) &#123; res += (nums[l] - cur) * (nums[l] - cur);; break; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1094 çºªå¿µå“åˆ†ç»„ 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[30005];int main() &#123; int w, n; cin &gt;&gt; w &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tsort(nums, nums + n);\tint res = 0, l = 0, r = n - 1;\twhile (l &lt;= r) &#123; if (nums[r] + nums[l] &gt; w) &#123; res++; r--; &#125; else &#123; res++; r--; l++; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1199 ä¸‰å›½æ¸¸æˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tint val, row, col;&#125; nums[250005];bool st[505], you[505];int res;bool cmp(node &amp;a, node &amp;b) &#123;\treturn a.val &lt; b.val;&#125;void dfs(int x) &#123;\tif (nums[x].val &lt; res) return;\tif (you[nums[x].row] &amp;&amp; !st[nums[x].col] || you[nums[x].col] &amp;&amp; !st[nums[x].row]) &#123; res = max(res, nums[x].val); return;\t&#125;\tif (!st[nums[x].row]) &#123; st[nums[x].col] = true; st[nums[x].row] = true; you[nums[x].row] = true; dfs(x - 1); st[nums[x].col] = false; st[nums[x].row] = false; you[nums[x].row] = false;\t&#125;\tif (!st[nums[x].col]) &#123; st[nums[x].row] = true; st[nums[x].col] = true; you[nums[x].col] = true; dfs(x - 1); st[nums[x].row] = false; st[nums[x].col] = false; you[nums[x].col] = false;\t&#125;&#125;int main() &#123; int n, id = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; cin &gt;&gt; nums[id].val; nums[id].row = i; nums[id++].col = j; &#125; &#125; sort(nums, nums + id, cmp); dfs(id - 1); cout &lt;&lt; &quot;1 &quot; &lt;&lt; res; return 0;&#125; P2672 æ¨é”€å‘˜ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum[100005], q[100005], h[100005];struct node &#123;\tint dist, fatigue;&#125; v[100005];bool cmp(node &amp;a, node &amp;b) &#123;\treturn a.fatigue &gt; b.fatigue;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i].dist; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i].fatigue; sort(v + 1, v + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + v[i].fatigue; for (int i = 1; i &lt;= n; i++) q[i] = max(q[i - 1], 2 * v[i].dist); for (int i = n; i &gt;= 1; i--) h[i] = max(h[i + 1], 2 * v[i].dist + v[i].fatigue); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; max(sum[i] + q[i], sum[i - 1] + h[i]) &lt;&lt; endl; return 0;&#125; P1080 å›½ç‹æ¸¸æˆ æ²¡æœ‰ç”¨é«˜ç²¾åº¦ï¼ˆ60åˆ†ï¼‰ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;struct node &#123;\tint l, r;\tdouble t;&#125; v[10005];bool cmp(node &amp;a, node &amp;b) &#123;\treturn a.l * a.r &lt; b.l * b.r;&#125;int main() &#123; LL n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i].l &gt;&gt; v[i].r; v[i].t = (double)v[i].l / v[i].r;\t&#125; sort(v, v + n, cmp); LL res = 0, cur = a; for (int i = 0; i &lt; n; i++) &#123; res = max(res, (LL)a / v[i].r); a *= v[i].l;\t&#125;\tcout &lt;&lt; res; return 0;&#125; æ„é€  æ„é€ é¢˜æ˜¯ä¸€ç§å½¢å¼çµæ´»å¤šæ ·çš„é¢˜å‹ã€‚æ­£æ˜¯å› ä¸ºè¿™ä¸ªç‰¹ç‚¹ï¼Œä½¿å¾—æ„é€ é¢˜æ²¡æœ‰ä¸€ç§é€šç”¨çš„æ–¹æ³•ã€‚ P5595 æ­Œå”±æ¯”èµ› 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string str, res1 = &quot;&quot;, res2 = &quot;&quot;; cin &gt;&gt; str; int cnt = 0; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;Z&#x27;) &#123; for (int j = i + 1; j &lt; str.size(); j++) &#123; if (str[j] != &#x27;Z&#x27;) &#123; cout &lt;&lt; -1; return 0; &#125; &#125; break; &#125;\t&#125;\tfor (int i = str.size() - 1; i &gt;= 0; i--) &#123; if (str[i] == &#x27;Z&#x27;) &#123; res1 += &#x27;0&#x27;; res2 += &#x27;0&#x27;; &#125; else if (str[i] == &#x27;Y&#x27;) &#123; res1 += &#x27;0&#x27;; res2 += &#x27;1&#x27;; &#125; else if (str[i] == &#x27;X&#x27;) &#123; res1 += &#x27;1&#x27;; res2 += &#x27;0&#x27;; &#125;\t&#125;\treverse(res1.begin(), res1.end());\treverse(res2.begin(), res2.end());\tcout &lt;&lt; res1 &lt;&lt; &quot; &quot; &lt;&lt; res2; return 0;&#125; é«˜ç²¾åº¦ åœ¨ C++ ä¸­ï¼Œlong long éƒ½æ— æ³•è¡¨ç¤ºæˆ‘ä»¬éœ€è¦çš„æ•´æ•°æ—¶æ€ä¹ˆåŠï¼Ÿé‚£å°±ç”¨é«˜ç²¾åº¦å§ï¼ P1601 A+B Problemï¼ˆé«˜ç²¾ï¼‰ 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a, b, c; cin &gt;&gt; a &gt;&gt; b; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); if (a.size() &lt; b.size()) swap(a, b); int t = 0, i = 0; for (; i &lt; b.size(); i++) &#123; c += ((a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t) % 10) + &#x27;0&#x27;; t = (a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t) / 10;\t&#125;\tfor (; i &lt; a.size(); i++) &#123; c += ((a[i] - &#x27;0&#x27; + t) % 10) + &#x27;0&#x27;; t = (a[i] - &#x27;0&#x27; + t) / 10;\t&#125;\tif (t) c += &#x27;1&#x27;;\treverse(c.begin(), c.end());\tcout &lt;&lt; c; return 0;&#125; P2142 é«˜ç²¾åº¦å‡æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a, b, c; cin &gt;&gt; a &gt;&gt; b; if (a == b) &#123; cout &lt;&lt; &quot;0&quot;; return 0;\t&#125; if (a.size() &lt; b.size()) &#123; int e = b.size() - a.size(); for (int i = 0; i &lt; e; i++) a = &#x27;0&#x27; + a;\t&#125; else if (a.size() &gt; b.size()) &#123; int e = a.size() - b.size(); for (int i = 0; i &lt; e; i++) b = &#x27;0&#x27; + b;\t&#125; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] + &#x27;0&#x27; &lt; b[i] + &#x27;0&#x27;) &#123; swap(a, b); cout &lt;&lt; &quot;-&quot;; break; &#125; else if (a[i] + &#x27;0&#x27; &gt; b[i] + &#x27;0&#x27;) &#123; break; &#125;\t&#125;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; int d = a[i] - b[i] - t; if (d &lt; 0) &#123; c += ((d + 10) % 10) + &#x27;0&#x27;; t = 1; &#125; else &#123; c += (d % 10) + &#x27;0&#x27;; t = 0; &#125;\t&#125;\treverse(c.begin(), c.end());\twhile (c[0] == &#x27;0&#x27;) c.erase(c.begin());\tcout &lt;&lt; c; return 0;&#125; P1303 A*B Problem 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int c[40005];int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; if (a[0] == &#x27;0&#x27; || b[0] == &#x27;0&#x27;) &#123; cout &lt;&lt; 0; return 0;\t&#125;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i &lt; b.size(); i++) &#123; for (int j = 0; j &lt; a.size(); j++) &#123; c[i+j] += (a[j] - &#x27;0&#x27;) * (b[i] - &#x27;0&#x27;); &#125;\t&#125; for (int i = 0; i &lt; a.size() + b.size() - 1; i++) &#123; c[i] += t; if (c[i] &gt;= 10) &#123; t = c[i] / 10; c[i] %= 10; &#125; else t = 0;\t&#125;\tif (t) &#123; c[a.size() + b.size() - 1] = t; for (int i = a.size() + b.size() - 1; i &gt;= 0; i--) cout &lt;&lt; c[i];\t&#125; else &#123; for (int i = a.size() + b.size() - 2; i &gt;= 0; i--) cout &lt;&lt; c[i];\t&#125; return 0;&#125; P1480 A&#x2F;B Problem 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a, c; int b; cin &gt;&gt; a &gt;&gt; b; long long t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t = t * 10 + a[i] - &#x27;0&#x27;; c += (t / b) + &#x27;0&#x27;; t -= t / b * b;\t&#125; while (c[0] == &#x27;0&#x27;) c.erase(c.begin()); if (c.size()) cout &lt;&lt; c; else cout &lt;&lt; &quot;0&quot;; return 0;&#125; P1009 é˜¶ä¹˜ä¹‹å’Œ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string s[51], fac[51];string mul(string a, int b) &#123;\tstring c;\tint t = 0;\treverse(a.begin(), a.end());\tfor (int i = 0; i &lt; a.size(); i++) &#123; int d = (a[i] - &#x27;0&#x27;) * b + t; c += (d % 10) + &#x27;0&#x27;; if (d &gt;= 10) t = d / 10; else t = 0;\t&#125;\tif (t) &#123; string e = to_string(t); reverse(e.begin(), e.end()); c += e;\t&#125;\treverse(c.begin(), c.end());\treturn c;&#125;string add(string a, string b) &#123;\tstring c;\tint t = 0, i = 0;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end());\tfor (; i &lt; a.size(); i++) &#123; int d = a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t; c += (d % 10) + &#x27;0&#x27;; if (d &gt;= 10) t = 1; else t = 0;\t&#125;\tfor (; i &lt; b.size(); i++) &#123; int d = b[i] - &#x27;0&#x27; + t; c += (d % 10) + &#x27;0&#x27;; if (d &gt;= 10) t = 1; else t = 0;\t&#125;\tif (t) c += &#x27;1&#x27;;\treverse(c.begin(), c.end());\treturn c;&#125;int main() &#123; int n; cin &gt;&gt; n; s[1] = fac[1] = &quot;1&quot;; for (int i = 2; i &lt;= n; i++) &#123; fac[i] = mul(fac[i - 1], i); s[i] = add(s[i - 1], fac[i]);\t&#125;\tcout &lt;&lt; s[n]; return 0;&#125; å‰ç¼€å’Œ &amp; å·®åˆ† å‰ç¼€å’Œæ˜¯ä¸€ç§é‡è¦çš„é¢„å¤„ç†ï¼Œèƒ½å¤§å¤§é™ä½æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ï¼Œè€Œå·®åˆ†åˆ™æ˜¯ä¸€ç§å’Œå‰ç¼€å’Œç›¸å¯¹çš„ç­–ç•¥ã€‚ P3131 Subsequences Summing to Sevens æš´åŠ›ï¼ˆ96åˆ†ï¼‰ 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef long long LL;LL sums[50005];int main() &#123; int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; sums[i] = sums[i - 1] + x;\t&#125;\tint res = 0;\tfor (int i = 1; i &lt;= n - res; i++) &#123; for (int j = i + res; j &lt;= n; j++) &#123; if ((sums[j] - sums[i - 1]) % 7 == 0) res = j - i + 1; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; æŠ€å·§ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int sums[50005], l[7], r[7];int main() &#123; int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; sums[i] = (sums[i - 1] + x) % 7;\t&#125; for (int i = n; i &gt;= 1; i--) l[sums[i]] = i;\tl[0] = 0;\tfor (int i = 1; i &lt;= n; i++) r[sums[i]] = i;\tint res = 0;\tfor (int i = 0; i &lt; 7; i++) res = max(res, r[i] - l[i]);\tcout &lt;&lt; res; return 0;&#125; P1387 æœ€å¤§æ­£æ–¹å½¢ dp 12345678910111213141516#include &lt;iostream&gt;using namespace std;int g[105][105], dp[105][105];int main() &#123; int n, m, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; g[i][j]; if (g[i][j] != 0) dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; res = max(res, dp[i][j]); &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; å‰ç¼€å’Œ+äºŒåˆ† 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int g[105][105] = &#123;0&#125;, dp[105][105];int main() &#123; int n, m, x, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; x; g[i][j] = g[i-1][j] + g[i][j-1] - g[i-1][j-1] + x; &#125;\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int l = 0, r = min(n, m); while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (i + mid &gt; n || j + mid &gt; m || g[i + mid][j+mid] - g[i+mid][j] - g[i][j+mid] + g[i][j] &lt; mid * mid) r = mid - 1; else l = mid; &#125; if (g[i+r][j+r] - g[i+r][j] - g[i][j+r] + g[i][j] == r*r) res = max(res, r); &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P3397 åœ°æ¯¯ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int g[1005][1005], res[1005][1005];int main() &#123; int n, m, x1, y1, x2, y2; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; g[x1][y1] += 1; g[x2+1][y1] -= 1; g[x1][y2+1] -= 1; g[x2+1][y2+1] += 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; g[i][j] += g[i-1][j] + g[i][j-1] - g[i-1][j-1]; cout &lt;&lt; g[i][j]; if (j &lt; n) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125;\t&#125; return 0;&#125; P2280 æ¿€å…‰ç‚¸å¼¹ 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int g[5005][5005], res;int main() &#123; int n, m, x, y, v; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; g[x+1][y+1] += v;\t&#125;\tfor (int i = 1; i &lt; 5005; i++) &#123; for (int j = 1; j &lt; 5005; j++) g[i][j] += g[i][j - 1] + g[i - 1][j] - g[i - 1][j - 1];\t&#125;\tfor (int i = m; i &lt; 5005; i++) &#123; for (int j = m; j &lt; 5005; j++) res = max(res, g[i][j] - g[i][j - m] - g[i - m][j] + g[i - m][j - m]);\t&#125;\tcout &lt;&lt; res; return 0;&#125; P4552 IncDec Sequence 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef long long LL;int a[100005];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i];\t&#125;\tLL p = 0, q = 0;\tfor (int i = 2; i &lt;= n; i++) &#123; int c = a[i] - a[i - 1]; if (c &gt; 0) p += c; else q -= c;\t&#125;\tLL res1 = max(p, q);\tLL res2 = abs(p - q) + 1;\tcout &lt;&lt; res1 &lt;&lt; &quot; &quot; &lt;&lt; res2; return 0;&#125; æœç´¢ æœç´¢å…¶å®å°±æ˜¯é«˜çº§çš„æšä¸¾ï¼Œå¾ˆå¤šé¢˜ç›®éƒ½å¯ä»¥ç”¨æœç´¢å®Œæˆã€‚å°±ç®—ä¸èƒ½ï¼Œæœç´¢ä¹Ÿæ˜¯éª—åˆ†ç¥å™¨ã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢ æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ï¼Œå³æŒ‰ç…§æ·±åº¦ä¼˜å…ˆçš„é¡ºåºæœç´¢çš„ç®—æ³•ã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢ä¸€èˆ¬ä½¿ç”¨æ ˆæ¥å®ç°ã€‚ P1219 å…«çš‡å 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool col[14], dg[28], udg[28];int n, cnt = 0;vector&lt;int&gt; res;void dfs(int u) &#123;\tif (u == n) &#123; if (cnt &lt; 3) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; cnt++; return;\t&#125;\tfor (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; col[i] = dg[u + i] = udg[n - u + i] = true; if (cnt &lt; 3) res.push_back(i + 1); dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; if (cnt &lt; 3) res.pop_back(); &#125;\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n;\tdfs(0);\tcout &lt;&lt; cnt; return 0;&#125; P1019 å•è¯æ¥é¾™ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt; #include &lt;map&gt;using namespace std;int n, res;map&lt;string, int&gt; st;string strs[21], str;void dfs(string t) &#123;\tres = max(res, (int)t.size());\tfor (int i = 0; i &lt; n; i++) &#123; if (st[strs[i]] &gt; 0) &#123; int size = min(t.size(), strs[i].size()); for (int k = 1; k &lt; size; k++) &#123; bool flag = true; for (int p = 1; p &lt;= k; p++) &#123; if (t[t.size() - p] != strs[i][k - p]) &#123; flag = false; break; &#125; &#125; if (flag) &#123; st[strs[i]]--; dfs(t + strs[i].substr(k)); st[strs[i]]++; break; &#125; &#125; &#125;\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str; st[str] = 2; strs[i] = str;\t&#125;\tcin &gt;&gt; str;\tfor (int i = 0; i &lt; n; i++) &#123; if (str[0] == strs[i][0]) &#123; st[strs[i]]--; dfs(strs[i]); st[strs[i]]++; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P5194 USACO05DEC]Scales P5440 ã€XR-2ã€‘å¥‡è¿¹ P1378 æ²¹æ»´æ‰©å±• å¹¿åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ï¼Œå³ä¼˜å…ˆæ‰©å±•æµ…å±‚èŠ‚ç‚¹ï¼Œé€æ¸æ·±å…¥çš„æœç´¢ç®—æ³•ã€‚ å¹¿åº¦ä¼˜å…ˆæœç´¢ä¸€èˆ¬ä½¿ç”¨é˜Ÿåˆ—æ¥å®ç°ã€‚ P1162 å¡«æ¶‚é¢œè‰² 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef pair&lt;int, int&gt; PII;bool visit[32][32];int g[32][32], n;int dx[5] = &#123;0, 0, 1, -1, 0&#125;;int dy[5] = &#123;1, -1, 0, 0, 0&#125;;vector&lt;PII&gt; res;bool bfs(int x, int y) &#123;\tqueue&lt;PII&gt; q;\tq.push(&#123;x, y&#125;);\tbool flag = true;\twhile (!q.empty()) &#123; auto u = q.front(); q.pop(); x = u.first, y = u.second; res.push_back(&#123;x, y&#125;); for (int i = 0; i &lt; 5; i++) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; !visit[a][b] &amp;&amp; g[a][b] == 0) &#123; if ((a == 1 || a == n || b == 1 || b == n) &amp;&amp; g[a][b] == 0) flag = false; visit[a][b] = true; q.push(&#123;a, b&#125;); &#125; &#125;\t&#125;\treturn flag;&#125;int main() &#123;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; &#125;\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (!visit[i][j] &amp;&amp; g[i][j] == 0) &#123; res.clear(); if (bfs(i, j)) &#123; for (int k = 0; k &lt; res.size(); k++) g[res[k].first][res[k].second] = 2; &#125; &#125; &#125;\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) cout &lt;&lt; g[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;\t&#125; return 0;&#125; P1443 é©¬çš„éå† P3956 æ£‹ç›˜ P1032 å­—ä¸²å˜æ¢ P1126 æœºå™¨äººæ¬é‡ç‰© è®°å¿†åŒ–æœç´¢ é€šè¿‡å°†å·²ç»éå†çš„çŠ¶æ€è®°å½•ä¸‹æ¥ï¼Œä»è€Œå‡å°‘é‡å¤çš„æœç´¢é‡ï¼Œè¿™å°±æ˜¯è®°å¿†åŒ–æœç´¢ã€‚ åŠ¨æ€è§„åˆ’çš„æ—¶å€™ï¼Œè®°å¿†åŒ–æœç´¢ä¹Ÿæ˜¯ä¸€ç§é«˜æ•ˆç®€æ´çš„å®ç°æ–¹å¼ã€‚ P1514 å¼•æ°´å…¥åŸ P1535 æ¸¸è¡çš„å¥¶ç‰› [P1434 SHOI2002]æ»‘é›ª P3953 é€›å…¬å›­ æœç´¢çš„å‰ªæ å¯¹äºä¸€äº›ä¸å¿…è¦æœç´¢çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥é¿å…è®¿é—®è¿™äº›çŠ¶æ€ï¼Œä»è€Œæé«˜æœç´¢æ•ˆç‡ã€‚ P1120 å°æœ¨æ£ ï¼»æ•°æ®åŠ å¼ºç‰ˆï¼½ P1312 Mayanæ¸¸æˆ P1074 é¶å½¢æ•°ç‹¬ åŠ¨æ€è§„åˆ’ åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§é‡è¦çš„æ€ç»´æ–¹æ³•ï¼Œé€šè¿‡åˆ©ç”¨å·²æœ‰çš„å­é—®é¢˜ä¿¡æ¯é«˜æ•ˆæ±‚å‡ºå½“å‰é—®é¢˜çš„æœ€ä¼˜è§£ã€‚ çº¿æ€§åŠ¨æ€è§„åˆ’ çº¿æ€§åŠ¨æ€è§„åˆ’ï¼Œå³å…·æœ‰çº¿æ€§é˜¶æ®µåˆ’åˆ†çš„åŠ¨æ€è§„åˆ’ã€‚ P1216 æ•°å­—ä¸‰è§’å½¢ P1020 å¯¼å¼¹æ‹¦æˆª P1091 åˆå”±é˜Ÿå½¢ P1095 å®ˆæœ›è€…çš„é€ƒç¦» P1541 ä¹Œé¾Ÿæ£‹ P1868 é¥¥é¥¿çš„å¥¶ç‰› P2679 å­ä¸² P2501 HAOI2006]æ•°å­—åºåˆ— P3336 ZJOI2013]è¯æ—§ P3558 POI2013]BAJ-Bytecomputer P4158 SCOI2009]ç²‰åˆ·åŒ  P5301 GXOI&#x2F;GZOI2019]å®ç‰Œä¸€å¤§å † èƒŒåŒ…åŠ¨æ€è§„åˆ’ èƒŒåŒ…åŠ¨æ€è§„åˆ’æ˜¯çº¿æ€§åŠ¨æ€è§„åˆ’ä¸­ç‰¹æ®Šçš„ä¸€ç±»ï¼ŒNOIPä¸­è€ƒåˆ°çš„æ¬¡æ•°ä¹Ÿä¸å°‘ã€‚ P1048 é‡‡è¯ P1060 å¼€å¿ƒçš„é‡‘æ˜ P1855 æ¦¨å–kkksc03 P5020 è´§å¸ç³»ç»Ÿ P1757 é€šå¤©ä¹‹åˆ†ç»„èƒŒåŒ… P1064 é‡‘æ˜çš„é¢„ç®—æ–¹æ¡ˆ P2946 USACO09MAR]Cow Frisbee Team P1156 åƒåœ¾é™·é˜± P5322 BJOI2019]æ’å…µå¸ƒé˜µ P5289 åäºŒçœè”è€ƒ2019]çš®é… åŒºé—´åŠ¨æ€è§„åˆ’ åŒºé—´åŠ¨æ€è§„åˆ’ä¸€èˆ¬ä»¥åŒºé—´ä½œä¸ºåŠ¨æ€è§„åˆ’çš„é˜¶æ®µã€‚ P1880 NOI1995]çŸ³å­åˆå¹¶ P3146 USACO16OPEN]248 P1063 èƒ½é‡é¡¹é“¾ P1005 çŸ©é˜µå–æ•°æ¸¸æˆ P4170 CQOI2007]æ¶‚è‰² P4302 SCOI2003]å­—ç¬¦ä¸²æŠ˜å  P2466 SDOI2008]Sueçš„å°çƒ Part 4.4 æ ‘å½¢åŠ¨æ€è§„åˆ’ æ ‘å½¢åŠ¨æ€è§„åˆ’ï¼Œå³åœ¨æ ‘ä¸Šè¿›è¡Œçš„åŠ¨æ€è§„åˆ’ã€‚ å› ä¸ºæ ‘çš„é€’å½’æ€§è´¨ï¼Œæ ‘å½¢åŠ¨æ€è§„åˆ’ä¸€èˆ¬éƒ½æ˜¯é€’å½’æ±‚è§£çš„ã€‚ P1352 æ²¡æœ‰ä¸Šå¸çš„èˆä¼š P1040 åŠ åˆ†äºŒå‰æ ‘ P1122 æœ€å¤§å­æ ‘å’Œ P1273 æœ‰çº¿ç”µè§†ç½‘ P2014 é€‰è¯¾ P2585 ZJOI2006]ä¸‰è‰²äºŒå‰æ ‘ P3047 USACO12FEB]Nearby Cows P3698 CQOI2017]å°Qçš„æ£‹ç›˜ P5658 æ‹¬å·æ ‘ P2607 ZJOI2008]éª‘å£« P3177 HAOI2015]æ ‘ä¸ŠæŸ“è‰² P4395 BOI2003]Gem P4516 JSOI2018]æ½œå…¥è¡ŒåŠ¨ å­—ç¬¦ä¸² å­—ç¬¦ä¸²é—®é¢˜æœ‰å¾ˆå¤šè‡ªå·±çš„ç‰¹ç‚¹ã€‚ å­—ç¬¦ä¸²å“ˆå¸Œ å­—ç¬¦ä¸²å“ˆå¸Œé€šè¿‡ç‰ºç‰²å¾ˆå°çš„å‡†ç¡®ç‡ï¼Œè¾¾åˆ°å¿«é€Ÿè¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…çš„æ•ˆæœã€‚ P3370 ã€æ¨¡æ¿ã€‘å­—ç¬¦ä¸²å“ˆå¸Œ P5270 æ— è®ºæ€æ ·ç¥æ ‘å¤§äººéƒ½ä¼šåˆ åº“è·‘è·¯ P5537 ã€XR-3ã€‘ç³»ç»Ÿè®¾è®¡ Part 5.2 KMP KMP ç®—æ³•å¯ä»¥ç”¨æ¥è§£å†³æ¨¡å¼ä¸²åŒ¹é…é—®é¢˜ã€‚ P3375 ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é… P4391 BOI2009]Radio Transmission P3435 POI2006]OKR-Periods of Words P4824 USACO15FEB]Censoring (Silver) P2375 NOI2014]åŠ¨ç‰©å›­ P3426 POI2005]SZA-Template P3193 HNOI2008]GTè€ƒè¯• æ•°å­¦ OI ä¸­çš„æ•°å­¦çŸ¥è¯†å¾ˆå¤šï¼Œä¹Ÿæœ‰äº›æ‚ä¹±ã€‚ ä½è¿ç®— å°†åè¿›åˆ¶æ•´æ•°è½¬æ¢ä¸ºäºŒè¿›åˆ¶åï¼Œæœ‰å¾ˆå¤šæŒ‰ä½è¿ç®—çš„è¿ç®—ç¬¦ã€‚ å¦‚æœèƒ½å–„äºåˆ©ç”¨ä½è¿ç®—çš„ä¸€äº›æ€§è´¨ï¼Œå¾€å¾€èƒ½è¾¾åˆ°äº‹åŠåŠŸå€çš„æ•ˆæœã€‚ P5657 æ ¼é›·ç  P5514 MtOI2019æ°¸å¤œçš„æŠ¥åº” P5538 ã€XR-3ã€‘NamidAme P5539 ã€XR-3ã€‘Unknown Mother-Goose P5523 yLOI2019çç  æ•´é™¤ç›¸å…³ ä¸æ•´é™¤ç›¸å…³çš„æ¦‚å¿µæœ‰å¾ˆå¤šï¼Œæ¯”è¾ƒå¸¸ç”¨çš„æœ‰ç´ æ•°ï¼Œæœ€å¤§å…¬çº¦æ•°å’Œæ¬§æ‹‰å‡½æ•°ã€‚ ç´ æ•° ç´ æ•°ï¼ŒæŒ‡çš„æ˜¯é™¤ 1 å’Œå®ƒæœ¬èº«ä¹‹å¤–æ²¡æœ‰å…¶ä»–çº¦æ•°çš„æ•°ã€‚ P4718 ã€æ¨¡æ¿ã€‘Pollard-Rhoç®—æ³• P1075 è´¨å› æ•°åˆ†è§£ P2441 è§’è‰²å±æ€§æ ‘ P5535 ã€XR-3ã€‘å°é“æ¶ˆæ¯ æœ€å¤§å…¬çº¦æ•° å¦‚æœä¸¤ä¸ªæ•°æœ‰ä¸€ä¸ªå…±åŒçš„çº¦æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªçº¦æ•°å°±è¢«ç§°ä¸ºå…¬çº¦æ•°ã€‚æœ€å¤§å…¬çº¦æ•°å°±æ˜¯æŒ‡è¿™ä¸¤ä¸ªæ•°çš„æ‰€æœ‰å…¬çº¦æ•°ä¸­ï¼Œæœ€å¤§çš„ä¸€ä¸ªã€‚ æ±‚è§£ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ï¼Œå¯ä»¥é‡‡ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•è§£å†³ã€‚ P5435 ã€æ¨¡æ¿ã€‘å¿«é€Ÿ GCD P5436 ã€XR-2ã€‘ç¼˜åˆ† P1029 æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°é—®é¢˜ P1414 åˆæ˜¯æ¯•ä¸šå­£II P2152 SDOI2009]SuperGCD P1072 Hankson çš„è¶£å‘³é¢˜ æ¬§æ‹‰å‡½æ•° æ¬§æ‹‰å‡½æ•° è¡¨ç¤ºäº†å°äº çš„æ•°å­—ä¸­ï¼Œä¸ äº’è´¨çš„æ•°å­—ä¸ªæ•°ã€‚ P2158 SDOI2008ä»ªä»—é˜Ÿ P2568 GCD P2398 GCD SUM P4139 ä¸Šå¸ä¸é›†åˆçš„æ­£ç¡®ç”¨æ³• åŒä½™æ–¹ç¨‹ æ±‚è§£åŒä½™æ–¹ç¨‹å¾€å¾€å¯ä»¥å¼•å‡ºä¸å°‘è¯é¢˜ã€‚ çº¿æ€§åŒä½™æ–¹ç¨‹&amp;ä¹˜æ³•é€†å…ƒ çº¿æ€§åŒä½™æ–¹ç¨‹æ˜¯åŒä½™æ–¹ç¨‹ä¸­æœ€åŸºç¡€çš„å†…å®¹ã€‚ P4549 ã€æ¨¡æ¿ã€‘è£´èœ€å®šç† P2613 ã€æ¨¡æ¿ã€‘æœ‰ç†æ•°å–ä½™ P3811 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ P5431 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ2 P1082 åŒä½™æ–¹ç¨‹ P3951 å°å‡¯çš„ç–‘æƒ‘ P1516 é’è›™çš„çº¦ä¼š ä¸­å›½å‰©ä½™å®šç† ä¸­å›½å‰©ä½™å®šç†å¯ä»¥å¿«é€Ÿè§£ä¸€å…ƒçº¿æ€§åŒä½™æ–¹ç¨‹ç»„ã€‚ P4777 ã€æ¨¡æ¿ã€‘æ‰©å±•ä¸­å›½å‰©ä½™å®šç†ï¼ˆEXCRTï¼‰ P3868 TJOI2009]çŒœæ•°å­— P2480 SDOI2010]å¤ä»£çŒªæ–‡ P4774 NOI2018]å± é¾™å‹‡å£« P5345 ã€XR-1ã€‘å¿«ä¹è‚¥å®… é«˜æ¬¡åŒä½™æ–¹ç¨‹ BSGS ç®—æ³•å¯ä»¥é«˜æ•ˆè®¡ç®—ç¦»æ•£å¯¹æ•°ã€‚ è€Œé«˜æ¬¡å‰©ä½™çš„æ±‚è§£æ›´åŠ å¤æ‚ï¼Œå…¶ä¸­äºŒæ¬¡å‰©ä½™ä½œä¸ºé«˜æ¬¡å‰©ä½™ä¸­æ¯”è¾ƒç‰¹æ®Šçš„æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨ Cipolla æ³•æ±‚è§£ã€‚ P4195 ã€æ¨¡æ¿ã€‘exBSGS P5491 ã€æ¨¡æ¿ã€‘äºŒæ¬¡å‰©ä½™ P3306 SDOI2013]éšæœºæ•°ç”Ÿæˆå™¨ P2485 SDOI2011]è®¡ç®—å™¨ åšå¼ˆè®º åšå¼ˆè®ºè€ƒè™‘æ¸¸æˆä¸­çš„ä¸ªä½“çš„é¢„æµ‹è¡Œä¸ºå’Œå®é™…è¡Œä¸ºï¼Œå¹¶ç ”ç©¶å®ƒä»¬çš„ä¼˜åŒ–ç­–ç•¥ã€‚ P2197 ã€æ¨¡æ¿ã€‘nimæ¸¸æˆ P1288 å–æ•°æ¸¸æˆII P1290 æ¬§å‡ é‡Œå¾·çš„æ¸¸æˆ P1247 å–ç«æŸ´æ¸¸æˆ P2252 å–çŸ³å­æ¸¸æˆ æ¦‚ç‡ä¸æœŸæœ› æ¦‚ç‡å’ŒæœŸæœ›æ˜¯ç´§å¯†ç›¸è¿çš„ï¼ŒOI ä¸­å¾€å¾€ä¼šå‡ºç°å’Œæ¦‚ç‡æœŸæœ›ç›¸å…³çš„åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚ P5104 çº¢åŒ…å‘çº¢åŒ… P1850 æ¢æ•™å®¤ P3830 SHOI2012]éšæœºæ ‘ P4564 CTSC2018]å‡é¢ P2473 SCOI2008]å¥–åŠ±å…³ P2221 HAOI2012]é«˜é€Ÿå…¬è·¯ P3239 HNOI2015]äºšç‘Ÿç‹ P3750 å…­çœè”è€ƒ2017]åˆ†æ‰‹æ˜¯ç¥æ„¿ P4284 SHOI2014]æ¦‚ç‡å……ç”µå™¨ P5249 LnOI2019]åŠ ç‰¹æ—è½®ç›˜èµŒ P2081 NOI2012]è¿·å¤±æ¸¸ä¹å›­ P3343 ZJOI2015]åœ°éœ‡åçš„å¹»æƒ³ä¹¡ P3600 éšæœºæ•°ç”Ÿæˆå™¨ P5326 ZJOI2019]å¼€å…³ æ•°æ®ç»“æ„ çµæ´»åœ°è¿ç”¨æ•°æ®ç»“æ„å¯ä»¥é«˜æ•ˆåœ°æŸ¥è¯¢å¹¶å¤„ç†éœ€è¦çš„ä¿¡æ¯ã€‚ é“¾è¡¨ åœ¨ä¸€ä¸ªæ•°åˆ—ä¸­é«˜æ•ˆæ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œé“¾è¡¨æ¯«æ— ç–‘é—®æ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚ P1996 çº¦ç‘Ÿå¤«é—®é¢˜ P1160 é˜Ÿåˆ—å®‰æ’ æ ˆ æ ˆï¼Œæ˜¯ä¸€ç§åè¿›å…ˆå‡ºï¼ˆFILOï¼‰çš„æ•°æ®ç»“æ„ã€‚ P1449 åç¼€è¡¨è¾¾å¼ P1739 è¡¨è¾¾å¼æ‹¬å·åŒ¹é… P1981 è¡¨è¾¾å¼æ±‚å€¼ P1175 è¡¨è¾¾å¼çš„è½¬æ¢ é˜Ÿåˆ— é˜Ÿåˆ—ï¼Œæ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰çš„æ•°æ®ç»“æ„ã€‚ P1540 æœºå™¨ç¿»è¯‘ å¹¶æŸ¥é›† å¹¶æŸ¥é›†å¸¸ç”¨äºå¤„ç†ä¸€äº›ä¸ç›¸äº¤é›†åˆçš„åˆå¹¶å’ŒæŸ¥è¯¢é—®é¢˜ã€‚ P1111 ä¿®å¤å…¬è·¯ P3958 å¥¶é…ª P1525 å…³æŠ¼ç½ªçŠ¯ P4185 USACO18JAN MooTube G P2024 NOI2001é£Ÿç‰©é“¾ P1197 JSOI2008æ˜Ÿçƒå¤§æˆ˜ P1196 NOI2002é“¶æ²³è‹±é›„ä¼ è¯´ P1955 NOI2015ç¨‹åºè‡ªåŠ¨åˆ†æ Part 7.5 äºŒå‰å † äºŒå‰å †æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œå †ä¸­æŸä¸ªèŠ‚ç‚¹çš„å€¼æ€»æ˜¯ä¸å¤§äºæˆ–ä¸å°äºå…¶çˆ¶èŠ‚ç‚¹çš„å€¼ã€‚ P3378 ã€æ¨¡æ¿ã€‘å † P1090 åˆå¹¶æœå­ P1168 ä¸­ä½æ•° P2085 æœ€å°å‡½æ•°å€¼ P2827 èš¯èš“ P3045 USACO12FEB Cow Coupons Part 7.6 STè¡¨ STè¡¨å¯ä»¥ç¦»çº¿æŸ¥è¯¢åŒºé—´æœ€å€¼ã€‚ P3865 ã€æ¨¡æ¿ã€‘STè¡¨ P2251 è´¨é‡æ£€æµ‹ P1816 å¿ è¯š P1198 JSOI2008æœ€å¤§æ•° P2880 USACO07JAN Balanced Lineup P5012 æ°´ã®æ•°åˆ— P5344 ã€XR-1ã€‘é€›æ£®æ— P2048 NOI2010 è¶…çº§é’¢ç´ Part 7.7 æ ‘çŠ¶æ•°ç»„ æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§ç®€æ´é«˜æ•ˆçš„æ ‘å½¢æ•°æ®ç»“æ„ã€‚ P3374 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 1 P3368 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 2 P1908 é€†åºå¯¹ P1966 ç«æŸ´æ’é˜Ÿ P3605 USACO17JAN Promotion Counting P1972 SDOI2009 HHçš„é¡¹é“¾ P3586 POI2015 LOG P4054 JSOI2009è®¡æ•°é—®é¢˜ P4113 HEOI2012é‡‡èŠ± P3960 åˆ—é˜Ÿ çº¿æ®µæ ‘ çº¿æ®µæ ‘çš„é€šç”¨æ€§æ¯”æ ‘çŠ¶æ•°ç»„æ›´å¼ºï¼Œå¯ä»¥å¤„ç†æ›´å¤šæ¶‰åŠåŒºé—´æ“ä½œçš„é¢˜ç›®ã€‚ P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 P3373 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2 P5490 ã€æ¨¡æ¿ã€‘æ‰«æçº¿ P4588 TJOI2018æ•°å­¦è®¡ç®— P1502 çª—å£çš„æ˜Ÿæ˜Ÿ P2471 SCOI2007é™é›¨é‡ P2824 HEOI2016&#x2F;TJOI2016æ’åº P3722 AH2017&#x2F;HNOI2017å½±é­” P4097 HEOI2013Segment P4198 æ¥¼æˆ¿é‡å»º P4513 å°ç™½é€›å…¬å›­ P4556 Vaniæœ‰çº¦ä¼šé›¨å¤©çš„å°¾å·´ P5324 BJOI2019åˆ æ•° P5327 ZJOI2019è¯­è¨€ å›¾è®º å›¾è®ºæ˜¯æ•°å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œå®ƒä»¥å›¾ä¸ºç ”ç©¶çš„å¯¹è±¡ã€‚ å›¾çš„å­˜å‚¨ä¸éå† è¿™é‡Œçš„å›¾è®ºå†…å®¹éƒ½æ¯”è¾ƒç®€å•ï¼Œæ¶‰åŠå›¾çš„å­˜å‚¨ä»¥åŠéå†å›¾çš„æ–¹å¼ã€‚ P2661 ä¿¡æ¯ä¼ é€’ P2921 USACO08DEC Trick or Treat on the Farm æœ€çŸ­è·¯é—®é¢˜ å¾ˆå¤šé¢˜ç›®éƒ½å¯ä»¥è½¬åŒ–ä¸ºæœ€çŸ­è·¯çš„æ¨¡å‹ã€‚å› æ­¤ï¼ŒæŒæ¡æœ€çŸ­è·¯ç®—æ³•éå¸¸é‡è¦ã€‚ P3371 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆå¼±åŒ–ç‰ˆï¼‰ P4779 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ ‡å‡†ç‰ˆï¼‰ P5905 ã€æ¨¡æ¿ã€‘Johnson å…¨æºæœ€çŸ­è·¯ P1144 æœ€çŸ­è·¯è®¡æ•° P1462 é€šå¾€å¥¥æ ¼ç‘ç›çš„é“è·¯ P1522 Cow Tours P1266 é€Ÿåº¦é™åˆ¶ P4001 ICPC-Beijing 2006ç‹¼æŠ“å…”å­ P4568 JLOI2011 é£è¡Œè·¯çº¿ P3238 HNOI2014 é“è·¯å µå¡ P5304 GXOI&#x2F;GZOI2019 æ—…è¡Œè€… æ ‘ä¸Šé—®é¢˜ ä½œä¸ºä¸€ç§ç‰¹æ®Šçš„å›¾ï¼Œæ ‘ä¸Šçš„é—®é¢˜å…·æœ‰å¾ˆå¤šé²œæ˜çš„ç‰¹ç‚¹ã€‚ äºŒå‰æ ‘ äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ‘ï¼Œå®ƒæœ‰å¾ˆå¤šç‰¹æ®Šçš„æ€§è´¨ã€‚ P1087 FBIæ ‘ P1030 æ±‚å…ˆåºæ’åˆ— P1305 æ–°äºŒå‰æ ‘ P1229 éå†é—®é¢˜ P5018 å¯¹ç§°äºŒå‰æ ‘ P5597 ã€XR-4ã€‘å¤è¯» Part 8.3.2 æ ‘çš„ç›´å¾„ æ ‘çš„ç›´å¾„è¢«å®šä¹‰ä¸ºæ ‘ä¸Šæœ€è¿œçš„ä¸¤ç‚¹é—´çš„è·ç¦»ã€‚ è®¡ç®—æ ‘çš„ç›´å¾„ï¼Œå¯ä»¥é€šè¿‡ä¸¤é DFS è§£å†³ã€‚ P2195 HXYé€ å…¬å›­ P3629 APIO2010 å·¡é€» P5536 ã€XR-3ã€‘æ ¸å¿ƒåŸå¸‚ P1099 æ ‘ç½‘çš„æ ¸ P4408 NOI2003é€ƒå­¦çš„å°å­© å…¬å…±ç¥–å…ˆ ä¸¤ä¸ªç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå³ä¸¤ä¸ªç‚¹çš„æ‰€æœ‰å…¬å…±ç¥–å…ˆä¸­ï¼Œç¦»æ ¹èŠ‚ç‚¹æœ€è¿œçš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚ æ±‚è§£æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå¸¸ç”¨çš„æ–¹æ³•æ˜¯æ ‘ä¸Šå€å¢æˆ–è€…æ ‘é“¾å‰–åˆ†ã€‚ P3379 ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ P3938 æ–æ³¢é‚£å¥‘ P4281 AHOI2008 ç´§æ€¥é›†åˆ &#x2F; èšä¼š ç”Ÿæˆæ ‘ ç”¨ æ¡è¾¹å°†å›¾ä¸Šçš„ ä¸ªç‚¹è¿æ¥èµ·æ¥ï¼Œå½¢æˆçš„æ ‘å°±è¢«ç§°ä¸ºç”Ÿæˆæ ‘ã€‚ P3366 ã€æ¨¡æ¿ã€‘æœ€å°ç”Ÿæˆæ ‘ [P4180 ã€æ¨¡æ¿ã€‘ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘BJWC2010] [P2872 USACO07DEC]Building Roads P1991 æ— çº¿é€šè®¯ç½‘ P1967 è´§è½¦è¿è¾“ [P4047 JSOI2010]éƒ¨è½åˆ’åˆ† æ‹“æ‰‘æ’åº å°†ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾æ’åºï¼Œä½¿å¾—æ‰€æœ‰æ’åœ¨å‰é¢çš„èŠ‚ç‚¹ä¸èƒ½ä¾èµ–äºæ’åœ¨åé¢çš„èŠ‚ç‚¹ï¼Œè¿™å°±æ˜¯æ‹“æ‰‘æ’åºã€‚ P1113 æ‚åŠ¡ P1983 è½¦ç«™åˆ†çº§ P1038 ç¥ç»ç½‘ç»œ å·®åˆ†çº¦æŸ å·®åˆ†çº¦æŸè¦è§£å†³çš„é—®é¢˜æ˜¯ï¼šæ±‚å‡ºä¸€ç»„ å…ƒä¸ç­‰å¼çš„ä¸€ç»„è§£ï¼Œä½¿å¾—æ‰€æœ‰çº¦æŸå…³ç³»éƒ½èƒ½å¾—åˆ°æ»¡è¶³ã€‚ P5960 ã€æ¨¡æ¿ã€‘å·®åˆ†çº¦æŸç®—æ³• [P3275 SCOI2011]ç³–æœ [P2294 HNOI2005]ç‹¡çŒ¾çš„å•†äºº [P4926 1007]å€æ€æµ‹é‡è€… P5590 èµ›è½¦æ¸¸æˆ å›¾çš„è¿é€šæ€§ç›¸å…³ åˆ©ç”¨ Tarjan ç®—æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è§£å†³å¾ˆå¤šä¸å›¾çš„è¿é€šæ€§ç›¸å…³çš„é—®é¢˜ã€‚ P3387 ã€æ¨¡æ¿ã€‘ç¼©ç‚¹ P3388 ã€æ¨¡æ¿ã€‘å‰²ç‚¹ï¼ˆå‰²é¡¶ï¼‰ [P2341 HAOI2006]å—æ¬¢è¿çš„ç‰› [P2863 USACO06JAN]The Cow Prom [P2746 USACO5.3]Network of Schools [P1407 å›½å®¶é›†è®­é˜Ÿ]ç¨³å®šå©šå§» [P2272 ZJOI2007]æœ€å¤§åŠè¿é€šå­å›¾ [P3225 HNOI2012]çŸ¿åœºæ­å»º [P5058 ZJOI2004]å—…æ¢å™¨ [P2515 HAOI2010]è½¯ä»¶å®‰è£…","tags":["ç®—æ³•","C++","æ´›è°·"],"categories":["ç®—æ³•"]},{"title":"åŠ›æ‰£Hot100","path":"/2024/09/09/åŠ›æ‰£Hot100/","content":"åŠ›æ‰£Hot100å“ˆå¸Œä¸¤æ•°ä¹‹å’Œ1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; st; for (int i = 0; i &lt; nums.size(); i++) &#123; if (st.find(target - nums[i]) != st.end()) &#123; return &#123;i, st[target - nums[i]]&#125;; &#125; else &#123; st[nums[i]] = i; &#125; &#125; return &#123;&#125;; &#125;&#125;; å­—æ¯å¼‚ä½è¯åˆ†ç»„12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt; &gt; st; for (int i = 0; i &lt; strs.size(); i++) &#123; string t = strs[i]; sort(strs[i].begin(), strs[i].end()); st[strs[i]].push_back(t); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto it: st) &#123; res.push_back(it.second); &#125; return res; &#125;&#125;; æœ€é•¿è¿ç»­åºåˆ—æ’åº 1234567891011121314151617181920class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &lt; nums.size();) &#123; int t = 1; while (i &lt; nums.size() - 1) &#123; if (nums[i] == nums[i + 1]) i++; else if (nums[i] == nums[i + 1] - 1) &#123; t++; i++; &#125; else break; &#125; if (t == 1) i++; res = max(res, t); &#125; return res; &#125;&#125;; å“ˆå¸Œ 12345678910111213141516171819class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; sets; for (auto num: nums) sets.insert(num); int res = 0; for (auto num: sets) &#123; if (!sets.count(num - 1)) &#123; int cur = num, t = 1; while (sets.count(cur + 1)) &#123; cur++; t++; &#125; res = max(res, t); &#125; &#125; return res; &#125;&#125;; åŒæŒ‡é’ˆç§»åŠ¨é›¶12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = 0, n = nums.size(); while (r &lt; n) &#123; if (nums[r]) &#123; swap(nums[l], nums[r]); l++; &#125; r++; &#125; &#125;&#125;; ç››æœ€å¤šæ°´çš„å®¹å™¨1234567891011121314class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int l = 0, r = height.size()-1; int res = 0; while (l &lt; r) &#123; int t = min(height[l], height[r]) * (r - l); res = max(res, t); if (height[l] &lt;= height[r]) l++; else r--; &#125; return res; &#125;&#125;; ä¸‰æ•°ä¹‹å’Œæš´åŠ› 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; st; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size(); i++) st[nums[i]] = i; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (j != i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; if (st[-nums[i] - nums[j]] &gt; i &amp;&amp; st[-nums[i] - nums[j]] &gt; j) res.push_back(&#123;nums[i], nums[j], -nums[i] - nums[j]&#125;); &#125; &#125; return res; &#125;&#125;; åŒæŒ‡é’ˆ 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i &lt; n - 2; i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] &gt; 0) break; if (nums[i] + nums[n - 2] + nums[n - 1] &lt; 0) continue; int j = i + 1, k = n - 1; while (j &lt; k) &#123; int s = nums[i] + nums[j] + nums[k]; if (s &gt; 0) k--; else if (s &lt; 0) j++; else &#123; res.push_back(&#123;nums[i], nums[j++], nums[k--]&#125;); while(j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; while(j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; &#125; &#125; &#125; return res; &#125;&#125;; æ»‘åŠ¨çª—å£æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int nums[128]; int i = 0, j = 0, res = 0; while (j &lt; s.size()) &#123; nums[s[j]]++; while (nums[s[j]] &gt; 1) nums[s[i++]]--; res = max(res, j - i + 1); j++; &#125; return res; &#125;&#125;; æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int l = 0, r = 0, valid = 0; unordered_map&lt;char, int&gt; need, window; vector&lt;int&gt; res; for (char ch: p) need[ch]++; while (r &lt; s.size()) &#123; char c = s[r++]; if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; while (r - l &gt;= p.size()) &#123; if (valid == need.size()) res.push_back(l); char d = s[l++]; if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; return res; &#125;&#125;; å­—ä¸²å’Œä¸º K çš„å­æ•°ç»„1234567891011121314class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int res = 0, s[20005]; for (int i = 0; i &lt; nums.size(); i++) s[i + 1] = s[i] + nums[i]; unordered_map&lt;int, int&gt; cnt; for (int i = 0; i &lt;= nums.size(); i++) &#123; if (cnt.contains(s[i] - k)) res += cnt[s[i] - k]; cnt[s[i]]++; &#125; return res; &#125;&#125;; æ»‘åŠ¨çª—å£æœ€å¤§å€¼ä¼˜å…ˆé˜Ÿåˆ— 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); priority_queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; k; i++) q.push(&#123;nums[i], i&#125;); vector&lt;int&gt; res = &#123;q.top().first&#125;; for (int i = k; i &lt; n; i++) &#123; q.push(&#123;nums[i], i&#125;); while (q.top().second &lt;= i - k) q.pop(); res.push_back(q.top().first); &#125; return res; &#125;&#125;; å•è°ƒé˜Ÿåˆ— 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); deque&lt;int&gt; q; vector&lt;int&gt; res; int l = 0; for (int i = 0; i &lt; k; i++) &#123; while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back(); q.push_back(i); &#125; res.push_back(nums[q.front()]); for (int i = k; i &lt; n; i++) &#123; while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back(); q.push_back(i); while (q.front() &lt;= i - k) q.pop_front(); res.push_back(nums[q.front()]); &#125; return res; &#125;&#125;; æ™®é€šæ•°ç»„æœ€å¤§å­æ•°ç»„å’ŒåŠ¨æ€è§„åˆ’ 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int dp[100005], res = -0x3f3f3f3f; dp[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) dp[i] = max(nums[i], dp[i - 1] + nums[i]); for (int i = 0; i &lt; nums.size(); i++) res = max(res, dp[i]); return res; &#125;&#125;; åˆå¹¶åŒºé—´123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; intervals.size();) &#123; int t = intervals[i][1]; int j = i + 1; while (j &lt; intervals.size() &amp;&amp; intervals[j][0] &lt;= t) &#123; t = max(t, intervals[j][1]); j++; &#125; res.push_back(&#123;intervals[i][0], t&#125;); i = j; &#125;; return res; &#125;&#125;; è½®è½¬æ•°ç»„12345678910class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int t[100005], size = nums.size(); for (int i = 0; i &lt; size; i++) t[(i + k) % size] = nums[i]; for (int i = 0; i &lt; size; i++) nums[i] = t[i]; &#125;&#125;; çŸ©é˜µçŸ©é˜µç½®é›¶12345678910111213141516171819class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row[205], col[205], n = matrix.size(), m = matrix[0].size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (matrix[i][j] == 0) &#123; row[i] = 1; col[j] = 1; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (row[i] || col[j]) matrix[i][j] = 0; &#125; &#125; &#125;&#125;; èºæ—‹çŸ©é˜µ123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = m - 1, u = 0, d = n - 1; vector&lt;int&gt; res; while (true) &#123; for (int i = l; i &lt;= r; i++) res.push_back(matrix[u][i]); u++; if (u &gt; d) break; for (int i = u; i &lt;= d; i++) res.push_back(matrix[i][r]); r--; if (l &gt; r) break; for (int i = r; i &gt;= l; i--) res.push_back(matrix[d][i]); d--; if (u &gt; d) break; for (int i = d; i &gt;= u; i--) res.push_back(matrix[i][l]); l++; if (l &gt; r) break; &#125; return res; &#125;&#125;; é“¾è¡¨äºŒå‰æ ‘å›¾è®ºå›æº¯äºŒåˆ†æŸ¥æ‰¾35. æœç´¢æ’å…¥ä½ç½®12345678910111213class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &lt; target) l = mid + 1; else r = mid; &#125; if (l == nums.size() - 1 &amp;&amp; nums[l] &lt; target) return l + 1; else return l; &#125;&#125;; 74. æœç´¢äºŒç»´çŸ©é˜µ1234567891011121314151617181920class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (matrix[mid].back() &lt; target) l = mid + 1; else r = mid; &#125; int t = l; l = 0, r = m - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (matrix[t][mid] &lt; target) l = mid + 1; else r = mid; &#125; return matrix[t][l] == target; &#125;&#125;; 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; if (nums.empty()) &#123; res.push_back(-1); res.push_back(-1); return res; &#125; int n = nums.size(); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &lt; target) l = mid + 1; else r = mid; &#125; if (nums[l] == target) res.push_back(l); else res.push_back(-1); l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (nums[mid] &gt; target) r = mid - 1; else l = mid; &#125; if (nums[r] == target) res.push_back(l); else res.push_back(-1); return res; &#125;&#125;; 33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„1234567891011121314151617181920212223class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if (target == nums[mid]) return mid; else if (nums[mid] &lt; nums[r]) &#123; if (nums[mid] &lt; target &amp;&amp; nums[r] &gt;= target) l = mid + 1; else r = mid - 1; &#125; else &#123; if (nums[mid] &gt; target &amp;&amp; nums[l] &lt;= target) r = mid - 1; else l = mid + 1; &#125; &#125; return -1; &#125;&#125;; æ ˆå †è´ªå¿ƒç®—æ³•121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int t = prices[0], res = 0; for (int i = 0; i &lt; prices.size(); i++) &#123; t = min(t, prices[i]); res = max(res, prices[i] - t); &#125; return res; &#125;&#125;; 55. è·³è·ƒæ¸¸æˆ123456789101112class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int dp[10005] = &#123;0&#125;; dp[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if (dp[i - 1] &lt;= 0) return false; dp[i] = max(dp[i - 1] - 1, nums[i]); &#125; return true; &#125;&#125;; 45. è·³è·ƒæ¸¸æˆ II1234567891011121314class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int res = 0, end = 0, maxa = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; maxa = max(nums[i] + i, maxa); if (i == end) &#123; end = maxa; res++; &#125; &#125; return res; &#125;&#125;; 763. åˆ’åˆ†å­—æ¯åŒºé—´1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; partitionLabels(string s) &#123; int last[26], n = s.size(); for (int i = 0; i &lt; n; i++) last[s[i] - &#x27;a&#x27;] = i; vector&lt;int&gt; res; int start = 0, end = 0; for (int i = 0; i &lt; n; i++) &#123; end = max(end, last[s[i] - &#x27;a&#x27;]); if (i == end) &#123; res.push_back(end - start + 1); start = end + 1; &#125; &#125; return res; &#125;&#125;; åŠ¨æ€è§„åˆ’70. çˆ¬æ¥¼æ¢¯1234567891011class Solution &#123;public: int climbStairs(int n) &#123; int dp[50]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; &#125;&#125;; 118. æ¨è¾‰ä¸‰è§’12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res; int dp[31][31]; dp[1][1] = 1; for (int i = 2; i &lt;= numRows; i++) &#123; for (int j = 1; j &lt;= i; j++) dp[i][j] = dp[i-1][j - 1] + dp[i-1][j]; &#125; for (int i = 1; i &lt;= numRows; i++) &#123; vector&lt;int&gt; t; for (int j = 1; j &lt;= i; j++) t.push_back(dp[i][j]); res.push_back(t); &#125; return res; &#125;&#125;; 198. æ‰“å®¶åŠ«èˆ1234567891011121314151617class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int dp[105], res; if (nums.size() == 1) res = nums[0]; else if (nums.size() == 2) res = max(nums[0], nums[1]); else &#123; dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); i++) &#123; dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); &#125; res = dp[nums.size() - 1]; &#125; return res; &#125;&#125;; 279. å®Œå…¨å¹³æ–¹æ•°1234567891011121314class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; f(n + 1); for (int i = 1; i &lt;= n; i++) &#123; int minn = INT_MAX; for (int j = 1; j * j &lt;= i; j++) &#123; minn = min(minn, f[i - j * j]); &#125; f[i] = minn + 1; &#125; return f[n]; &#125;&#125;; 322. é›¶é’±å…‘æ¢123456789101112131415class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int dp[10005]; fill(dp, dp + amount + 1, 10005); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.size(); j++) &#123; if (i - coins[j] &gt;= 0) dp[i] = min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; if (dp[amount] == 10005) return -1; else return dp[amount]; &#125;&#125;; 139. å•è¯æ‹†åˆ†123456789101112131415class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; vector&lt;bool&gt; dp(s.size() + 1); dp[0] = true; for (int i = 1; i &lt;= s.size(); i++) &#123; for (auto &amp; word: wordDict) &#123; int sz = word.size(); if (i - sz &gt;= 0 &amp;&amp; s.substr(i - sz, sz) == word) dp[i] = dp[i] || dp[i - sz]; &#125; &#125; return dp[s.size()]; &#125;&#125;; å¤šç»´åŠ¨æ€è§„åˆ’62. ä¸åŒè·¯å¾„1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[m][n]; for (int i = 0; i &lt; m; i++) dp[i][0] = 1; for (int i = 0; i &lt; n; i++) dp[0][i] = 1; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; 64. æœ€å°è·¯å¾„å’Œ 1234567891011121314class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int dp[205][205], n = grid.size(), m = grid[0].size(); for (int i = 1; i &lt;= m; i++) dp[1][i] = dp[1][i - 1] + grid[0][i - 1]; for (int i = 1; i &lt;= n; i++) dp[i][1] = dp[i - 1][1] + grid[i - 1][0]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= m; j++) &#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; &#125; &#125; return dp[n][m]; &#125;&#125;; æŠ€å·§","tags":["ç®—æ³•","LeetCode","C++"],"categories":["ç®—æ³•"]},{"title":"PAT ç”²çº§","path":"/2024/08/30/PATç”²çº§/","content":"PATç”²çº§1001 A+B Format12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int c = a + b; if (c &lt; 0) &#123; cout &lt;&lt; &#x27;-&#x27;; c = -c; &#125; if (c &gt;= 1000) &#123; string t = to_string(c); int d = t.size() % 3; if(d) cout &lt;&lt; t.substr(0, d) &lt;&lt; &quot;,&quot;; for (int i = d; i &lt; t.size(); i += 3) &#123; cout &lt;&lt; t.substr(i, 3); if (i + 3 &lt; t.size()) cout &lt;&lt; &quot;,&quot;; &#125; &#125; else cout &lt;&lt; c; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; string s = to_string(a + b); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; s[i]; if (s[i] == &#x27;-&#x27;) continue; if ((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1) cout &lt;&lt; &#x27;,&#x27;; &#125; return 0;&#125; 1002 A+B for Polynomials1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 1001;double nums[N];int main() &#123; int n, a; double b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums[a] = b; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums[a] += b; &#125; int cnt = 0; for (int i = 1000; i &gt;= 0; i--) &#123; if (nums[i]) cnt++; &#125; cout &lt;&lt; cnt; for (int i = 1000; i &gt;= 0; i--) &#123; if (nums[i]) &#123; printf(&quot; %d %.1f&quot;, i, nums[i]); &#125; &#125; return 0;&#125; 1003 Emergency12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 501;const int INF = 0x3f3f3f3f;int vals[N], d[N], num[N], val[N];bool visit[N];vector&lt;PII&gt; g[N];void djkstra(int s, int n) &#123; fill(d, d + N, INF); d[s] = 0; val[s] = vals[s]; num[s] = 1; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; u = j; mind = d[j]; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) &#123; if (d[u] + dis &lt; d[v]) &#123; d[v] = d[u] + dis; num[v] = num[u]; val[v] = val[u] + vals[v]; &#125; else if (d[u] + dis == d[v]) &#123; num[v] = num[v] + num[u]; val[v] = max(val[v], val[u] + vals[v]); &#125; &#125; &#125; &#125;&#125;int main() &#123; int n, m, c1, c2, u, v, w; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; vals[i]; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(&#123;v, w&#125;); g[v].push_back(&#123;u, w&#125;); &#125; djkstra(c1, n); cout &lt;&lt; num[c2] &lt;&lt; &quot; &quot; &lt;&lt; val[c2]; return 0;&#125; 1004 Counting Leavesbfs 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; trees[101];void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; int len = q.size(); int t = 0; while (len--) &#123; u = q.front(); q.pop(); for (int i = 0; i &lt; trees[u].size(); i++) &#123; q.push(trees[u][i]); &#125; if (trees[u].empty()) t++; &#125; cout &lt;&lt; t; if (!q.empty()) cout &lt;&lt; &quot; &quot;; &#125; &#125;int main() &#123; int n, m, id1, k, id2; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id1 &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; id2; trees[id1].push_back(id2); &#125; &#125; bfs(1); return 0;&#125; dfs 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; trees[101];int res[101], maxdepth;void dfs(int u, int depth) &#123; if (trees[u].size() == 0) &#123; res[depth]++; maxdepth = max(maxdepth, depth); &#125; for (int i = 0; i &lt; trees[u].size(); i++) &#123; dfs(trees[u][i], depth + 1); &#125;&#125;int main() &#123; int n, m, id1, k, id2; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id1 &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; id2; trees[id1].push_back(id2); &#125; &#125; dfs(1, 0); for (int i = 0; i &lt;= maxdepth; i++) &#123; cout &lt;&lt; res[i]; if (i &lt; maxdepth) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1005 Spell It Right123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; string words[10] = &#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;&#125;; int res = 0; for (int i = 0; i &lt; str.length(); i++) &#123; res += str[i] - &#x27;0&#x27;; &#125; string res2 = to_string(res); for (int i = 0; i &lt; res2.length(); i++) &#123; cout &lt;&lt; words[res2[i] - &#x27;0&#x27;]; if (i &lt; res2.length() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1006 Sign In and Sign Out123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string name, start, end, res1_name, res1_start = &quot;23:59:59&quot;, res2_name, res2_end = &quot;00:00:00&quot;; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; start &gt;&gt; end; if (start &lt; res1_start) &#123; res1_name = name; res1_start = start; &#125; if (end &gt; res2_end) &#123; res2_name = name; res2_end = end; &#125; &#125; cout &lt;&lt; res1_name &lt;&lt; &quot; &quot; &lt;&lt; res2_name; return 0;&#125; 1007 Maximum Subsequence Sum1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;int nums[10001], dp[10001];int main() &#123; int n; cin &gt;&gt; n; fill(dp, dp + n, -INF); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; dp[0] = nums[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); &#125; int res = -INF, start = 0, end = n - 1, t = 0; for (int i = 0; i &lt; n; i++) &#123; if (res &lt; dp[i]) &#123; res = dp[i]; end = i; &#125; &#125; if (res == 0) start = end; else if (res &gt; 0) &#123; for (int i = end; i &gt;= 0; i--) &#123; if (t &lt; res) &#123; t += nums[i]; start = i; &#125; &#125; &#125; else &#123; res = 0; start = 0; end = n - 1; &#125; cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; nums[start] &lt;&lt; &quot; &quot; &lt;&lt; nums[end]; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int nums[100001];int main() &#123; int n; cin &gt;&gt; n; int left = 0, right = n - 1, res = -1, temp = 0, tempindex = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; temp = temp + nums[i]; if (temp &lt; 0) &#123; temp = 0; tempindex = i + 1; &#125; else if (temp &gt; res) &#123; res = temp; left = tempindex; right = i; &#125; &#125; if (res &lt; 0) res = 0; cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; nums[left] &lt;&lt; &quot; &quot; &lt;&lt; nums[right]; return 0;&#125; 1008 Elevator1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n, pre = 0, now, res = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; now; if (now &gt; pre) res += (now - pre) * 6 + 5; else res += (pre - now) * 4 + 5; pre = now; &#125; cout &lt;&lt; res; return 0;&#125; 1009 Product of Polynomials1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 1001;double nums[N], res[N * N];int main() &#123; int k, a, cnt = 0; double b; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums[a] = b; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; for (int j = 0; j &lt; N; j++) &#123; res[a + j] += b * nums[j]; &#125; &#125; for (int i = 0; i &lt; N * N; i++) if (res[i]) cnt++; cout &lt;&lt; cnt; for (int i = N * N - 1; i &gt;= 0; i--) if (res[i]) printf(&quot; %d %.1f&quot;, i, res[i]); return 0;&#125; 1010 Radix12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;LL convert(string s, int k) &#123; LL sum = 0, idx = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; int t = isdigit(s[i]) ? s[i] - &#x27;0&#x27; : s[i] - &#x27;a&#x27; + 10; sum += t * pow(k, idx++); &#125; return sum;&#125;LL find(string s, LL num) &#123; char maxt = *max_element(s.begin(), s.end()); LL low = isdigit(maxt) ? maxt - &#x27;0&#x27; + 1 : maxt - &#x27;a&#x27; + 11; LL high = max(low, num); while (low &lt;= high) &#123; LL mid = low + high &gt;&gt; 1; LL t = convert(s, mid); if (t &lt; 0 | t &gt; num) high = mid - 1; else if (t == num) return mid; else low = mid + 1; &#125; return -1;&#125;int main() &#123; string n1, n2; int tag, radix, res; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; tag &gt;&gt; radix; if (tag == 1) res = find(n2, convert(n1, radix)); else res = find(n1, convert(n2, radix)); if (res == -1) cout &lt;&lt; &quot;Impossible&quot;; else cout &lt;&lt; res; return 0;&#125; 1011 World Cup Betting1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;double fun(double a, double b, double c) &#123; double res = 1; if (b &gt;= a &amp;&amp; b &gt;= c) &#123; cout &lt;&lt; &quot;T &quot;; res *= b; &#125; else if (a &gt;= b &amp;&amp; a &gt;= c) &#123; cout &lt;&lt; &quot;W &quot;; res *= a; &#125; else &#123; cout &lt;&lt; &quot;L &quot;; res *= c; &#125; return res;&#125;int main() &#123; double a, b, c; double res = 1; for (int i = 0; i &lt; 3; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; res *= fun(a * 0.65, b, c); &#125; printf(&quot;%.2f&quot;, 2 * (res - 1)); return 0;&#125; 1012 The Best Rank123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; int num, c, m, e; double a; student(int _num, int _c, int _m, int _e, double _a) &#123; num = _num, c = _c, m = _m, e = _e, a = _a; &#125; student()&#123;&#125;;&#125; nums[2000];bool cmp_a(student a, student b) &#123; return a.a &gt; b.a;&#125;bool cmp_c(student a, student b) &#123; return a.c &gt; b.c;&#125;bool cmp_m(student a, student b) &#123; return a.m &gt; b.m;&#125;bool cmp_e(student a, student b) &#123; return a.e &gt; b.e;&#125;int A[1000000], C[1000000], M[1000000], E[1000000];bool isin[1000000];int main() &#123; int n, m, num, c1, m1, e1; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num &gt;&gt; c1 &gt;&gt; m1 &gt;&gt; e1; double a1 = (c1 + m1 + e1) / 3.0; nums[i] = student(num, c1, m1, e1, a1); isin[num] = true; &#125; int idx = 1; sort(nums, nums + 2000, cmp_a); A[nums[0].num] = idx; for (int i = 1; i &lt; n; i++) &#123; if (nums[i].a == nums[i - 1].a) &#123; A[nums[i].num] = idx; &#125; else &#123; A[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; idx = 1; sort(nums, nums + 2000, cmp_c); C[nums[0].num] = idx; for (int i = 1; i &lt; n; i++) &#123; if (nums[i].c == nums[i - 1].c) &#123; C[nums[i].num] = idx; &#125; else &#123; C[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; idx = 1; sort(nums, nums + 2000, cmp_m); M[nums[0].num] = idx; for (int i = 1; i &lt; n; i++) &#123; if (nums[i].m == nums[i - 1].m) &#123; M[nums[i].num] = idx; &#125; else &#123; M[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; idx = 1; sort(nums, nums + 2000, cmp_e); E[nums[0].num] = idx; for (int i = 0; i &lt; n; i++) &#123; if (nums[i].e == nums[i - 1].e) &#123; E[nums[i].num] = idx; &#125; else &#123; E[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num; if (isin[num]) &#123; int res_rank = n, res_sub; if (res_rank &gt; A[num]) &#123; res_rank = A[num]; res_sub = &#x27;A&#x27;; &#125; if (res_rank &gt; C[num]) &#123; res_rank = C[num]; res_sub = &#x27;C&#x27;; &#125; if (res_rank &gt; M[num]) &#123; res_rank = M[num]; res_sub = &#x27;M&#x27;; &#125; if (res_rank &gt; E[num]) &#123; res_rank = E[num]; res_sub = &#x27;E&#x27;; &#125; printf(&quot;%d %c &quot;, res_rank, res_sub); &#125; else &#123; cout &lt;&lt; &quot;N/A&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int id, best; int score[4], rank[4];&#125; stu[2001];int hashtable[1000000], flag;bool cmp(node a, node b) &#123; return a.score[flag] &gt; b.score[flag];&#125;int main() &#123; int n, m, id; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].id &gt;&gt; stu[i].score[1] &gt;&gt; stu[i].score[2] &gt;&gt; stu[i].score[3]; stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5; &#125; for (flag = 0; flag &lt;= 3; flag++) &#123; sort(stu, stu + n, cmp); stu[0].rank[flag] = 1; for (int i = 1; i &lt; n; i++) &#123; stu[i].rank[flag] = i + 1; if (stu[i].score[flag] == stu[i - 1].score[flag]) stu[i].rank[flag] = stu[i - 1].rank[flag]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; hashtable[stu[i].id] = i + 1; stu[i].best = 0; int minn = stu[i].rank[0]; for (int j = 1; j &lt;= 3; j++) &#123; if (stu[i].rank[j] &lt; minn) &#123; minn = stu[i].rank[j]; stu[i].best = j; &#125; &#125; &#125; char c[5] = &#123;&quot;ACME&quot;&#125;; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id; if (hashtable[id]) &#123; int best = stu[hashtable[id] - 1].best; printf(&quot;%d %c &quot;, stu[hashtable[id] - 1].rank[best], c[best]); &#125; else &#123; cout &lt;&lt; &quot;N/A &quot;; &#125; &#125; return 0;&#125; 1013 Battle Over Citieså¹¶æŸ¥é›† 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 1001;int g[N][N], fa[N];int find(int x) &#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;int main() &#123; int n, m, k, u, v, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u][v] = g[v][u] = 1; &#125; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; x; for (int j = 1; j &lt;= n; j++) &#123; fa[j] = j; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int k = j + 1; k &lt;= n; k++) &#123; if (j == x || k == x) continue; if (g[j][k] == 1 &amp;&amp; find(j) != find(k)) &#123; fa[find(j)] = find(k); &#125; &#125; &#125; set&lt;int&gt; res; for (int j = 1; j &lt;= n; j++) &#123; res.insert(find(j)); &#125; cout &lt;&lt; res.size() - 2 &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ï¼ˆdfsï¼‰ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 1001;int g[N][N], n;bool visit[N];void dfs(int x) &#123; visit[x] = true; for (int i = 1; i &lt;= n; i++) &#123; if (g[i][x] &amp;&amp; !visit[i]) &#123; dfs(i); &#125; &#125;&#125;int main() &#123; int m, k, u, v, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u][v] = g[v][u] = 1; &#125; for (int i = 0; i &lt; k; i++) &#123; fill(visit, visit + N, false); cin &gt;&gt; x; visit[x] = true; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) &#123; dfs(i); cnt++; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl; &#125; return 0;&#125; 1014 Waiting in Lineå¤§æ¨¡æ‹Ÿï¼ˆqueueï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int poptime, endtime; queue&lt;int&gt; q;&#125;;int main() &#123; int n, m, k, q, idx = 1; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q; vector&lt;int&gt; time(k + 1), res(k + 1); for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; time[i]; &#125; vector&lt;node&gt; win(n + 1); vector&lt;bool&gt; sorry(k + 1, false); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (idx &lt;= k) &#123; win[j].q.push(time[idx]); if (win[j].endtime &gt;= 540) sorry[idx] = true; win[j].endtime += time[idx]; if (i == 1) win[j].poptime = win[j].endtime; res[idx] = win[j].endtime; idx++; &#125; &#125; &#125; while (idx &lt;= k) &#123; int tmin = win[1].poptime, twin = 1; for (int i = 2; i &lt;= n; i++) &#123; if (win[i].poptime &lt; tmin) &#123; twin = i; tmin = win[i].poptime; &#125; &#125; win[twin].q.pop(); win[twin].q.push(time[idx]); win[twin].poptime += win[twin].q.front(); if (win[twin].endtime &gt;= 540) sorry[idx] = true; win[twin].endtime += time[idx]; res[idx] = win[twin].endtime; idx++; &#125; for (int i = 1; i &lt;= q; i++) &#123; int query, minute; cin &gt;&gt; query; minute = res[query]; if (sorry[query]) cout &lt;&lt; &quot;Sorry&quot; &lt;&lt; endl; else printf(&quot;%02d:%02d &quot;, (minute + 480) / 60, minute % 60); &#125; return 0;&#125; 1015 Reversible Primes12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;const int N = 100001;bool st[N];int convert1(string s, int k) &#123; int sum = 0, idx = 0; for (int i = s.size() - 1; i &gt;= 0; i--) &#123; sum += (s[i] - &#x27;0&#x27;) * pow(k, idx++); &#125; return sum;&#125;string convert2(int n, int k) &#123; string res; while (n) &#123; res.push_back(n % k + &#x27;0&#x27;); n /= k; &#125; return res;&#125;int main() &#123; for (int i = 2; i &lt; N; i++) &#123; if (!st[i]) &#123; for (int j = i + i; j &lt; N; j += i) &#123; st[j] = true; &#125; &#125; &#125; st[0] = st[1] = true; int a, b; while (cin &gt;&gt; a) &#123; if (a &lt; 0) break; cin &gt;&gt; b; int t = convert1(convert2(a, b), b); if (!st[t] &amp;&amp; !st[a]) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isprime(int n) &#123; if (n &lt;= 1) return false; for (int i = 2; i &lt;= int(sqrt(n * 1.0)); i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int a, b; while (cin &gt;&gt; a) &#123; if (a &lt; 0) break; cin &gt;&gt; b; if (!isprime(a)) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; continue; &#125; int len = 0, arr[100]; do &#123; arr[len++] = a % b; a /= b; &#125; while(a != 0); for (int i = 0; i &lt; len; i++) a = a * b + arr[i]; if (isprime(a)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1016 Phone Billså¤§æ¨¡æ‹Ÿ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string time, tag; node (string _time, string _tag) &#123; time = _time, tag = _tag; &#125;&#125;;map&lt;string, vector&lt;node&gt;&gt; mp;bool cmp(node a, node b) &#123; return a.time &lt; b.time;&#125;int price[25] = &#123;0&#125;, n;double count2(string time) &#123; int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = price[hour] * min + price[24] * 60 * day; for (int i = 0; i &lt; hour; i++) &#123; res += price[i] * 60; &#125; return res / 100.0;&#125;int count1(string time) &#123; int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = day * 24 * 60 + hour * 60 + min; return res;&#125;int main() &#123; for (int i = 0; i &lt; 24; i++) &#123; cin &gt;&gt; price[i]; price[24] += price[i]; &#125; cin &gt;&gt; n; string name, time, tag, month; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; time &gt;&gt; tag; month = time.substr(0, 2); mp[name].push_back(node(time.substr(3, 8), tag)); &#125; for (auto i = mp.begin(); i != mp.end(); i++) &#123; vector&lt;node&gt; nodes = i-&gt;second; sort(nodes.begin(), nodes.end(), cmp); double money = 0; int idx = 0, minute; string start, end; vector&lt;string&gt; times; for (int i = 0; i &lt; nodes.size() - 1; i++) &#123; if (nodes[i].tag == &quot;on-line&quot; &amp;&amp; nodes[i + 1].tag == &quot;off-line&quot;) &#123; times.push_back(nodes[i].time); times.push_back(nodes[i + 1].time); &#125; &#125; if (times.size() &gt; 0) &#123; cout &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; month &lt;&lt; endl; for (int i = 0; i &lt; times.size(); i += 2) &#123; string start = times[i], end = times[i + 1]; minute = count1(end) - count1(start); double t = count2(end) - count2(start); money += t; printf(&quot;%s %s %d $%.2f &quot;, start.c_str(), end.c_str(), minute, t); &#125; printf(&quot;Total amount: $%.2f &quot;, money); &#125; &#125; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int status, month, time, day, hour, minute;&#125;;bool cmp(node a, node b) &#123; return a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;&#125;int rate[25], n;double count(node a) &#123; double res = rate[a.hour] * a.minute + rate[24] * 60 * a.day; for (int i = 0; i &lt; a.hour; i++) &#123; res += rate[i] * 60; &#125; return res / 100.0;&#125;int main() &#123; for (int i = 0; i &lt; 24; i++) &#123; cin &gt;&gt; rate[i]; rate[24] += rate[i]; &#125; cin &gt;&gt; n; vector&lt;node&gt; data(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; data[i].name; scanf(&quot;%d:%d:%d:%d&quot;, &amp;data[i].month, &amp;data[i].day, &amp;data[i].hour, &amp;data[i].minute); string tmp; cin &gt;&gt; tmp; data[i].status = (tmp == &quot;on-line&quot;) ? 1 : 0; data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute; &#125; sort(data.begin(), data.end(), cmp); map&lt;string, vector&lt;node&gt; &gt; custom; for (int i = 1; i &lt; n; i++) &#123; if (data[i].name == data[i - 1].name &amp;&amp; data[i - 1].status == 1 &amp;&amp; data[i].status == 0) &#123; custom[data[i - 1].name].push_back(data[i - 1]); custom[data[i].name].push_back(data[i]); &#125; &#125; for (auto it: custom) &#123; vector&lt;node&gt; tmp = it.second; printf(&quot;%s %02d &quot;, it.first.c_str(), tmp[0].month); double res = 0; for (int i = 1; i &lt; tmp.size(); i += 2) &#123; double t = count(tmp[i]) - count(tmp[i - 1]); printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2f &quot;, tmp[i - 1].day, tmp[i - 1].hour, tmp[i - 1].minute, tmp[i].day, tmp[i].hour, tmp[i].minute, tmp[i].time - tmp[i - 1].time, t); res += t; &#125; printf(&quot;Total amount: $%.2f &quot;, res); &#125; return 0;&#125; 1017 Queueing at Bank1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int main() &#123; int n, k, p, hour, minute, second, idx = 0, res = 0; cin &gt;&gt; n &gt;&gt; k; vector&lt;PII&gt; nums; vector&lt;int&gt; v(k); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d:%d:%d %d&quot;, &amp;hour, &amp;minute, &amp;second, &amp;p); int t = hour * 3600 + minute * 60 + second; if (t &gt; 61200) continue; nums.push_back(&#123;t, p * 60&#125;); &#125; sort(nums.begin(), nums.end()); n = nums.size(); for (int j = 0; j &lt; min(n, k); j++) &#123; if (nums[idx].first &lt; 28800) &#123; v[j] = 28800; res += 28800 - nums[idx].first; &#125; else &#123; v[j] = nums[idx].first; &#125; v[j] += nums[idx].second; idx++; &#125; while (idx &lt; n) &#123; int tmin = v[0], twin = 0; for (int i = 1; i &lt; k; i++) &#123; if (tmin &gt; v[i]) &#123; tmin = v[i]; twin = i; &#125; &#125; if (v[twin] &gt; nums[idx].first) &#123; res += v[twin] - nums[idx].first; &#125; else &#123; v[twin] = nums[idx].first; &#125; v[twin] += nums[idx].second; idx++; &#125; printf(&quot;%.1f&quot;, res / 60.0 / n); return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10005;struct person &#123; int come, time;&#125; p[maxn];int cmp(person p1, person p2) &#123; return p1.come &lt; p2.come;&#125;int n, k, cnt, total;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; int hh, ss, mm, tt; scanf(&quot;%d:%d:%d %d&quot;, &amp;hh, &amp;mm, &amp;ss, &amp;tt); int sum = hh * 3600 + mm * 60 + ss; if (sum &gt; 61200) continue; p[++cnt].time = tt * 60; p[cnt].come = sum; &#125; sort(p + 1, p + 1 + cnt, cmp); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for (int i = 1; i &lt;= k; i++) q.push(28800); for (int i = 1; i &lt;= cnt; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; if (q.top() &lt;= p[i].come) &#123; q.push(p[i].come + p[i].time); &#125; else &#123; total += q.top() - p[i].come; q.push(q.top() + p[i].time); &#125; q.pop(); &#125; if (!cnt) cout &lt;&lt; &quot;0.0&quot; &lt;&lt; endl; else printf(&quot;%.1f&quot;, total / 60.0 / cnt); return 0;&#125; 1018 Public Bike Managementdijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 501;const int INF = 0x3f3f3f3f;bool visit[N];int d[N], weight[N], n, minNeed = INF, minBack = INF;vector&lt;PII&gt; g[N];vector&lt;int&gt; pre[N], path, tmppath;void dijkstra(int x) &#123; fill(d, d + N, INF); d[x] = 0; for (int i = 0; i &lt;= n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt;= n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; mind = d[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) &#123; if (d[u] + dis &lt; d[v]) &#123; d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[u] + dis == d[v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; tmppath.push_back(v); if (v == 0) &#123; int need = 0, back = 0; for (int i = tmppath.size() - 1; i &gt;= 0; i--) &#123; int idx = tmppath[i]; if (weight[idx] &gt; 0) &#123; back += weight[idx]; &#125; else &#123; if (back &gt; -weight[idx]) &#123; back += weight[idx]; &#125; else &#123; need += (-weight[idx] - back); back = 0; &#125; &#125; &#125; if (need &lt; minNeed) &#123; minNeed = need; minBack = back; path = tmppath; &#125; else if (need == minNeed &amp;&amp; back &lt; minBack) &#123; minBack = back; path = tmppath; &#125; tmppath.pop_back(); return; &#125; for (int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v][i]); tmppath.pop_back();&#125;int main() &#123; int c, s, m, u, v, w; cin &gt;&gt; c &gt;&gt; n &gt;&gt; s &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; weight[i] = weight[i] - c / 2; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(&#123;v, w&#125;); g[v].push_back(&#123;u, w&#125;); &#125; dijkstra(0); dfs(s); cout &lt;&lt; minNeed &lt;&lt; &quot; 0&quot;; for (int i = path.size() - 2; i &gt;= 0; i--) &#123; cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; path[i]; &#125; cout &lt;&lt; &quot; &quot; &lt;&lt; minBack; return 0;&#125; 1019 General Palindromic Number1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; str; while (n) &#123; str.push_back(n % k); n /= k; &#125; vector&lt;int&gt; str2(str.rbegin(), str.rend()); if (str == str2) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; for (int i = 0; i &lt; str2.size(); i++) &#123; cout &lt;&lt; str2[i]; if (i &lt; str2.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1020 Tree Traversals1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 31;int post[N], in[N];struct node &#123; int l, r;&#125; trees[N];int build(int postl, int postr, int inl, int inr) &#123; if (postl &gt; postr) return -1; int root = post[postr], idx; for (int i = inl; i &lt;= inr; i++) &#123; if (root == in[i]) &#123; idx = i; break; &#125; &#125; int cntl = idx - inl; trees[root].l = build(postl, postl + cntl - 1, inl, idx - 1); trees[root].r = build(postl + cntl, postr - 1, idx + 1, inr); return root;&#125;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; u = q.front(); q.pop(); cout &lt;&lt; u; if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); if (!q.empty()) cout &lt;&lt; &quot; &quot;; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; post[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; int root = build(0, n - 1, 0, n - 1); bfs(root); return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int N = 31;int post[N], in[N];map&lt;int, int&gt; level;void pre(int root, int start, int end, int idx) &#123; if (start &gt; end) return; int i = start; while (i &lt; end &amp;&amp; in[i] != post[root]) i++; level[idx] = post[root]; pre(root - 1 - end + i, start, i - 1, 2 * idx + 1); pre(root - 1, i + 1, end, 2 * idx + 2);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; post[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; pre(n - 1, 0, n - 1, 0); for (auto i = level.begin(); i != level.end(); i++) &#123; cout &lt;&lt; i-&gt;second; if (next(i) != level.end()) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1021 Deepest Root123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int n, maxh = 0;vector&lt;int&gt; g[10010], tmp;bool visit[10010];set&lt;int&gt; s;void dfs(int node, int height) &#123; if (maxh &lt; height) &#123; maxh = height; tmp.clear(); tmp.push_back(node); &#125; else if (maxh == height) &#123; tmp.push_back(node); &#125; visit[node] = true; for (int i = 0; i &lt; g[node].size(); i++) &#123; if (!visit[g[node][i]]) &#123; dfs(g[node][i], height + 1); &#125; &#125;&#125;int main() &#123; int n, u, v, cnt = 0, s1 = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) &#123; dfs(i, 1); if (i == 1) &#123; if (!tmp.empty()) s1 = tmp[0]; for (int j = 0; j &lt; tmp.size(); j++) &#123; s.insert(tmp[j]); &#125; &#125; cnt++; &#125; &#125; if (cnt &gt; 1) cout &lt;&lt; &quot;Error: &quot; &lt;&lt; cnt &lt;&lt; &quot; components&quot;; else &#123; tmp.clear(); fill(visit, visit + 10010, false); maxh = 0; dfs(s1, 1); for (int i = 0; i &lt; tmp.size(); i++) s.insert(tmp[i]); for (auto it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; &#125; return 0;&#125; 1022 Digital Library12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct book &#123; string num, title, auther, publisher, year; vector&lt;string&gt; keys;&#125; books[10001];bool cmp(book a, book b) &#123; return a.num &lt; b.num;&#125;int main() &#123; int n, m, q; string key, query; scanf(&quot;%d &quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; getline(cin, books[i].num); getline(cin, books[i].title); getline(cin, books[i].auther); while (cin &gt;&gt; key) &#123; books[i].keys.push_back(key); char c = getchar(); if (c == &#x27; &#x27;) break; &#125; getline(cin, books[i].publisher); getline(cin, books[i].year); &#125; sort(books, books + n, cmp); cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; bool flag = false; scanf(&quot;%d: &quot;, &amp;q); getline(cin, query); cout &lt;&lt; q &lt;&lt; &quot;: &quot; &lt;&lt; query &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; if (q == 1 &amp;&amp; books[i].title == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; else if (q == 2 &amp;&amp; books[i].auther == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; else if (q == 3) &#123; for (int j = 0; j &lt; books[i].keys.size(); j++) &#123; if (query == books[i].keys[j]) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; &#125; &#125; else if (q == 4 &amp;&amp; books[i].publisher == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; else if (q == 5 &amp;&amp; books[i].year == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; &#125; if (!flag) cout &lt;&lt; &quot;Not Found&quot; &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt; &gt; title, author, key, pub, year;void query(map&lt;string, set&lt;int&gt; &gt; &amp;m, string &amp;str) &#123; if(m.find(str) != m.end()) &#123; for(auto it = m[str].begin(); it != m[str].end(); it++) printf(&quot;%07d &quot;, *it); &#125; else cout &lt;&lt; &quot;Not Found &quot;;&#125;int main() &#123; int n, m, id, num; scanf(&quot;%d&quot;, &amp;n); string ttitle, tauthor, tkey, tpub, tyear; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d &quot;, &amp;id); getline(cin, ttitle); title[ttitle].insert(id); getline(cin, tauthor); author[tauthor].insert(id); while(cin &gt;&gt; tkey) &#123; key[tkey].insert(id); char c = getchar(); if(c == &#x27; &#x27;) break; &#125; getline(cin, tpub); pub[tpub].insert(id); getline(cin, tyear); year[tyear].insert(id); &#125; scanf(&quot;%d&quot;, &amp;m); for(int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d: &quot;, &amp;num); string temp; getline(cin, temp); cout &lt;&lt; num &lt;&lt; &quot;: &quot; &lt;&lt; temp &lt;&lt; &quot; &quot;; if(num == 1) query(title, temp); else if(num == 2) query(author, temp); else if(num == 3) query(key, temp); else if(num == 4) query(pub,temp); else if(num ==5) query(year, temp); &#125; return 0;&#125; 1023 Have Fun with Numbers12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int nums[10];int main() &#123; string a, b = &quot;&quot;; cin &gt;&gt; a; int t = 0; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; b += ((a[i] - &#x27;0&#x27;) * 2 + t) % 10 + &#x27;0&#x27;; t = ((a[i] - &#x27;0&#x27;) * 2 + t) / 10; &#125; if (t) b += t + &#x27;0&#x27;; reverse(b.begin(), b.end()); for (int i = 0; i &lt; a.size(); i++) &#123; nums[a[i]]++; &#125; bool flag = true; for (int i = 0; i &lt; b.size(); i++) &#123; nums[b[i]]--; if (nums[b[i]] &lt; 0) &#123; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; cout &lt;&lt; b; return 0;&#125; 1024 Palindromic Number123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string add(string a) &#123; string b(a.rbegin(), a.rend()), c = &quot;&quot;; int t = 0; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; int sum = a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t; c += sum % 10 + &#x27;0&#x27;; t = sum / 10; &#125; if (t) c += t + &#x27;0&#x27;; reverse(c.begin(), c.end()); return c;&#125;bool ispal(string a) &#123; string b(a.rbegin(), a.rend()); return a == b;&#125;int main() &#123; string n; int k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; if (ispal(n)) &#123; cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; i; return 0; &#125; n = add(n); &#125; cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; k; return 0;&#125; 1025 PAT Ranking1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node1 &#123; string num; int score, locnum, locrank;&#125;;bool cmp1(node1 &amp;a, node1 &amp;b) &#123; if (a.score == b.score) &#123; return a.num &lt; b.num; &#125; else &#123; return a.score &gt; b.score; &#125;&#125;int main() &#123; int n, k, score; string num; vector&lt;node1&gt; nums; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k; vector&lt;node1&gt; tmp(k); for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; tmp[j].num &gt;&gt; tmp[j].score; tmp[j].locnum = i; &#125; sort(tmp.begin(), tmp.end(), cmp1); tmp[0].locrank = 1; nums.push_back(tmp[0]); for (int j = 1; j &lt; k; j++) &#123; if (tmp[j].score != tmp[j - 1].score) tmp[j].locrank = j + 1; else tmp[j].locrank = tmp[j - 1].locrank; nums.push_back(tmp[j]); &#125; &#125; sort(nums.begin(), nums.end(), cmp1); int rank = 1; cout &lt;&lt; nums.size() &lt;&lt; endl; cout &lt;&lt; nums[0].num &lt;&lt; &quot; &quot; &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; nums[0].locnum &lt;&lt; &quot; &quot; &lt;&lt; nums[0].locrank &lt;&lt; endl; for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[i].score != nums[i - 1].score) rank = i + 1; cout &lt;&lt; nums[i].num &lt;&lt; &quot; &quot; &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; nums[i].locnum &lt;&lt; &quot; &quot; &lt;&lt; nums[i].locrank &lt;&lt; endl; &#125; return 0;&#125; 1026 Table Tennisæœ€æ¶å¿ƒçš„å¤§æ¨¡æ‹Ÿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef long long ll;struct table &#123; int endtime, num; bool vip;&#125;;struct play &#123; int arrive, use, start; // åˆ°è¾¾æ—¶é—´ï¼Œä½¿ç”¨æ—¶é—´ï¼Œå¼€å§‹æ—¶é—´ bool served, vip; // æ˜¯å¦æœåŠ¡ï¼Œvip?&#125;;int cmp1(play a, play b) &#123; return a.arrive &lt; b.arrive; // å…ˆå¯¹æ•°æ®è¿›è¡Œæ’åºï¼ŒæŒ‰åˆ°è¾¾çš„æ—¶é—´å‡åº&#125;int cmp2(play a, play b) &#123; return a.start &lt; b.start; // æœ€åè¾“å‡ºçš„æ—¶å€™ä¸ºä»€ä¹ˆæ˜¯8:12:00åœ¨8:10:00çš„å‰é¢å‘¢ï¼Ÿå°±æ˜¯å› ä¸ºæ˜¯æŒ‰å¼€å§‹ä½¿ç”¨çš„æ—¶é—´å‡åºçš„&#125;vector&lt;play&gt; p;vector&lt;table&gt; t;// æ‰¾åˆ°personidåŠä¹‹åçš„ï¼Œå¹¶ä¸”åˆ°è¾¾ï¼ˆarriveï¼‰æ—¶é—´ä¸æ™šäºbeforeçš„ï¼ŒæœªæœåŠ¡çš„ï¼Œä¸”ä¸ºvipçš„ person-id. å¦‚æœæ²¡æ‰¾åˆ°,åˆ™è¿”å›-1int findvip(int personId, int minendtime) &#123; for (int i = personId; i &lt; p.size() &amp;&amp; p[i].arrive &lt;= minendtime; i++) &#123; if (!p[i].served &amp;&amp; p[i].vip) return i; &#125; return -1;&#125;// æ›´æ–°ä»¥personIdçš„ç©å®¶å¯¹ï¼Œå’ŒtableIdçš„æ¡Œå­çš„ä¿¡æ¯// 1ã€å°†è¯¥ç©å®¶å¯¹çš„å¼€å§‹æ—¶é—´èµ‹å€¼ä¸ºåˆ°è¾¾æ—¶é—´å’Œå¯ç”¨æ¡Œå­ç»“æŸæ—¶é—´ä¸­çš„è¾ƒå¤§å€¼// 2ã€å°†è¯¥ç©å®¶å¯¹çš„æœåŠ¡çŠ¶æ€èµ‹å€¼ä¸ºä»¥æœåŠ¡è¿‡// 3ã€å°†æ¡Œå­çš„ç»“æŸæ—¶é—´ä¿¡æ¯æ›´æ–°ä¸ºè¯¥ç©å®¶å¯¹çš„å¼€å§‹æ—¶é—´åŠ è¯¥ç©å®¶çš„ä½¿ç”¨æ—¶é—´// 4ã€å°†è¯¥æ¡Œå­æœåŠ¡çš„ç©å®¶æ•°é‡åŠ ä¸€void update(int personid, int tableid) &#123; p[personid].start = max(p[personid].arrive, t[tableid].endtime); p[personid].served = 1; t[tableid].endtime = p[personid].start + p[personid].use; t[tableid].num++;&#125;int main() &#123; int n, m, k, vipnum; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int h, m, s, use, vip, arrive; scanf(&quot;%d:%d:%d %d %d&quot;, &amp;h, &amp;m, &amp;s, &amp;use, &amp;vip); arrive = h * 3600 + m * 60 + s; use = use &gt; 120 ? 7200 : use * 60; p.push_back(&#123;arrive, use, 0, 0, vip &gt; 0&#125;); &#125; sort(p.begin(), p.end(), cmp1); scanf(&quot;%d %d&quot;, &amp;k, &amp;m); for (int i = 0; i &lt; k; i++) t.push_back(&#123;28800, 0, 0&#125;); for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;vipnum); t[vipnum - 1].vip = 1; &#125; for (int i = 0; i &lt; p.size();) &#123; // æ‰¾åˆ°æœ€å…ˆç©ºé—²çš„æ¡Œå­,å¦‚æœå¤šä¸ªæ¡Œå­åŒæ—¶ç©ºé—²ï¼Œåˆ™è¿”å›æ¡Œå­å·æœ€å°çš„é‚£ä¸ª int minendtime = INF, minendid; for (int j = 0; j &lt; k; j++) &#123; if (minendtime &gt; t[j].endtime) &#123; minendtime = t[j].endtime; minendid = j; &#125; &#125; // å¦‚æœæœ€å…ˆç©ºé—²çš„æ¡Œå­ç©ºé—²çš„å¤ªæ™šäº†ï¼Œæˆ–è€…å½“å‰åºåˆ—ä¸­çš„ç¬¬ä¸€ä½ç©å®¶å¯¹è¾¾åˆ°çš„æ—¶é—´å¤ªæ™šäº†ï¼Œå°±é€€å‡ºå¾ªç¯ if (minendtime &gt;= 75600 || p[i].arrive &gt;= 75600) break; // å£°æ˜æ–°çš„å˜é‡ï¼ŒpersonIdä¸ºç»è¿‡è°ƒæ•´é€‰æ‹©åæœ€ç»ˆçš„å¼€å§‹ä½¿ç”¨æ¡Œå­çš„ç©å®¶å¯¹ç´¢å¼•ï¼ŒtableIdä¸ºä¸ºç»è¿‡è°ƒæ•´é€‰æ‹©åæœ€ç»ˆçš„å¼€å§‹è¢«ä½¿ç”¨çš„æ¡Œå­ int personid = i, tableid = minendid; // å¦‚æœå½“å‰çš„æœ€æ—©ç©ºé—²ä¸”å·æœ€å°çš„æ¡Œå­ç©ºé—²æ—¶ï¼Œå­˜åœ¨ç©å®¶å¯¹å·²ç»åœ¨ç­‰å¾…äº† if (minendtime &gt;= p[i].arrive) &#123; // å¹¶ä¸”å½“å‰çš„æœ€æ—©ç©ºé—²ä¸”å·æœ€å°çš„æ¡Œå­æ˜¯vipï¼Œå¯»æ‰¾æ˜¯vipçš„ä¸”æœªæœåŠ¡è¿‡çš„ï¼Œç©å®¶å¯¹åˆ°è¾¾æ—¶é—´ä¸æ™šäºminEndTimeçš„ç©å®¶å¯¹ç´¢å¼• if (t[tableid].vip) &#123; int vipid = findvip(personid, minendtime); personid = vipid != -1 ? vipid : personid; &#125; else if (p[i].vip) &#123; // è™½ç„¶å½“å‰çš„æœ€æ—©ç©ºé—²ä¸”å·æœ€å°çš„æ¡Œå­ä¸æ˜¯vipï¼Œä½†æ˜¯è¿˜å¯èƒ½å­˜åœ¨åŒæ—¶ç©ºé—²ï¼Œæ¡Œå·æ›´å¤§çš„æ¡Œå­æ˜¯vip for (int j = 0; j &lt; k; j++) &#123; if (t[j].vip &amp;&amp; t[j].endtime &lt;= p[personid].arrive) &#123; tableid = j; break; &#125; &#125; &#125; // å¦‚æœå½“å‰çš„æ¡Œå­évipï¼Œä¸”å½“å‰çš„åºåˆ—çš„ç¬¬ä¸€ä¸ªç©å®¶å¯¹évipï¼Œé¡ºåºé€‰æ‹©å³å¯ï¼Œæ¢å¥è¯è¯´ï¼ŒpersonIdå’ŒtableIdæ— éœ€è°ƒæ•´ &#125; else &#123; /* å¦‚æœå½“å‰çš„æœ€æ—©ç©ºé—²çš„æ¡Œå­ç©ºé—²æ—¶ï¼Œæ²¡æœ‰ç©å®¶åœ¨ç­‰å¾…åºåˆ—ä¸­ï¼Œå³å½“ä¸€ä¸ªç©å®¶åˆ°è¾¾æ—¶ï¼Œåº”è¯¥æ˜¯è‡³å°‘æœ‰ä¸€ä¸ªæ¡Œå­æ˜¯ç©ºé—²çš„ æˆ‘ä»¬æ€»æ˜¯å¸Œæœ›é€‰æ‹©ç©ºé—²ä¸­çš„æ¡Œå­ä¸­æ¡Œå­å·æœ€å°çš„ï¼Œå¦‚æœåˆ°è¾¾äº†ä¸€ä¸ªvipç©å®¶å¯¹ï¼Œå¹¶ä¸”å­˜åœ¨ç©ºé—²çš„vipæ¡Œå­ï¼Œæˆ‘ä»¬é€‰æ‹©ç©ºé—²ä¸­çš„vipæ¡Œä¸­å·æœ€å°çš„ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ç®¡æ˜¯å¦æ˜¯vipï¼Œå…ˆå¾—åˆ°ç©ºé—²ä¸­çš„æ¡Œå­ä¸­æ¡Œå­å·æœ€å°çš„ï¼Œå¦‚æœå½“å‰åˆ°è¾¾çš„ç©å®¶å¯¹æœªvipï¼Œå¹¶ä¸”å­˜åœ¨ç©ºé—²çš„vipæ¡Œå­ï¼Œ æˆ‘ä»¬ç”¨ç©ºé—²ä¸­çš„vipæ¡Œä¸­å·æœ€å°çš„é‚£ä¸ªæ¡Œå­è¦†ç›–ä¹‹å‰å¾—åˆ°çš„tableId */ for (int j = 0; j &lt; k; j++) &#123; if (t[j].endtime &lt;= p[personid].arrive) &#123; tableid = j; break; &#125; &#125; if (p[personid].vip) &#123; for (int j = 0; j &lt; k; j++) &#123; // å°è¯•å¯»æ‰¾ç©ºé—²çš„vipæ¡Œå­å¹¶è°ƒæ•´tableIdï¼Œé¡ºåºæ‰¾åˆ°å³é€€å‡ºå¾—åˆ°çš„å°±æ˜¯å·ç æœ€å°çš„ if (t[j].vip &amp;&amp; t[j].endtime &lt;= p[personid].arrive) &#123; tableid = j; break; &#125; &#125; &#125; &#125; update(personid, tableid); while (i &lt; p.size() &amp;&amp; p[i].served) i++; &#125; sort(p.begin(), p.end(), cmp2); for (int i = 0; i &lt; p.size(); i++) &#123; if (p[i].served) &#123; int wait = p[i].start - p[i].arrive; printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d &quot;, p[i].arrive / 3600, p[i].arrive % 3600 / 60, p[i].arrive % 60, p[i].start / 3600, p[i].start % 3600 / 60, p[i].start % 60, (int)(1.0 * wait / 60 + 0.5)); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; if (i != 0) printf(&quot; &quot;); printf(&quot;%d&quot;, t[i].num); &#125; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int n, m, k, H, M, S, t, table, vtable, cnt, now, nowt, T[100000], V[100000], num[10001], AnsI[10001], AnsO[10001], vip[10001];map&lt;int, int&gt; Table;queue&lt;int&gt; Wait, vWait;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d:%d:%d&quot;, &amp;H, &amp;M, &amp;S); t = H * 3600 + M * 60 + S; scanf(&quot;%d %d&quot;, &amp;T[t], &amp;V[t]); T[t] = min(T[t], 120) * 60; &#125; scanf(&quot;%d %d&quot;, &amp;m, &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;t); vip[t] = 1; &#125; for (int Time = 28800; Time &lt; 75600; Time++, table = vtable = now = 0) &#123; if (T[Time] &amp;&amp; V[Time]) vWait.push(Time); else if (T[Time]) Wait.push(Time); for (int i = 1; i &lt;= m; i++) &#123; if (Table[i] &gt; 0) Table[i]--; if (Table[i] == 0 &amp;&amp; vip[i] &amp;&amp; vtable == 0) vtable = i; if (Table [i] == 0 &amp;&amp; table == 0) table = i; &#125; if (!vWait.empty() &amp;&amp; (table || vtable)) &#123; now = vWait.front(); nowt = vtable; if (vtable != 0) vWait.pop(); else &#123; nowt = table; if (!Wait.empty() &amp;&amp; Wait.front() &lt; vWait.front()) &#123; now = Wait.front(); Wait.pop(); &#125; else vWait.pop(); &#125; &#125; else if (!Wait.empty() &amp;&amp; (table || vtable)) &#123; if (table != 0) nowt = table; else nowt = vtable; now = Wait.front(); Wait.pop(); &#125; if (now == 0) continue; Table[nowt] = T[now]; AnsI[cnt] = now; AnsO[cnt++] = Time; num[nowt]++; &#125; for (int i = 0; i &lt; cnt; i++) printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d &quot;, AnsI[i] / 3600, AnsI[i] % 3600 / 60, AnsI[i] % 60, AnsO[i] / 3600, AnsO[i] % 3600 / 60, AnsO[i] % 60, (AnsO[i] - AnsI[i] + 30) / 60); for (int i = 1; i &lt;= m; i++) &#123; if (i != 1) printf(&quot; &quot;); printf(&quot;%d&quot;, num[i]); &#125; return 0;&#125; 1027 Colors in Mars123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string convert(int n) &#123; string res = &quot;&quot;; while (n) &#123; if (n % 13 &gt; 9) res += n % 13 + &#x27;A&#x27; - 10; else res += n % 13 + &#x27;0&#x27;; n /= 13; &#125; while (res.size() &lt; 2) res += &#x27;0&#x27;; reverse(res.begin(), res.end()); return res;&#125;int main() &#123; int red, green, blue; cin &gt;&gt; red &gt;&gt; green &gt;&gt; blue; cout &lt;&lt; &quot;#&quot; &lt;&lt; convert(red) &lt;&lt; convert(green) &lt;&lt; convert(blue); return 0;&#125; æŸ³å©¼çš„ 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; char c[14] = &#123;&quot;0123456789ABC&quot;&#125;; cout &lt;&lt; &quot;#&quot;; for (int i = 0; i &lt; 3; i++) &#123; int num; cin &gt;&gt; num; cout &lt;&lt; c[num / 13] &lt;&lt; c[num % 13]; &#125; return 0;&#125; 1028 List Sorting1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct node &#123; string num, name; int score;&#125; nums[100001];bool cmp1 (node a, node b) &#123; return a.num &lt; b.num;&#125;bool cmp2 (node a, node b) &#123; if (a.name == b.name) return a.num &lt; b.num; else return a.name &lt; b.name;&#125;bool cmp3 (node a, node b) &#123; if (a.score == b.score) return a.num &lt; b.num; else return a.score &lt; b.score;&#125;int main() &#123; int n, c, score; string num, name; cin &gt;&gt; n &gt;&gt; c; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].num &gt;&gt; nums[i].name &gt;&gt; nums[i].score; &#125; if (c == 1) &#123; sort(nums, nums + n, cmp1); &#125; else if (c == 2) &#123; sort(nums, nums + n, cmp2); &#125; else if (c == 3) &#123; sort(nums, nums + n, cmp3); &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i].num &lt;&lt; &quot; &quot; &lt;&lt; nums[i].name &lt;&lt; &quot; &quot; &lt;&lt; nums[i].score &lt;&lt; endl; &#125;&#125; 1029 Median12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;vector&lt;LL&gt; nums;int main() &#123; LL n, x; scanf(&quot;%lld&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot; %lld&quot;, &amp;x); nums.push_back(x); &#125; scanf(&quot;%lld&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot; %lld&quot;, &amp;x); nums.push_back(x); &#125; sort(nums.begin(), nums.end()); cout &lt;&lt; nums[(nums.size() - 1) / 2]; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 200005;int n, m, a1[N], a2[N];int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a1[i]); &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d&quot;, &amp;a2[i]); &#125; int target = (n + m + 1) / 2; int i = 1, j = 1, cnt = 0, res; while (i &lt;= n &amp;&amp; j &lt;= m) &#123; res = a1[i] &lt;= a2[j] ? a1[i++] : a2[j++]; if (++cnt == target) break; &#125; if (i &lt;= n &amp;&amp; cnt &lt; target) res = a1[i + target - cnt - 1]; else if (j &lt;= m &amp;&amp; cnt &lt; target) res = a2[j + target - cnt - 1]; cout &lt;&lt; res; return 0;&#125; 1030 Travel Plandijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node &#123; int v, dis; node (int _v, int _dis) &#123; v = _v, dis = _dis; &#125;&#125;;vector&lt;node&gt; g[N];vector&lt;int&gt; pre[N];int n, s, d[N], cost[N][N], mincost = INF;bool visit[N];void dijkstra(int s) &#123; fill(d, d + N, INF); d[s] = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; u = j; mind = d[j]; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].v; int dis = g[u][j].dis; if (!visit[v]) &#123; if (d[u] + dis &lt; d[v]) &#123; d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); &#125; else if (d[u] + dis == d[v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; tmp, res;void dfs(int t) &#123; tmp.push_back(t); if (s == t) &#123; int minc = 0; for (int i = 0; i &lt; tmp.size() - 1; i++) &#123; int id = tmp[i], nexti = tmp[i + 1]; minc += cost[id][nexti]; &#125; if (minc &lt; mincost) &#123; mincost = minc; res = tmp; &#125; tmp.pop_back(); return; &#125; for (int i = 0; i &lt; pre[t].size(); i++) &#123; dfs(pre[t][i]); &#125; tmp.pop_back();&#125;int main() &#123; int m, t, u, v, w, c; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c; cost[u][v] = cost[v][u] = c; g[u].push_back(node(v, w)); g[v].push_back(node(u, w)); &#125; dijkstra(s); dfs(t); for (int i = res.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; d[t] &lt;&lt; &quot; &quot; &lt;&lt; mincost; return 0;&#125; 1031 Hello World for U123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int len = str.size() + 2; int n = len / 3; int n2 = len - n * 3 + n - 2; for (int i = 0; i &lt; n - 1; i++) &#123; cout &lt;&lt; str[i]; for (int j = 0; j &lt; n2; j++) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; str[str.size() - 1 - i] &lt;&lt; endl; &#125; for (int i = n - 1; i &lt; n + n2 + 1; i++) &#123; cout &lt;&lt; str[i]; &#125; return 0;&#125; 1032 Sharing12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;const int N = 100001;struct node &#123; int next; char data; bool flag;&#125; nodes[N];int main() &#123; int s1, s2, n, add, next; char data; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; data &gt;&gt; next; nodes[add] = &#123;next, data, false&#125;; &#125; for (int i = s1; i != -1; i = nodes[i].next) &#123; nodes[i].flag = true; &#125; for (int i = s2; i != -1; i = nodes[i].next) &#123; if (nodes[i].flag) &#123; printf(&quot;%05d&quot;, i); return 0; &#125; &#125; cout &lt;&lt; -1; return 0;&#125; 1033 To Fill or Not to Fillé”™è¯¯ç­”æ¡ˆï¼ˆæ²¡æœ‰è€ƒè™‘åˆ°æ²¹ç®±ä¸Šé™ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;double, double&gt; PII;vector&lt;PII&gt; sites;int main() &#123; double c_max, d_max, d_avg, n,price, dis; cin &gt;&gt; c_max &gt;&gt; d_max &gt;&gt; d_avg &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; price &gt;&gt; dis; if (dis &gt;= d_max) continue; sites.push_back(&#123;dis, price&#125;); &#125; sort(sites.begin(), sites.end()); int cur_site = 0; double res = 0, cur_dis = 0, diff = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q; if (sites[0].first != 0) &#123; cout &lt;&lt; &quot;The maximum travel distance = 0.00&quot;; return 0; &#125; while (cur_dis &lt; d_max &amp;&amp; cur_site &lt; sites.size()) &#123; if (cur_site == sites.size() - 1) diff = d_max - cur_dis; else diff = sites[cur_site + 1].first - cur_dis; q.push(&#123;sites[cur_site++].second, c_max&#125;); while (!q.empty()) &#123; PII t = q.top(); q.pop(); if (d_avg * t.second &lt;= diff) &#123; res += t.first * t.second; diff -= d_avg * t.second; cur_dis += d_avg * t.second; &#125; else &#123; res += diff * t.first / d_avg; cur_dis += diff; q.push(&#123;t.first, t.second - diff / d_avg&#125;); diff = 0; break; &#125; &#125; if (diff &gt; 0) break; &#125; if (cur_dis == d_max) printf(&quot;%.2f&quot;, res); else printf(&quot;The maximum travel distance = %.2f&quot;, cur_dis); return 0;&#125; æŸ³å©¼çš„ï¼ˆè´ªå¿ƒï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef pair&lt;double, double&gt; PII;int main() &#123; double c_max, d_max, d_avg, n; cin &gt;&gt; c_max &gt;&gt; d_max &gt;&gt; d_avg &gt;&gt; n; vector&lt;PII&gt; sta(n + 1); sta[0] = &#123;d_max, 0&#125;; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; sta[i].second &gt;&gt; sta[i].first; &#125; sort(sta.begin(), sta.end()); double cur_dis = 0, max_dis = 0, cur_price = 0, total_price = 0, left_dis = 0; if (sta[0].first != 0) &#123; cout &lt;&lt; &quot;The maximum travel distance = 0.00&quot;; return 0; &#125; else &#123; cur_price = sta[0].second; &#125; while (cur_dis &lt; d_max) &#123; max_dis = cur_dis + c_max * d_avg; double min_price_dis = 0, min_price = INF; int flag = 0; for (int i = 1; i &lt;= n &amp;&amp; sta[i].first &lt;= max_dis; i++) &#123; if (sta[i].first &lt;= cur_dis) continue; if (sta[i].second &lt;= cur_price) &#123; total_price += (sta[i].first - cur_dis - left_dis) * cur_price / d_avg; left_dis = 0; cur_price = sta[i].second; cur_dis = sta[i].first; flag = 1; break; &#125; if (sta[i].second &lt; min_price) &#123; min_price = sta[i].second; min_price_dis = sta[i].first; &#125; &#125; if (flag == 0 &amp;&amp; min_price != INF) &#123; total_price += (cur_price * (c_max - left_dis / d_avg)); left_dis = c_max * d_avg - (min_price_dis - cur_dis); cur_price = min_price; cur_dis = min_price_dis; &#125; if (flag == 0 &amp;&amp; min_price == INF) &#123; cur_dis += c_max * d_avg; printf(&quot;The maximum travel distance = %.2f&quot;, cur_dis); return 0; &#125; &#125; printf(&quot;%.2f&quot;, total_price); return 0;&#125; 1034 Head of a Gangå¹¶æŸ¥é›†ï¼ˆå†™å¤æ‚äº†ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;string, int&gt; PII;const int N = 20000;int fa[N], sum[N], maxs[N];int find(int x) &#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;int convert1(string x) &#123; return (x[0] - &#x27;A&#x27;) * 26 * 26 + (x[1] - &#x27;A&#x27;) * 26 + x[2] - &#x27;A&#x27;;&#125;string convert2(int x) &#123; string res = &quot;&quot;; res += x / (26 * 26) + &#x27;A&#x27;; res += x % (26 * 26) / 26 + &#x27;A&#x27;; res += x % 26 + &#x27;A&#x27;; return res;&#125;set&lt;int&gt; nums;struct node &#123; int a, b, time;&#125;;vector&lt;node&gt; relations;int main() &#123; int n, k, time; cin &gt;&gt; n &gt;&gt; k; string a, b; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; time; nums.insert(convert1(a)); nums.insert(convert1(b)); relations.push_back(&#123;convert1(a), convert1(b), time&#125;); &#125; for (auto i = nums.begin(); i != nums.end(); i++) &#123; fa[*i] = *i; &#125; for (int i = 0; i &lt; relations.size(); i++) &#123; int a = relations[i].a, b = relations[i].b, time = relations[i].time; if (fa[a] != fa[b]) &#123; sum[find(b)] = max(sum[find(a)], sum[find(b)]); fa[find(a)] = find(b); &#125; sum[find(b)] += time; maxs[a] += time; maxs[b] += time; &#125; set&lt;int&gt; bangs; for (auto i = nums.begin(); i != nums.end(); i++) &#123; if (sum[find(*i)] &gt; k) bangs.insert(find(*i)); &#125; vector&lt;PII&gt; res; for (auto i = bangs.begin(); i != bangs.end(); i++) &#123; set&lt;int&gt; tmp; int m = 0, r; for (int j = 0; j &lt; relations.size(); j++) &#123; if (find(*i) == find(relations[j].a)) &#123; tmp.insert(relations[j].a); tmp.insert(relations[j].b); if (m &lt; maxs[relations[j].a]) &#123; m = maxs[relations[j].a]; r = relations[j].a; &#125; if (m &lt; maxs[relations[j].b]) &#123; m = maxs[relations[j].b]; r = relations[j].b; &#125; &#125; &#125; if (tmp.size() &gt; 2) res.push_back(&#123;convert2(r), tmp.size()&#125;); &#125; cout &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot; &quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ï¼ˆdfsï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, int&gt; stringToInt;map&lt;int, string&gt; intToString;map&lt;string, int&gt; res;int id = 1, k;int stoifun(string s) &#123; if (stringToInt[s] == 0) &#123; stringToInt[s] = id; intToString[id] = s; return id++; &#125; else &#123; return stringToInt[s]; &#125;&#125;int g[2010][2010], weight[2010];bool vis[2010];void dfs(int u, int &amp;head, int &amp;numMember, int &amp;totalweight) &#123; vis[u] = true; numMember++; if (weight[u] &gt; weight[head]) head = u; for (int v = 1; v &lt; id; v++) &#123; if (g[u][v] &gt; 0) &#123; totalweight += g[u][v]; g[u][v] = g[v][u] = 0; if (!vis[v]) dfs(v, head, numMember, totalweight); &#125; &#125;&#125;void dfsTrave() &#123; for (int i = 1; i &lt; id; i++) &#123; if (!vis[i]) &#123; int head = i, numMember = 0, totalweight = 0; dfs(i, head, numMember, totalweight); if (numMember &gt; 2 &amp;&amp; totalweight &gt; k) res[intToString[head]] = numMember; &#125; &#125;&#125;int main() &#123; int n, w; cin &gt;&gt; n &gt;&gt; k; string s1, s2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w; int id1 = stoifun(s1); int id2 = stoifun(s2); weight[id1] += w; weight[id2] += w; g[id1][id2] += w; g[id2][id1] += w; &#125; dfsTrave(); cout &lt;&lt; res.size() &lt;&lt; endl; for (auto it = res.begin(); it != res.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt; second &lt;&lt; endl; &#125; return 0;&#125; 1035 Password123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;string convert(string a) &#123; string b = &quot;&quot;; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] == &#x27;1&#x27;) b += &#x27;@&#x27;; else if (a[i] == &#x27;0&#x27;) b += &#x27;%&#x27;; else if (a[i] == &#x27;l&#x27;) b += &#x27;L&#x27;; else if (a[i] == &#x27;O&#x27;) b += &#x27;o&#x27;; else b += a[i]; &#125; return b;&#125;int main() &#123; int n; cin &gt;&gt; n; string name, password; vector&lt;pair&lt;string, string&gt; &gt; res; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; password; if (password != convert(password)) &#123; res.push_back(&#123;name, convert(password)&#125;); &#125; &#125; if (res.size() &gt; 1) &#123; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot; &quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; &#125; else if (n == 1) &#123; cout &lt;&lt; &quot;There is 1 account and no account is modified&quot;; &#125; else &#123; cout &lt;&lt; &quot;There are &quot; &lt;&lt; n &lt;&lt; &quot; accounts and no account is modified&quot;; &#125; return 0;&#125; 1036 Boys vs Girls1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name, id; int grade;&#125;;bool cmp(node a, node b) &#123; return a.grade &lt; b.grade;&#125;vector&lt;node&gt; males, famales;int main() &#123; int n; cin &gt;&gt; n; string name, gender, id; int grade; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; gender &gt;&gt; id &gt;&gt; grade; if (gender == &quot;M&quot;) &#123; males.push_back(&#123;name, id, grade&#125;); &#125; else &#123; famales.push_back(&#123;name, id, grade&#125;); &#125; &#125; bool flag = false; int diff; sort(males.begin(), males.end(), cmp); sort(famales.begin(), famales.end(), cmp); if (famales.size() &gt; 0) &#123; cout &lt;&lt; famales[famales.size() - 1].name &lt;&lt; &quot; &quot; &lt;&lt; famales[famales.size() - 1].id &lt;&lt; endl; diff = famales[famales.size() - 1].grade; &#125; else &#123; cout &lt;&lt; &quot;Absent&quot; &lt;&lt; endl; flag = true; &#125; if (males.size() &gt; 0) &#123; cout &lt;&lt; males[0].name &lt;&lt; &quot; &quot; &lt;&lt; males[0].id &lt;&lt; endl; diff += -males[0].grade; &#125; else &#123; cout &lt;&lt; &quot;Absent&quot; &lt;&lt; endl; flag = true; &#125; if (flag) cout &lt;&lt; &quot;NA&quot;; else cout &lt;&lt; diff; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); string female, male; int femalescore = -1, malescore = 101; for(int i = 0; i &lt; n; i++) &#123; string name, sex, num; int score; cin &gt;&gt; name &gt;&gt; sex &gt;&gt; num; scanf(&quot;%d&quot;, &amp;score); if(sex == &quot;F&quot;) &#123; if(femalescore &lt; score) &#123; femalescore = score; female = name + &quot; &quot; + num; &#125; &#125; else if(malescore &gt; score) &#123; malescore = score; male = name + &quot; &quot; + num; &#125; &#125; if(femalescore != -1) cout &lt;&lt; female &lt;&lt; endl; else printf(&quot;Absent &quot;); if(malescore != 101) cout &lt;&lt; male &lt;&lt; endl; else printf(&quot;Absent &quot;); if(femalescore != -1 &amp;&amp; malescore != 101) printf(&quot;%d&quot;, femalescore - malescore); else printf(&quot;NA&quot;); return 0;&#125; 1037 Magic Coupon123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;int a[N], b[N];int main() &#123; int n, m; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; b[i]; &#125; sort(a, a + n); sort(b, b + m); int al = 0, bl = 0, ar = n - 1, br = m - 1, res = 0; while(al &lt; n &amp;&amp; bl &lt; n &amp;&amp; a[al] &lt; 0 &amp;&amp; b[bl] &lt; 0) &#123; res += a[al++] * b[bl++]; &#125; while (ar &gt;= 0 &amp;&amp; br &gt;= 0 &amp;&amp; a[ar] &gt; 0 &amp;&amp; b[br] &gt; 0) &#123; res += a[ar--] * b[br--]; &#125; cout &lt;&lt; res; return 0;&#125; 1038 Recover the Smallest Number12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125;typedef long long LL;int main() &#123; int n; string x; cin &gt;&gt; n; vector&lt;string&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums.begin(), nums.end(), cmp); bool flag = true, first = true; for (int i = 0; i &lt; (LL)nums.size(); i++) &#123; if (first) &#123; int j = 0; for (; j &lt; (LL)nums[i].size(); j++) &#123; if (nums[i][j] != &#x27;0&#x27;) break; &#125; if (j &lt; (LL)nums[i].size()) first = false; for (; j &lt; (LL)nums[i].size(); j++) &#123; cout &lt;&lt; nums[i][j]; flag = false; &#125; &#125; else &#123; cout &lt;&lt; nums[i]; &#125; &#125; if (flag) cout &lt;&lt; 0; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125;string str[10010];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; str[i]; sort(str, str + n, cmp); string s; for (int i = 0; i &lt; n; i++) s += str[i]; while (s.size() != 0 &amp;&amp; s[0] == &#x27;0&#x27;) s.erase(s.begin()); if (s.size() == 0) cout &lt;&lt; 0; cout &lt;&lt; s; return 0;&#125; 1039 Course List for Student1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, vector&lt;int&gt; &gt; students;int main() &#123; int n, k, courseId, m; string name; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; courseId &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; name; students[name].push_back(courseId); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; students[name].size(); sort(students[name].begin(), students[name].end()); for (int j = 0; j &lt; students[name].size(); j++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; students[name][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int getid(char *name) &#123; int id = 0; for(int i = 0; i &lt; 3; i++) id = 26 * id + (name[i] - &#x27;A&#x27;); id = id * 10 + (name[3] - &#x27;0&#x27;); return id;&#125;const int maxn = 26 * 26 * 26 * 10 + 10;vector&lt;int&gt; v[maxn];int main() &#123; int n, k, no, num, id = 0; char name[5]; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt; k; i++) &#123; scanf(&quot;%d %d&quot;, &amp;no, &amp;num); for(int j = 0; j &lt; num; j++) &#123; scanf(&quot;%s&quot;, name); id = getid(name); v[id].push_back(no); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, name); id = getid(name); sort(v[id].begin(), v[id].end()); printf(&quot;%s %lu&quot;, name, v[id].size()); for(int j = 0; j &lt; v[id].size(); j++) printf(&quot; %d&quot;, v[id][j]); printf(&quot; &quot;); &#125; return 0;&#125; 1040 Longest Symmetric String12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1005;bool dp[N][N];int main() &#123; string str; getline(cin, str); int n = str.size(), res = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i][i] = true; if (i &lt; n - 1 &amp;&amp; str[i] == str[i + 1]) &#123; dp[i][i + 1] = true; res = 2; &#125; &#125; for (int len = 3; len &lt;= n; len++) &#123; for (int l = 0; l &lt; n - len + 1; l++) &#123; int r = l + len - 1; if (str[l] == str[r] &amp;&amp; dp[l + 1][r - 1]) &#123; dp[l][r] = true; res = len; &#125; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1041 Be Unique1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int N = 100005;int nums[N], cnt[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; cnt[nums[i]] ++; &#125; for (int i = 0; i &lt; n; i++) &#123; if (cnt[nums[i]] == 1) &#123; cout &lt;&lt; nums[i]; return 0; &#125; &#125; cout &lt;&lt; &quot;None&quot;; return 0;&#125; 1042 Shuffling Machine123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string nums[55] = &#123;&quot; &quot;,&quot;S1&quot;,&quot;S2&quot;,&quot;S3&quot;,&quot;S4&quot;,&quot;S5&quot;,&quot;S6&quot;,&quot;S7&quot;,&quot;S8&quot;,&quot;S9&quot;,&quot;S10&quot;,&quot;S11&quot;,&quot;S12&quot;,&quot;S13&quot;,&quot;H1&quot;,&quot;H2&quot;,&quot;H3&quot;,&quot;H4&quot;,&quot;H5&quot;,&quot;H6&quot;,&quot;H7&quot;,&quot;H8&quot;,&quot;H9&quot;,&quot;H10&quot;,&quot;H11&quot;,&quot;H12&quot;,&quot;H13&quot;,&quot;C1&quot;,&quot;C2&quot;,&quot;C3&quot;,&quot;C4&quot;,&quot;C5&quot;,&quot;C6&quot;,&quot;C7&quot;,&quot;C8&quot;,&quot;C9&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;,&quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;,&quot;D4&quot;,&quot;D5&quot;,&quot;D6&quot;,&quot;D7&quot;,&quot;D8&quot;,&quot;D9&quot;,&quot;D10&quot;,&quot;D11&quot;,&quot;D12&quot;,&quot;D13&quot;,&quot;J1&quot;, &quot;J2&quot;&#125;;int shuff[55];int main () &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt; 55; i++) &#123; cin &gt;&gt; shuff[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; string tmps[55]; for (int j = 1; j &lt; 55; j++) &#123; tmps[shuff[j]] = nums[j]; &#125; copy(begin(tmps), end(tmps), begin(nums)); &#125; for (int i = 1; i &lt; 55; i++) &#123; cout &lt;&lt; nums[i]; if (i &lt; 54) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main () &#123; int cnt; cin &gt;&gt; cnt; int start[55], end[55], scan[55]; for (int i = 1; i &lt; 55; i++) &#123; cin &gt;&gt; scan[i]; end[i] = i; &#125; for (int i = 0; i &lt; cnt; i++) &#123; for (int j = 1; j &lt; 55; j++) start[j] = end[j]; for (int k = 1; k &lt; 55; k++) end[scan[k]] = start[k]; &#125; char c[6] = &#123;&quot;SHCDJ&quot;&#125;; for (int i = 1; i &lt; 55; i++) &#123; end[i] = end[i] - 1; cout &lt;&lt; c[end[i] / 13] &lt;&lt; end[i] % 13 + 1; if (i != 54) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1043 Is It a Binary Search Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool isMirror;vector&lt;int&gt; pre, post;void getpost(int root, int tail) &#123; if (root&gt; tail) return; int i = root + 1, j = tail; if (!isMirror) &#123; while (i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) i++; while (j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) j--; &#125; else &#123; while (i &lt;= tail &amp;&amp; pre[root] &lt;= pre[i]) i++; while (j &gt; root &amp;&amp; pre[root] &gt; pre[j]) j--; &#125; if (i - j != 1) return; getpost(root + 1, j); getpost(i, tail); post.push_back(pre[root]);&#125;int main() &#123; int n; cin &gt;&gt; n; pre.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; &#125; getpost(0, n - 1); if (post.size() != n) &#123; isMirror = true; post.clear(); getpost(0, n - 1); &#125; if (post.size() == n) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; post[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; &#125; else &#123; cout &lt;&lt; &quot;NO&quot;; &#125; return 0;&#125; 1044 Shopping in Marsæ»‘åŠ¨çª—å£ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int N = 100005;vector&lt;pair&lt;int, int&gt; &gt; res;int nums[N];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int tmp = 0, maxn = 0x3f3f3f3f; int l = 0, r = 0; while (r &lt; n) &#123; tmp += nums[r]; if (tmp &gt;= m &amp;&amp; tmp &lt; maxn) maxn = tmp; if (tmp == maxn) res.push_back(&#123;l + 1, r + 1&#125;); while (l &lt; r &amp;&amp; tmp &gt;= m) &#123; if (maxn &gt; tmp) &#123; maxn = tmp; res.clear(); if (tmp == maxn) res.push_back(&#123;l + 1, r + 1&#125;); &#125; tmp -= nums[l++]; if (tmp == maxn) res.push_back(&#123;l + 1, r + 1&#125;); &#125; r++; &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot;-&quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ï¼ˆäºŒåˆ†ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; sum, res;int n, m;void search(int i, int &amp;j, int &amp;tmp) &#123; int l = i, r = n; while (l &lt; r) &#123; int mid = (l + r) / 2; if (sum[mid] - sum[i - 1] &gt;= m) r = mid; else l = mid + 1; &#125; j = r; tmp = sum[j] - sum[i - 1];&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; sum.resize(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; sum[i]; sum[i] += sum[i - 1]; &#125; int minres = sum[n]; for (int i = 1; i &lt;= n; i++) &#123; int j, tmpsum; search(i, j, tmpsum); if (tmpsum &gt; minres) continue; if (tmpsum &gt;= m) &#123; if (tmpsum &lt; minres) &#123; res.clear(); minres = tmpsum; &#125; res.push_back(i); res.push_back(j); &#125; &#125; for (int i = 0; i &lt; res.size(); i += 2) cout &lt;&lt; res[i] &lt;&lt; &quot;-&quot; &lt;&lt; res[i + 1] &lt;&lt; endl; return 0;&#125; 1045 Favorite Color StripeåŠ¨æ€è§„åˆ’ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[10001], b[201], a[10001];int main() &#123; int n, m, x, l, num = 0, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x; b[x] = i; &#125; cin &gt;&gt; l; for (int i = 0; i &lt; l; i++) &#123; cin &gt;&gt; x; if (b[x] &gt;= 1) a[num++] = b[x]; &#125; for (int i = 0; i &lt; num; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (a[i] &gt;= a[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; res = max(dp[i], res); &#125; cout &lt;&lt; res; return 0;&#125; 1046 Shortest Distanceå‰ç¼€å’Œ 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200001;int nums[N], sums[N];int main() &#123; int n, m, a, b; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; nums[i]; nums[i + n] = nums[i]; sums[i] = sums[i - 1] + nums[i]; &#125; for (int i = n + 1; i &lt; n + n; i++) &#123; sums[i] = sums[i - 1] + nums[i]; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &gt; b) swap(a, b); cout &lt;&lt; min(sums[b - 1] - sums[a - 1], sums[a + n - 1] - sums[b - 1]) &lt;&lt; endl; &#125; return 0;&#125; 1047 Student List for Course1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt; course[2501];int main() &#123; int n, k, c, x; string name; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; c; for (int j = 0; j &lt; c; j++) &#123; cin &gt;&gt; x; course[x].push_back(name); &#125; &#125; for (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; course[i].size() &lt;&lt; endl; sort(course[i].begin(), course[i].end()); for (int j = 0; j &lt; course[i].size(); j++) &#123; printf(&quot;%s &quot;, course[i][j].c_str()); &#125; &#125; return 0;&#125; 1048 Find CoinsåŒæŒ‡é’ˆ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int nums[N];int main() &#123; int n, m, cnt = 0, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (x &lt; m) nums[cnt++] = x; &#125; sort(nums, nums + cnt); int l = 0, r = cnt - 1, tmp = nums[l] + nums[r]; while (l &lt; r) &#123; if (tmp == m) &#123; cout &lt;&lt; nums[l] &lt;&lt; &quot; &quot; &lt;&lt; nums[r]; return 0; &#125; else if (tmp &gt; m) &#123; r--; &#125; else &#123; l++; &#125; tmp = nums[l] + nums[r]; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int nums[1001];int main() &#123; int n, m, cnt = 0, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; nums[x] ++; &#125; for (int i = 0; i &lt; 1001; i++) &#123; if (nums[i]) &#123; nums[i]--; if (m &gt; i &amp;&amp; nums[m - i]) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; m - i; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125; 1049 Counting Onesæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int a = i; while (a) &#123; if (a % 10 == 1) cnt++; a /= 10; &#125; &#125; cout &lt;&lt; cnt; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, left = 0, right = 0, a = 1, now = 1, res = 0; cin &gt;&gt; n; while (n / a) &#123; left = n / (a * 10), now = n / a % 10, right = n % a; if (now == 0) res += left * a; else if (now == 1) res += left * a + right + 1; else res += (left + 1) * a; a = a * 10; &#125; cout &lt;&lt; res; return 0;&#125; 1050 String Subtraction1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;string s1, s2;bool nums[129];int main() &#123; getline(cin, s1); getline(cin, s2); for (auto i: s2) &#123; nums[i] = true; &#125; for (auto i: s1) &#123; if (!nums[i]) cout &lt;&lt; i; &#125; return 0;&#125; 1051 Pop Sequence123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; int m, n, k, x; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; int cnt = 1; stack&lt;int&gt; st; bool flag = true; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; x; while (x &gt;= cnt &amp;&amp; st.size() &lt; m &amp;&amp; cnt &lt;= n) &#123; st.push(cnt); cnt++; &#125; if (st.top() != x) &#123; flag = false; while (j++ &lt; n - 1) cin &gt;&gt; x; break; &#125; st.pop(); &#125; cout &lt;&lt; (flag ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; &#125; return 0;&#125; 1052 Linked List Sorting1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct node &#123; int add, key, next;&#125;;bool cmp(PII a, PII b) &#123; return a.second &lt; b.second;&#125;const int INF = 0x3f3f3f3f;const int N = 100001;node nums[N];vector&lt;PII&gt; nums2;int main() &#123; int n, head, add, key, nex; cin &gt;&gt; n &gt;&gt; head; if (head == -1) &#123; cout &lt;&lt; &quot;0 -1&quot;; return 0; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; key &gt;&gt; nex; nums[add] = &#123;add, key, nex&#125;; &#125; while (head != -1) &#123; nums2.push_back(&#123;head, nums[head].key&#125;); head = nums[head].next; &#125; sort(nums2.begin(), nums2.end(), cmp); printf(&quot;%d %05d &quot;, nums2.size(), nums2[0].first); for (int i = 0; i &lt; nums2.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, nums2[i].first, nums2[i].second, nums2[i + 1].first); &#125; printf(&quot;%05d %d -1 &quot;, nums2[nums2.size() - 1].first, nums2[nums2.size() - 1].second); return 0;&#125; 1053 Path of Equal Weight1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;int weight[N], sum, s;vector&lt;int&gt; trees[N], tmp;vector&lt;vector&lt;int&gt; &gt; res;bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123; for (int i = 0; ; i++) &#123; if (a[i] != b[i]) return a[i] &gt; b[i]; &#125;&#125;void dfs(int x) &#123; if (sum == s &amp;&amp; trees[x].empty()) &#123; res.push_back(tmp); return; &#125; if (sum &gt; s) return; for (int i = 0; i &lt; trees[x].size(); i++) &#123; sum += weight[trees[x][i]]; tmp.push_back(weight[trees[x][i]]); dfs(trees[x][i]); sum -= weight[trees[x][i]]; tmp.pop_back(); &#125;&#125;int main() &#123; int n, m, cur, k, child; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; s -= weight[0]; tmp.push_back(weight[0]); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; cur &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; trees[cur].push_back(child); &#125; &#125; dfs(0); sort(res.begin(), res.end(), cmp); for (int i = 0; i &lt; res.size(); i++) &#123; for (int j = 0; j &lt; res[i].size(); j++) &#123; printf(&quot;%d&quot;, res[i][j]); if (j &lt; res[i].size() - 1) printf(&quot; &quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125; 1054 The Dominant Color12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;map&lt;int, int&gt; nums;vector&lt;pair&lt;int, int&gt; &gt; res;bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.second &gt; b.second;&#125;int main() &#123; int m, n, x; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; nums[x]++; &#125; &#125; for (auto it: nums) &#123; res.push_back(it); &#125; sort(res.begin(), res.end(), cmp); cout &lt;&lt; res[0].first; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; nums;int main() &#123; int m, n, x; cin &gt;&gt; m &gt;&gt; n; int half = m * n / 2; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; nums[x]++; if (nums[x] &gt; half) &#123; cout &lt;&lt; x; return 0; &#125; &#125; &#125; return 0;&#125; 1055 The Worldâ€™s Richest123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int age, worth;&#125;;bool cmp(node a, node b) &#123; if (a.worth != b.worth) return a.worth &gt; b.worth; else if (a.age != b.age) return a.age &lt; b.age; else return a.name &lt; b.name;&#125;vector&lt;node&gt; nums[201];int main() &#123; int n, k, age, worth, m, start, end; cin &gt;&gt; n &gt;&gt; k; string name; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; age &gt;&gt; worth; nums[age].push_back(&#123;name, age, worth&#125;); &#125; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; m &gt;&gt; start &gt;&gt; end; if (start &lt; 1) start = 1; if (end &gt; 200) end = 200; vector&lt;node&gt; tmp; for (int j = start; j &lt;= end; j++) &#123; for (auto it: nums[j]) &#123; tmp.push_back(&#123;it.name, it.age, it.worth&#125;); &#125; &#125; sort(tmp.begin(), tmp.end(), cmp); printf(&quot;Case #%d: &quot;, i); for (int j = 0; j &lt; min((int)tmp.size(), m); j++) &#123; printf(&quot;%s %d %d &quot;, tmp[j].name.c_str(), tmp[j].age, tmp[j].worth); &#125; if (tmp.empty()) printf(&quot;None&quot;); &#125; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int age, worth;&#125; nums[100001];bool cmp(node a, node b) &#123; if (a.worth != b.worth) return a.worth &gt; b.worth; else if (a.age != b.age) return a.age &lt; b.age; else return a.name &lt; b.name;&#125;int main() &#123; int n, k, age, worth, m, start, end; cin &gt;&gt; n &gt;&gt; k; string name; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].name &gt;&gt; nums[i].age &gt;&gt; nums[i].worth; &#125; sort(nums, nums + n, cmp); for (int i = 1; i &lt;= k; i++) &#123; printf(&quot;Case #%d: &quot;, i); cin &gt;&gt; m &gt;&gt; start &gt;&gt; end; int cnt = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[j].age &gt;= start &amp;&amp; nums[j].age &lt;= end) &#123; printf(&quot;%s %d %d &quot;, nums[j].name.c_str(), nums[j].age, nums[j].worth); cnt++; &#125; if (cnt == m) break; &#125; if (cnt == 0) printf(&quot;None&quot;); &#125; return 0;&#125; 1056 Mice and Rice1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int weight[10001], ranks[10001];vector&lt;int&gt; tmp, res[300];int main() &#123; int np, ng, x; cin &gt;&gt; np &gt;&gt; ng; for (int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; weight[i]; &#125; for (int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; x; tmp.push_back(x); &#125; int depth = 0, d = np / ng + 1; while (d--) &#123; for (int i = 0; i &lt; tmp.size(); i += ng) &#123; int ma = 0, idx = 0; for (int j = i; j &lt; min(ng + i, (int)tmp.size()); j++) &#123; if (weight[tmp[j]] &gt; ma) &#123; ma = weight[tmp[j]]; idx = tmp[j]; &#125; &#125; res[depth + 1].push_back(idx); for (int j = i; j &lt; min(ng + i, (int)tmp.size()); j++) &#123; if (tmp[j] != idx) res[depth].push_back(tmp[j]); &#125; &#125; tmp.clear(); tmp = res[depth + 1]; res[depth + 1].clear(); depth++; &#125; int rank = 1; ranks[tmp[0]] = rank++; for (int i = depth - 1; i &gt;= 0; i--) &#123; for (auto it: res[i]) &#123; ranks[it] = rank; &#125; rank += res[i].size(); &#125; for (int i = 0; i &lt; np; i++) &#123; cout &lt;&lt; ranks[i]; if (i &lt; np - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1057 Stackæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;stack&lt;int&gt; st;vector&lt;int&gt; tmp;int main() &#123; int n, x; string op; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; op; if (op == &quot;Pop&quot;) &#123; if (st.empty()) cout &lt;&lt; &quot;Invalid&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; st.top() &lt;&lt; endl; tmp.erase(find(tmp.begin(), tmp.end(), st.top())); st.pop(); &#125; &#125; else if (op == &quot;Push&quot;) &#123; cin &gt;&gt; x; st.push(x); tmp.push_back(x); &#125; else if (op == &quot;PeekMedian&quot;) &#123; if (st.empty()) cout &lt;&lt; &quot;Invalid&quot; &lt;&lt; endl; else &#123; sort(tmp.begin(), tmp.end()); if (tmp.size() % 2) cout &lt;&lt; tmp[(tmp.size() - 1) / 2] &lt;&lt; endl; else cout &lt;&lt; tmp[tmp.size() / 2 - 1] &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; æŸ³å©¼çš„ï¼ˆæ ‘çŠ¶æ•°ç»„ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define lowbit(i) ((i) &amp; (-i))const int N = 100010;int c[N];stack&lt;int&gt; s;void update(int x, int v) &#123; for (int i = x; i &lt; N; i += lowbit(i)) c[i] += v;&#125;int getsum(int x) &#123; int sum = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) sum += c[i]; return sum;&#125;void PeekMedian() &#123; int left = 1, right = N, mid, k = (s.size() + 1) / 2; while (left &lt; right) &#123; mid = (left + right) / 2; if (getsum(mid) &gt;= k) right = mid; else left = mid + 1; &#125; printf(&quot;%d &quot;, left);&#125;int main() &#123; int n, tmp; scanf(&quot;%d&quot;, &amp;n); char str[15]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, str); if (str[1] == &#x27;u&#x27;) &#123; scanf(&quot;%d&quot;, &amp;tmp); s.push(tmp); update(tmp, 1); &#125; else if (str[1] == &#x27;o&#x27;) &#123; if (!s.empty()) &#123; update(s.top(), -1); printf(&quot;%d &quot;, s.top()); s.pop(); &#125; else &#123; printf(&quot;Invalid &quot;); &#125; &#125; else &#123; if (!s.empty()) PeekMedian(); else printf(&quot;Invalid &quot;); &#125; &#125; return 0;&#125; 1058 A+B in Hogwarts - PAT (Advanced Level) Practice (pintia.cn)123456789101112#include &lt;iostream&gt;int main() &#123; int a1, a2, a3, b1, b2, b3, c1, c2, c3, t; scanf(&quot;%d.%d.%d %d.%d.%d&quot;, &amp;a1, &amp;a2, &amp;a3, &amp;b1, &amp;b2, &amp;b3); c3 = (a3 + b3) % 29; t = (a3 + b3) / 29; c2 = (a2 + b2 + t) % 17; t = (a2 + b2 + t) / 17; c1 = a1 + b1 + t; printf(&quot;%d.%d.%d&quot;, c1, c2, c3); return 0;&#125; 1059 Prime Factors123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;int main() &#123; LL n; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; &quot;=&quot;; if (n == 1) cout &lt;&lt; 1; for (LL i = 2; i &lt;= sqrt(n); i++) &#123; int cnt = 0; if (n % i == 0) &#123; while (n % i == 0) &#123; cnt++; n /= i; &#125; &#125; if (cnt &gt; 1) cout &lt;&lt; i &lt;&lt; &quot;^&quot; &lt;&lt; cnt; else if (cnt == 1) cout &lt;&lt; i; if (cnt != 0 &amp;&amp; n &gt; 1) cout &lt;&lt; &quot;*&quot;; &#125; if (n &gt; 1) cout &lt;&lt; n; return 0;&#125; 1060 Are They Equal1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string convert(string str, int n) &#123; int idx = 0, len = str.size(), k = 0; string t; while (idx &lt; len &amp;&amp; str[idx] == &#x27;0&#x27;) idx++; if (str[idx] == &#x27;.&#x27;) &#123; idx++; while (idx &lt; len &amp;&amp; str[idx] == &#x27;0&#x27;) &#123; idx++; k--; &#125; bool flag = false; while (t.size() &lt; n &amp;&amp; idx &lt; len) &#123; t.push_back(str[idx++]); flag = true; &#125; while (t.size() &lt; n) t.push_back(&#x27;0&#x27;); if (!flag) k = 0; &#125; else &#123; for (int j = idx; str[j] != &#x27;.&#x27; &amp;&amp; j &lt; len; j++) k++; while (str[idx] != &#x27;.&#x27; &amp;&amp; t.size() &lt; n &amp;&amp; idx &lt; len) t.push_back(str[idx++]); if (t.size() &lt; n) idx++; while (idx &lt; len &amp;&amp; t.size() &lt; n) t.push_back(str[idx++]); while (t.size() &lt; n) t.push_back(&#x27;0&#x27;); &#125; return &quot;0.&quot; + t + &quot;*10^&quot; + to_string(k);&#125;int main() &#123; int n; string a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; a = convert(a, n); b = convert(b, n); if (a == b) cout &lt;&lt; &quot;YES &quot; &lt;&lt; a; else cout &lt;&lt; &quot;NO &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b; return 0;&#125; 1061 Dating12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int sa = a.size(), sb = b.size(), sc = c.size(), sd = d.size(); int week, hour, minute, cnt = 0; string weeks[7] = &#123;&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;&#125;; bool is_first = true; for (int i = 0; i &lt; min(sa, sb); i++) &#123; if (a[i] == b[i] &amp;&amp; a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;G&#x27; &amp;&amp; is_first) &#123; week = a[i] - &#x27;A&#x27;; is_first = false; continue; &#125; if (!is_first &amp;&amp; a[i] == b[i] &amp;&amp; ((a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;N&#x27;) || isdigit(a[i]))) &#123; if (a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;N&#x27;) &#123; hour = a[i] - &#x27;A&#x27; + 10; &#125; else if (isdigit(a[i])) &#123; hour = a[i] - &#x27;0&#x27;; &#125; break; &#125; &#125; for (int i = 0; i &lt; min(sc, sd); i++) &#123; if (c[i] == d[i] &amp;&amp; isalpha(c[i])) &#123; minute = i; break; &#125; &#125; printf(&quot;%s %02d:%02d&quot;, weeks[week].c_str(), hour, minute); return 0;&#125; 1062 Talent and Virtue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int num, virtue, talent, sum;&#125;;bool cmp(node a, node b) &#123; if (a.sum != b.sum) return a.sum &gt; b.sum; else if (a.virtue != b.virtue) return a.virtue &gt; b.virtue; else if (a.talent != b.talent) return a.talent &gt; b.talent; else return a.num &lt; b.num;&#125;vector&lt;node&gt; sage, nobleman, fool, small;int main() &#123; int n, l, h, num, virtue, talent; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num &gt;&gt; virtue &gt;&gt; talent; int sum = virtue + talent; if (virtue &gt;= h &amp;&amp; talent &gt;= h) &#123; sage.push_back(&#123;num, virtue, talent, sum&#125;); &#125; else if (virtue &gt;= h &amp;&amp; talent &gt;= l) &#123; nobleman.push_back(&#123;num, virtue, talent, sum&#125;); &#125; else if (virtue &gt;= talent &amp;&amp; talent &gt;= l) &#123; fool.push_back(&#123;num, virtue, talent, sum&#125;); &#125; else if (virtue &gt;= l &amp;&amp; talent &gt;= l) &#123; small.push_back(&#123;num, virtue, talent, sum&#125;); &#125; &#125; sort(sage.begin(), sage.end(), cmp); sort(nobleman.begin(), nobleman.end(), cmp); sort(fool.begin(), fool.end(), cmp); sort(small.begin(), small.end(), cmp); cout &lt;&lt; sage.size() + nobleman.size() + fool.size() + small.size()&lt;&lt; endl; for (auto it: sage) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; for (auto it: nobleman) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; for (auto it: fool) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; for (auto it: small) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; return 0;&#125; 1063 Set Similarity123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, bool&gt; nums[51];int main() &#123; int n, m, x, k, a, b; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); nums[i][x] = true; &#125; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; map&lt;int, bool&gt; tmp; tmp = nums[a]; int common = 0, total = 0; for (auto it: nums[b]) &#123; if (tmp[it.first]) &#123; tmp[it.first] = false; common++; total++; &#125; else &#123; total++; &#125; &#125; for (auto it: tmp) &#123; if (it.second) total++; &#125; printf(&quot;%.1f\\% &quot;, common * 100.0 / total); &#125; return 0;&#125; 1064 Complete Binary Search Tree123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1001;int in[N], level[N], n, idx = 0;void dfs(int root) &#123; if (root &gt;= n) return; dfs(root * 2 + 1); level[root] = in[idx++]; dfs(root * 2 + 2);&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; sort(in, in + n); dfs(0); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; level[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1065 A+B and C (64bit)12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;typedef long long LL;int main() &#123; int n; LL a, b, c; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; LL t = a + b; if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt; 0) &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: true&quot; &lt;&lt; endl; &#125; else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; t &gt; 0) &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: false&quot; &lt;&lt; endl; &#125; else if (a + b &gt; c) &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: true&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: false&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 1066 Root of AVL Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;struct node &#123; int val; node *left, *right;&#125;;node* rotateLeft(node* root) &#123; node *t = root-&gt;right; root-&gt;right = t-&gt;left; t-&gt;left = root; return t;&#125;node* rotateRight(node* root) &#123; node *t = root-&gt;left; root-&gt;left = t-&gt;right; t-&gt;right = root; return t;&#125;node* rotateLeftRight(node* root) &#123; root-&gt;left = rotateLeft(root-&gt;left); return rotateRight(root);&#125;node* rotateRightLeft(node* root) &#123; root-&gt;right = rotateRight(root-&gt;right); return rotateLeft(root);&#125;int getHeight(node* root) &#123; if (root == NULL) return 0; return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;&#125;node* insert(node* root, int val) &#123; if (root == NULL) &#123; root = new node(); root-&gt;val = val; root-&gt;left = NULL; root-&gt;right = NULL; &#125; else if (val &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, val); if (getHeight(root-&gt;left) - getHeight(root-&gt;right) == 2) &#123; root = val &lt; root-&gt;left-&gt;val ? rotateRight(root) : rotateLeftRight(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, val); if (getHeight(root-&gt;right) - getHeight(root-&gt;left) == 2) &#123; root = val &gt; root-&gt;right-&gt;val ? rotateLeft(root) : rotateRightLeft(root); &#125; &#125; return root;&#125;int main() &#123; int n, val; cin &gt;&gt; n; node *root = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; val; root = insert(root, val); &#125; cout &lt;&lt; (&quot;%d&quot;, root-&gt;val); return 0;&#125; 1067 Sort with Swap(0, i)1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];int main() &#123; int n, x, res = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;x); nums[x] = i; &#125; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] != i) &#123; while (nums[0] != 0) &#123; swap(nums[0], nums[nums[0]]); res++; &#125; if (nums[i] != i) &#123; swap(nums[0], nums[i]); res++; &#125; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1068 Find More Coinsdfs 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int nums[10001], n, m;vector&lt;int&gt; tmp;void dfs(int x, int t) &#123; if (t == m) &#123; for (int i = 0; i &lt; tmp.size(); i++) &#123; cout &lt;&lt; tmp[i]; if (i &lt; tmp.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; exit(0); &#125; if (t &gt; m || x == n) return; tmp.push_back(nums[x]); dfs(x + 1, t + nums[x]); tmp.pop_back(); dfs(x + 1, t);&#125;int main() &#123; int sum = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; sum += nums[i]; &#125; if (sum &lt; m) cout &lt;&lt; &quot;No Solution&quot;; else &#123; sort(nums, nums + n); dfs(0, 0); cout &lt;&lt; &quot;No Solution&quot;; &#125; return 0;&#125; æŸ³å©¼çš„ï¼ˆdpï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int dp[100001], nums[100001];bool choice[100001][110];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums + 1, nums + n + 1, greater&lt;int&gt;()); for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= nums[i]; j--) &#123; if (dp[j] &lt;= dp[j - nums[i]] + nums[i]) &#123; choice[i][j] = true; dp[j] = dp[j - nums[i]] + nums[i]; &#125; &#125; &#125; if (dp[m] != m) cout &lt;&lt; &quot;No Solution&quot;; else &#123; vector&lt;int&gt; res; int v = m, idx = n; while(v &gt; 0) &#123; if (choice[idx][v] == true) &#123; res.push_back(nums[idx]); v -= nums[idx]; &#125; idx--; &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; &#125; return 0;&#125; 1069 The Black Hole of Numbers12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string n; cin &gt;&gt; n; while(n.size() &lt; 4) n = &#x27;0&#x27; + n; do &#123; string a = n, b = n; sort(a.begin(), a.end()); sort(b.begin(), b.end(), greater&lt;char&gt;()); int c = stoi(b) - stoi(a); n = to_string(c); while(n.size() &lt; 4) n = &#x27;0&#x27; + n; cout &lt;&lt; b &lt;&lt; &quot; - &quot; &lt;&lt; a &lt;&lt; &quot; = &quot; &lt;&lt; n &lt;&lt; endl; &#125; while (n != &quot;6174&quot; &amp;&amp; n!= &quot;0000&quot;); return 0;&#125; 1070 Mooncake123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; double amount, price, profit;&#125; nums[1001];bool cmp(node &amp;a, node &amp;b) &#123; return a.profit &gt; b.profit;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].amount; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].price; nums[i].profit = nums[i].price / nums[i].amount; &#125; sort(nums, nums + n, cmp); double res; for (int i = 0; i &lt; n; i++) &#123; if (nums[i].amount &gt;= m) &#123; res += m * nums[i].profit; break; &#125; else &#123; res += nums[i].price; m -= nums[i].amount; &#125; &#125; printf(&quot;%.2f&quot;, res); return 0;&#125; 1071 Speech Patterns1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; nums;int main() &#123; string str; getline(cin, str); str += &#x27;.&#x27;; for (int i = 0; i &lt; str.size(); i++) &#123; for (int j = i; j &lt; str.size(); j++) &#123; if (isalpha(str[j])) str[j] = tolower(str[j]); if (!isalnum(str[j])) &#123; if (j != i) &#123; nums[str.substr(i, j - i)]++; &#125; i = j; break; &#125; &#125; &#125; string res = nums.begin()-&gt;first; int m = nums.begin()-&gt;second; for (auto it: nums) &#123; if (m &lt; it.second) &#123; m = it.second; res = it.first; &#125; &#125; cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; m; return 0;&#125; 1072 Gas Stationdijkstra 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int N = 1012;const int INF = 0x3f3f3f3f;vector&lt;pair&lt;int, int&gt; &gt; g[N];int dist[N], n, m, sums[11], mins[11];bool visit[N];void dijkstra(int x) &#123; fill(dist, dist + N, INF); fill(visit, visit + N, false); dist[x] = 0; for (int i = 0; i &lt; n + m; i++) &#123; int u = -1, mind = INF; for (int j = 1; j &lt;= n + m; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; dist[j]) &#123; mind = dist[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v] &amp;&amp; dist[v] &gt; dist[u] + dis) &#123; dist[v] = dist[u] + dis; &#125; &#125; &#125;&#125;int main() &#123; int k, d, dis, t1, t2; string p1, p2; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; if (p1[0] == &#x27;G&#x27;) t1 = n + stoi(p1.substr(1)); else t1 = stoi(p1); if (p2[0] == &#x27;G&#x27;) t2 = n + stoi(p2.substr(1)); else t2 = stoi(p2); g[t1].push_back(&#123;t2, dis&#125;); g[t2].push_back(&#123;t1, dis&#125;); &#125; int real_sum = INF, real_min = 0, real_id = 0; for (int i = 1; i &lt;= m; i++) &#123; dijkstra(n + i); int res = INF, sum = 0; bool flag = true; for (int j = 1; j &lt;= n; j++) &#123; if (dist[j] &gt; d) &#123; flag = false; break; &#125; sum += dist[j]; res = min(res, dist[j]); &#125; if (flag) &#123; if (real_min &lt; res) &#123; real_sum = sum; real_id = i; real_min = res; &#125; else if (real_min == res) &#123; if (real_sum &gt; sum) &#123; real_sum = sum; real_id = i; &#125; &#125; &#125; &#125; if (real_min == 0) cout &lt;&lt; &quot;No Solution&quot;; else printf(&quot;G%d %.1f %.1f&quot;, real_id, (double)real_min, (double)real_sum / n); return 0;&#125; 1073 Scientific Notation123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; if (str[0] == &#x27;-&#x27;) cout &lt;&lt; &quot;-&quot;; int exp, i; for (i = 3; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;E&#x27;) break; &#125; if (str[i + 1] == &#x27;-&#x27;) &#123; exp = stoi(str.substr(i + 2)); cout &lt;&lt; &quot;0.&quot;; for (int j = 0; j &lt; exp - 1; j++) cout &lt;&lt; 0; cout &lt;&lt; str[1] &lt;&lt; str.substr(3, i - 3); &#125; else &#123; exp = stoi(str.substr(i + 1)); if (str[1] != &#x27;0&#x27;) cout &lt;&lt; str[1]; if (exp &lt; i - 3) &#123; for (int j = 0; j &lt; exp; j++) &#123; cout &lt;&lt; str[j + 3]; &#125; cout &lt;&lt; &quot;.&quot;; for (int j = exp; j &lt; i - 3; j++) &#123; cout &lt;&lt; str[j + 3]; &#125; &#125; else &#123; for (int j = 0; j &lt; exp; j++) &#123; if (j &lt; i - 3) cout &lt;&lt; str[j + 3]; else cout &lt;&lt; 0; &#125; &#125; &#125; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int i = 0; while (s[i] != &#x27;E&#x27;) i++; string t = s.substr(1, i - 1); int n = stoi(s.substr(i + 1)); if (s[0] == &#x27;-&#x27;) cout &lt;&lt; &quot;-&quot;; if (n &lt; 0) &#123; cout &lt;&lt; &quot;0.&quot;; for (int j = 0; j &lt; abs(n) - 1; j++) cout &lt;&lt; &#x27;0&#x27;; for (int j = 0; j &lt; t.length(); j++) if (t[j] != &#x27;.&#x27;) cout &lt;&lt; t[j]; &#125; else &#123; cout &lt;&lt; t[0]; int cnt, j; for (j = 2, cnt = 0; j &lt; t.length() &amp;&amp; cnt &lt; n; j++, cnt++) cout &lt;&lt; t[j]; if (j == t.length()) &#123; for (int k = 0; k &lt; n - cnt; k++) cout &lt;&lt; &#x27;0&#x27;; &#125; else &#123; cout &lt;&lt; &#x27;.&#x27;; for (int k = j; k &lt; t.length(); k++) cout &lt;&lt; t[k]; &#125; &#125; return 0;&#125; 1074 Reversing Linked Listæ•°ç»„æ¨¡æ‹Ÿ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct node &#123; string addr, nex; int val;&#125; ;map&lt;string, node&gt; nums1;vector&lt;node&gt; nums2;int main() &#123; int n, k, val; string start, addr, nex; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; addr &gt;&gt; val &gt;&gt; nex; nums1[addr] = &#123;addr, nex, val&#125;; &#125; while (start != &quot;-1&quot;) &#123; nums2.push_back(&#123;nums1[start].addr, nums1[start].nex, nums1[start].val&#125;); start = nums1[start].nex; &#125; for (i = 0; i &lt;= nums2.size() - k; i += k) &#123; for (int j = i + k - 1; j &gt; i; j--) &#123; cout &lt;&lt; nums2[j].addr &lt;&lt; &quot; &quot; &lt;&lt; nums2[j].val &lt;&lt; &quot; &quot; &lt;&lt; nums2[j - 1].addr &lt;&lt; endl; &#125; cout &lt;&lt; nums2[i].addr &lt;&lt; &quot; &quot; &lt;&lt; nums2[i].val &lt;&lt; &quot; &quot;; if (i + 2 * k &lt;= nums2.size()) cout &lt;&lt; nums2[i + 2 * k - 1].addr &lt;&lt; endl; else if (i + k &lt; nums2.size()) cout &lt;&lt; nums2[i + k].addr &lt;&lt; endl; else cout &lt;&lt; &quot;-1 &quot;; &#125; for (int j = i; j &lt; nums2.size(); j++) &#123; cout &lt;&lt; nums2[j].addr &lt;&lt; &quot; &quot; &lt;&lt; nums2[j].val &lt;&lt; &quot; &quot; &lt;&lt; nums2[j].nex &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N = 100005;int datas[N], nexts[N], list[N], res[N];int main() &#123; int first, k, n, sum = 0, tmp; cin &gt;&gt; first &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; cin &gt;&gt; datas[tmp] &gt;&gt; nexts[tmp]; &#125; while (first != -1) &#123; list[sum++] = first; first = nexts[first]; &#125; for (int i = 0; i &lt; sum; i++) res[i] = list[i]; for (int i = 0; i &lt; (sum - sum % k); i++) res[i] = list[i / k * k + k - 1 - i % k]; for (int i = 0; i &lt; sum - 1; i++) printf(&quot;%05d %d %05d &quot;, res[i], datas[res[i]], res[i + 1]); printf(&quot;%05d %d -1&quot;, res[sum - 1], datas[res[sum - 1]]); return 0;&#125; 1075 PAT Judge12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int userId = 99999, totle, s[6] = &#123;-1, -1, -1, -1, -1, -1&#125;, perfect; bool isShow;&#125; nums[10001];bool cmp(node &amp;a, node &amp;b) &#123; if (a.totle != b.totle) return a.totle &gt; b.totle; else if (a.perfect != b.perfect) return a.perfect &gt; b.perfect; return a.userId &lt; b.userId;&#125;int w[6];int main() &#123; int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; w[i]; &#125; int userId, problemId, score; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; userId &gt;&gt; problemId &gt;&gt; score; nums[userId].userId = userId; if (score &lt; 1) nums[userId].s[problemId] = max(0, nums[userId].s[problemId]); if (score &gt;= 0) nums[userId].isShow = true; if (score &gt; nums[userId].s[problemId]) &#123; if (score == w[problemId]) nums[userId].perfect++; nums[userId].totle += score - max(0, nums[userId].s[problemId]); nums[userId].s[problemId] = score; &#125; &#125; sort(nums, nums + 10001, cmp); int rank = 1; for (int i = 0; i &lt; 10000; i++) &#123; if (!nums[i].isShow) break; if (i != 0 &amp;&amp; nums[i].totle != nums[i - 1].totle) rank = i + 1; printf(&quot;%d %05d %d &quot;, rank, nums[i].userId, nums[i].totle); for (int j = 1; j &lt;= k; j++) &#123; if (nums[i].s[j] &lt; 0) cout &lt;&lt; &quot;-&quot;; else cout &lt;&lt; nums[i].s[j]; if (j &lt; k) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1076 Forwards on Weibo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; g[1001];bool visit[1001];int bfs(int u, int l) &#123; queue&lt;int&gt; q; q.push(u); fill(visit, visit + 1001, false); visit[u] = true; int res = 0, cnt = 0; while (!q.empty()) &#123; if (cnt &gt;= l) break; int len = q.size(); for (int i = 0; i &lt; len; i++) &#123; u = q.front(); q.pop(); for (int j = 0; j &lt; g[u].size(); j++) &#123; if (!visit[g[u][j]]) &#123; visit[g[u][j]] = true; res++; q.push(g[u][j]); &#125; &#125; &#125; cnt++; &#125; return res;&#125;int main() &#123; int n, l, m, x, k, query; cin &gt;&gt; n &gt;&gt; l; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; g[x].push_back(i); &#125; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; query; int res = bfs(query, l); cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 1077 Kuchiguse12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string strs[101];int main() &#123; int n, len = 257; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) &#123; getline(cin, strs[i]); len = min((int)strs[i].size(), len); &#125; string res = &quot;&quot;; for (int i = 1; i &lt;= len; i++) &#123; char ch = strs[0][strs[0].size() - i]; for (int j = 0; j &lt; n; j++) &#123; if (strs[j][strs[j].size() - i] != ch) &#123; if (res.empty()) cout &lt;&lt; &quot;nai&quot;; else cout &lt;&lt; res; return 0; &#125; &#125; res = ch + res; &#125; cout &lt;&lt; res; return 0;&#125; 1078 Hashing123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 20001;vector&lt;int&gt; primes;bool st[N];bool res[N];int main() &#123; int m, n, x; cin &gt;&gt; m &gt;&gt; n; for (int i = 2; i &lt; N; i++) &#123; if (!st[i]) &#123; primes.push_back(i); if (i &gt;= m) &#123; m = i; break; &#125; for (int j = i * 2; j &lt; N; j += i) &#123; st[j] = true; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; bool flag = false; for (int j = 0; j &lt; m; j++) &#123; if (!res[(x + j * j) % m]) &#123; cout &lt;&lt; (x + j * j) % m; res[(x + j * j) % m] = true; flag = true; break; &#125; &#125; if (!flag) cout &lt;&lt; &quot;-&quot;; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1079 Total Sales of Supply Chain1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int val; vector&lt;int&gt; child;&#125; trees[100001];double r, res;void dfs(int u, double p) &#123; if (trees[u].child.empty()) &#123; res += trees[u].val * p; return; &#125; for (int i = 0; i &lt;trees[u].child.size(); i++) &#123; dfs(trees[u].child[i], p + p * r); &#125;&#125;int main() &#123; int n, k, x; double p; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; r /= 100; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k; if (k == 0) &#123; cin &gt;&gt; x; trees[i].val = x; &#125; else &#123; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; x; trees[i].child.push_back(x); &#125; &#125; &#125; dfs(0, p); printf(&quot;%.1f&quot;, res); return 0;&#125; 1080 Graduate Admission123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct student &#123; int num, ge, gi, total, apps[6], rank;&#125; students[40001];int limits[101];vector&lt;int&gt; schools[101];bool cmp(student &amp;a, student &amp;b) &#123; if (a.total != b.total) return a.total &gt; b.total; else if (a.ge != b.ge) return a.ge &gt; b.ge; else return a.num &lt; b.num;&#125;int main() &#123; int n, m, k, ge, gi, total, rank = 1; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; limits[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; students[i].ge &gt;&gt; students[i].gi; students[i].total = students[i].ge + students[i].gi; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; students[i].apps[j]; &#125; students[i].num = i; &#125; sort(students, students + n, cmp); for (int i = 0; i &lt; n; i++) &#123; if (i != 0 &amp;&amp; (students[i].total != students[i - 1].total || students[i].ge != students[i - 1].ge)) rank++; students[i].rank = rank; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int t = students[i].apps[j]; if (limits[t]) &#123; schools[t].push_back(students[i].num); limits[t]--; while (limits[t] == 0 &amp;&amp; i &lt; n - 1 &amp;&amp; students[i].rank == students[i + 1].rank) &#123; schools[t].push_back(students[i + 1].num); i++; &#125; break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; sort(schools[i].begin(), schools[i].end()); for (int j = 0; j &lt; schools[i].size(); j++) &#123; cout &lt;&lt; schools[i][j]; if (j &lt; schools[i].size() - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1081 Rational Sum123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b) &#123; if (b == 0) return a; else return gcd(b, a % b);&#125;void convert(LL a, LL b) &#123; if (a * b &lt; 0) &#123; cout &lt;&lt; &quot;-&quot;; a = abs(a); b = abs(b); &#125; LL t = a / b; if (t) cout &lt;&lt; t; a -= b * t; if (a == 0) &#123; if (t == 0) cout &lt;&lt; 0; return; &#125; if (t != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; a &lt;&lt; &quot;/&quot; &lt;&lt; b;&#125;int main() &#123; LL n, numerator, denominator, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b); if (i != 0) &#123; LL c = numerator * b + denominator * a; LL d = denominator * b; LL t = gcd(c, d); numerator = c / t; denominator = d / t; &#125; else numerator = a, denominator = b; &#125; convert(numerator, denominator); return 0;&#125; 1082 Read Number in Chineseå¤§æ¨¡æ‹Ÿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main() &#123; string dicts[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; int n; vector&lt;string&gt; res; cin &gt;&gt; n; if (n == 0) &#123; cout &lt;&lt; &quot;ling&quot;; return 0; &#125; if (n &lt; 0) &#123; res.push_back(&quot;Fu&quot;); n = -n; &#125; int raw = n; if (n &gt;= 100000000) &#123; res.push_back(dicts[n / 100000000]); res.push_back(&quot;Yi&quot;); n = n % 100000000; &#125; bool zero = false; if (n &gt;= 10000) &#123; if (n / 10000000) &#123; res.push_back(dicts[n / 10000000]); res.push_back(&quot;Qian&quot;); n %= 10000000; &#125; else if (raw &gt; 10000000)&#123; zero = true; &#125; if (n / 1000000) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 1000000]); res.push_back(&quot;Bai&quot;); n %= 1000000; &#125; else if (raw &gt; 1000000) &#123; zero = true; &#125; if (n / 100000) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 100000]); res.push_back(&quot;Shi&quot;); n %= 100000; &#125; else if (raw &gt; 100000)&#123; zero = true; &#125; if (n / 10000) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 10000]); n %= 10000; &#125; res.push_back(&quot;Wan&quot;); &#125; zero = false; if (n / 1000) &#123; res.push_back(dicts[n / 1000]); res.push_back(&quot;Qian&quot;); n %= 1000; &#125; else if (raw &gt; 1000)&#123; zero = true; &#125; if (n / 100) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 100]); res.push_back(&quot;Bai&quot;); n %= 100; &#125; else if (raw &gt; 100)&#123; zero = true; &#125; if (n / 10) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 10]); res.push_back(&quot;Shi&quot;); n %= 10; &#125; else if (raw &gt; 10)&#123; zero = true; &#125; if (n % 10) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n % 10]); &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; ä¼˜åŒ– 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main() &#123; string nums[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; string wei[5] = &#123;&quot;Shi&quot;, &quot;Bai&quot;, &quot;Qian&quot;, &quot;Wan&quot;, &quot;Yi&quot;&#125;; string str; cin &gt;&gt; str; int len = str.length(); int left = 0, right = len - 1; if (str[0] == &#x27;-&#x27;) &#123; cout &lt;&lt; &quot;Fu&quot;; left++; &#125; while (left + 4 &lt;= right) right -= 4; while (left &lt; len) &#123; bool flag = false, isPrint = false; while (left &lt;= right) &#123; if (left &gt; 0 &amp;&amp; str[left] == &#x27;0&#x27;) flag = true; else &#123; if (flag == true) &#123; cout &lt;&lt; &quot; ling&quot;; flag = false; &#125; if (left &gt; 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; nums[str[left] - &#x27;0&#x27;]; isPrint = true; if (left != right) cout &lt;&lt; &quot; &quot; &lt;&lt; wei[right - left - 1]; &#125; left++; &#125; if (isPrint == true &amp;&amp; right != len - 1) cout &lt;&lt; &quot; &quot; &lt;&lt; wei[(len - 1 - right) / 4 + 2]; right += 4; &#125; return 0;&#125; 1083 List Grades1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; string name, num; int grade;&#125; nums[100001];bool cmp(node a, node b) &#123; return a.grade &gt; b.grade;&#125;int main() &#123; int n, left, right; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].name &gt;&gt; nums[i].num &gt;&gt; nums[i].grade; &#125; cin &gt;&gt; left &gt;&gt; right; sort(nums, nums + n, cmp); bool flag = true; for (int i = 0; i &lt; n; i++) &#123; if (nums[i].grade &gt;= left &amp;&amp; nums[i].grade &lt;= right) &#123; cout &lt;&lt; nums[i].name &lt;&lt; &quot; &quot; &lt;&lt; nums[i].num &lt;&lt; endl; flag = false; &#125; &#125; if (flag) cout &lt;&lt; &quot;NONE&quot;; return 0;&#125; 1084 Broken Keyboard12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool st[256];int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; a.size(); i++) &#123; if (isalpha(a[i])) a[i] = tolower(a[i]); st[a[i]] = true; &#125; for (int i = 0; i &lt; b.size(); i++) &#123; if (isalpha(b[i])) b[i] = tolower(b[i]); st[b[i]] = false; &#125; for (int i = 0; i &lt; a.size(); i++) &#123; if (st[a[i]]) &#123; char t = a[i]; if (isalpha(t)) t = toupper(t); cout &lt;&lt; t; st[a[i]] = false; &#125; &#125; return 0;&#125; æŸ³å©¼çš„ 1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string s1, s2, res; cin &gt;&gt; s1 &gt;&gt; s2; for (int i = 0; i &lt; s1.size(); i++) if (s2.find(s1[i]) == string::npos &amp;&amp; res.find(toupper(s1[i])) == string::npos) res += toupper(s1[i]); cout &lt;&lt; res; return 0;&#125; 1085 Perfect Sequenceæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL nums[100001], res = 1, p;void dfs(LL l, LL r) &#123; if (res &gt; r - l + 1) return; if (nums[l] * p &lt; nums[r]) &#123; dfs(l + 1, r); dfs(l, r - 1); &#125; else &#123; res = max(res, r - l + 1); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n &gt;&gt; p; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n); dfs(0, n - 1); cout &lt;&lt; res; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL nums[100001];int main() &#123; int n, p, res = 1; cin &gt;&gt; n &gt;&gt; p; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n); for (int i = 0; i &lt; n; i++) &#123; // res = max((int)(upper_bound(nums, nums + n, nums[i] * p) - (nums + i)), res); for (int j = i + res; j &lt; n; j++) &#123; if (nums[i] * p &gt;= nums[j]) &#123; res = max(res, j - i + 1); &#125; else break; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1086 Tree Traversals Again1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int l, r;&#125; trees[31];stack&lt;int&gt; st;vector&lt;int&gt; in, pre, post;int build(int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR) return -1; int root = in[inL], idx = preL; for (int i = preL; i &lt;= preR; i++) &#123; if (root == pre[i]) &#123; idx = i; break; &#125; &#125; int cntL = idx - preL; trees[root].l = build(preL, preL + cntL - 1, inL + 1, inL + cntL); trees[root].r = build(idx + 1, preR, inL + cntL + 1, inR); return root;&#125;void dfs(int root) &#123; if (root == -1) return; dfs(trees[root].l); dfs(trees[root].r); post.push_back(root);&#125;int main() &#123; int n, x; string ops; cin &gt;&gt; n; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ops; if (ops == &quot;Push&quot;) &#123; cin &gt;&gt; x; st.push(x); in.push_back(x); &#125; else &#123; pre.push_back(st.top()); st.pop(); &#125; &#125; int root = build(0, n - 1, 0, n - 1); dfs(root); for (int i = 0; i &lt; post.size(); i++) &#123; cout &lt;&lt; post[i]; if (i &lt; post.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;stack&lt;int&gt; st;vector&lt;int&gt; pre, in, post, value;void postorder(int root, int start, int end) &#123; if (start &gt; end) return; int i = start; while (i &lt; end &amp;&amp; in[i] != pre[root]) i++; postorder(root + 1, start, i - 1); postorder(root + 1 + i - start, i + 1, end); post.push_back(pre[root]);&#125;int main() &#123; int n, x, key = 0; string ops; cin &gt;&gt; n; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ops; if (ops == &quot;Push&quot;) &#123; cin &gt;&gt; x; value.push_back(x); pre.push_back(key); st.push(key++); &#125; else &#123; in.push_back(st.top()); st.pop(); &#125; &#125; postorder(0, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; value[post[i]]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1087 All Roads Lead to Rome123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 201;const int INF = 0x3f3f3f3f;map&lt;string, int&gt; strToInt;string intToStr[N], start;vector&lt;PII&gt; g[N];int d[N], haps[N], pre[N], cnt[N], happys[N], cnt2[N], n;bool visit[N];void dijkstra(int a) &#123; fill(d, d + n, INF); d[a] = 0; cnt2[a] = 1; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; d[j] &lt; mind) &#123; u = j; mind = d[j]; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first, dis = g[u][j].second; if (!visit[v]) &#123; if (d[v] &gt; d[u] + dis) &#123; d[v] = d[u] + dis; happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; cnt2[v] = cnt2[u]; pre[v] = u; &#125; else if (d[v] == d[u] + dis) &#123; if (happys[v] &lt; happys[u] + haps[v]) &#123; happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; pre[v] = u; &#125; else if (happys[v] == happys[u] + haps[v]) &#123; if (cnt[v] &gt; cnt[u] + 1) &#123; cnt[v] = cnt[u] + 1; pre[v] = u; &#125; &#125; cnt2[v] += cnt2[u]; &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; res;void dfs(int u) &#123; res.push_back(u); if (u == strToInt[start]) &#123; for (int i = res.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; intToStr[res[i]]; if (i &gt; 0) cout &lt;&lt; &quot;-&gt;&quot;; &#125; &#125; else &#123; dfs(pre[u]); &#125;&#125;int main() &#123; string city1, city2; int k, hap, cost; cin &gt;&gt; n &gt;&gt; k &gt;&gt; start; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; city1 &gt;&gt; hap; strToInt[city1] = i; intToStr[i] = city1; haps[i] = hap; &#125; strToInt[start] = n - 1; intToStr[n - 1] = start; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; cost; g[strToInt[city1]].push_back(&#123;strToInt[city2], cost&#125;); g[strToInt[city2]].push_back(&#123;strToInt[city1], cost&#125;); &#125; dijkstra(strToInt[start]); cout &lt;&lt; cnt2[strToInt[&quot;ROM&quot;]] &lt;&lt; &quot; &quot; &lt;&lt; d[strToInt[&quot;ROM&quot;]] &lt;&lt; &quot; &quot; &lt;&lt; happys[strToInt[&quot;ROM&quot;]] &lt;&lt; &quot; &quot; &lt;&lt; happys[strToInt[&quot;ROM&quot;]] / cnt[strToInt[&quot;ROM&quot;]] &lt;&lt; endl; dfs(strToInt[&quot;ROM&quot;]); return 0;&#125; 1088 Rational Arithmetic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b) &#123; if (b == 0) return a; return gcd(b, a % b);&#125;string convert(LL a, LL b) &#123; string res; if (b == 0) return &quot;Inf&quot;; LL tt = a; if (tt &lt; 0) res += &quot;(-&quot;; a = abs(a), b = abs(b); LL d = gcd(a, b); a /= d; b /= d; LL t = a / b; a -= t * b; if (t &amp;&amp; a) res += to_string(t) + &quot; &quot; + to_string(a) + &quot;/&quot; + to_string(b); else if(t &amp;&amp; a == 0) res += to_string(t); else if(t == 0 &amp;&amp; a) res += to_string(a) + &quot;/&quot; + to_string(b); else res += &quot;0&quot;; if (tt &lt; 0) res += &quot;)&quot;; return res;&#125;string add(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * b2 + a2 * b1; b = b1 * b2; return convert(a, b);&#125;string sub(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * b2 - a2 * b1; b = b1 * b2; return convert(a, b);&#125;string mul(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * a2; b = b1 * b2; return convert(a, b);&#125;string div(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * b2; b = b1 * a2; if (b &lt; 0) a = -a, b = -b; return convert(a, b);&#125;int main() &#123; LL a1, b1, a2, b2; scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;b1, &amp;a2, &amp;b2); cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; + &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; add(a1, b1, a2, b2) &lt;&lt; endl; cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; - &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; sub(a1, b1, a2, b2) &lt;&lt; endl; cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; * &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; mul(a1, b1, a2, b2) &lt;&lt; endl; cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; / &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; div(a1, b1, a2, b2) &lt;&lt; endl; return 0;&#125; 1089 Insert or Merge123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 101;int nums[N], now[N], tmp[N], tmp2[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; now[i]; int id = 0; for (int i = 0; i &lt; n - 1; i++) &#123; if (now[i + 1] &lt; now[i]) &#123; id = i; break; &#125; &#125; bool isInsert = true; for (int j = id + 1; j &lt; n; j++) &#123; if (nums[j] != now[j]) &#123; isInsert = false; break; &#125; &#125; if (isInsert) &#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(nums, nums + id + 2); &#125; else &#123; cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl; bool flag = true; int k = 1; while (flag) &#123; flag = false; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] != now[i]) flag = true; &#125; k *= 2; for (int i = 0; i &lt; n / k; i++) sort(nums + i * k, nums + (i + 1) * k); sort(nums + n / k * k, nums + n); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1090 Highest Price in Supply Chain123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; g[100001];int cnt[100001], res = 0;void dfs(int n, int t) &#123; if (res &lt; t) &#123; res = t; cnt[t] = 1; &#125; else cnt[t]++; for (int i = 0; i &lt; g[n].size(); i++) &#123; dfs(g[n][i], t + 1); &#125;&#125;int main() &#123; int n, x; double p, r; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (x == -1) &#123; g[n].push_back(i); &#125; else &#123; g[x].push_back(i); &#125; &#125; dfs(n, 0); for (int i = 0; i &lt; res - 1; i++) &#123; p *= (100 + r) / 100.0; &#125; printf(&quot;%.2f %d&quot;, p, cnt[res]); return 0;&#125; 1091 Acute Stroke123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int g[61][1287][129], m, n, l, t;bool v[61][1287][129];struct node &#123; int i, j, k;&#125;;int x[6] = &#123;1, -1, 0, 0, 0, 0&#125;;int y[8] = &#123;0, 0, 1, -1, 0, 0&#125;;int z[8] = &#123;0, 0, 0, 0, 1, -1&#125;;int bfs(int i, int j, int k) &#123; v[i][j][k] = true; int cnt = 1; queue&lt;node&gt; q; q.push(&#123;i, j, k&#125;); while (!q.empty()) &#123; node u = q.front(); q.pop(); i = u.i, j = u.j, k = u.k; for (int id = 0; id &lt; 6; id++) &#123; int a = i + x[id], b = j + y[id], c = k + z[id]; if (a &gt;= 0 &amp;&amp; a &lt; l &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; n &amp;&amp; !v[a][b][c] &amp;&amp; g[a][b][c] == 1) &#123; cnt++; v[a][b][c] = true; q.push(&#123;a, b, c&#125;); &#125; &#125; &#125; if (cnt &lt; t) return 0; else return cnt;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; t; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; scanf(&quot;%d&quot;, &amp;g[i][j][k]); &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; if (!v[i][j][k] &amp;&amp; g[i][j][k]) &#123; res += bfs(i, j, k); &#125; &#125; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1092 To Buy or Not to Buy1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int nums[256];int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; a.size(); i++) &#123; nums[a[i]]++; &#125; bool flag = true; int cnt = 0; for (int i = 0; i &lt; b.size(); i++) &#123; if (nums[b[i]] &lt;= 0) &#123; flag = false; cnt++; &#125; nums[b[i]]--; &#125; if (flag) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; a.size() - b.size(); else cout &lt;&lt; &quot;No &quot; &lt;&lt; cnt; return 0;&#125; 1093 Count PATâ€™s1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() &#123; string str; cin &gt;&gt; str; int res = 0; for (int i = 1; i &lt; str.size(); i++) &#123; p[i] = p[i - 1]; if (str[i - 1] == &#x27;P&#x27;) p[i]++; &#125; for (int i = str.size() - 1; i &gt;= 0; i--) &#123; t[i] = t[i + 1]; if (str[i + 1] == &#x27;T&#x27;) t[i]++; &#125; for (int i = 1; i &lt; str.size() - 1; i++) &#123; if (str[i] == &#x27;A&#x27;) &#123; res = (res + p[i] * t[i] % MOD) % MOD; &#125; &#125; cout &lt;&lt; res; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() &#123; string s; cin &gt;&gt; s; int res = 0, len = s.size(), p = 0, t = 0; for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;T&#x27;) t++; &#125; for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;P&#x27;) p++; if (s[i] == &#x27;T&#x27;) t--; if (s[i] == &#x27;A&#x27;) res = (res + p * t % MOD) % MOD; &#125; cout &lt;&lt; res; return 0;&#125; 1094 The Largest Generation1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; trees[101];int res, cntn;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); int depth = 1; while (!q.empty()) &#123; int cnt = q.size(); for (int i = 0; i &lt; cnt; i++) &#123; u = q.front(); q.pop(); for (int j = 0; j &lt; trees[u].size(); j++) &#123; q.push(trees[u][j]); &#125; &#125; if (cntn &lt; cnt) &#123; res = depth; cntn = cnt; &#125; depth++; &#125; return;&#125;int main() &#123; int n, m, id, k, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; x; trees[id].push_back(x); &#125; &#125; bfs(1); cout &lt;&lt; cntn &lt;&lt; &quot; &quot; &lt;&lt; res; return 0;&#125; 1095 Cars on Campus1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int time; string op;&#125;;bool cmp(node a, node b) &#123; return a.time &lt; b.time;&#125;map&lt;string, int&gt; strToInt;map&lt;int, string&gt; intToStr;vector&lt;node&gt; nums[10001], finall;int times[86401];int main() &#123; string a, op; int n, k, h, m, s, id = 1; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; if (!strToInt[a]) &#123; strToInt[a] = id; intToStr[id++] = a; &#125; scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); cin &gt;&gt; op; int time = h * 60 * 60 + m * 60 + s; nums[strToInt[a]].push_back(&#123;time, op&#125;); &#125; int total[id + 1]; for (int i = 1; i &lt; id; i++) &#123; sort(nums[i].begin(), nums[i].end(), cmp); for (int j = 0; j &lt; nums[i].size() - 1; j++) &#123; if (nums[i][j].op == &quot;in&quot; &amp;&amp; nums[i][j + 1].op == &quot;out&quot;) &#123; finall.push_back(nums[i][j]); finall.push_back(nums[i][j + 1]); total[i] += nums[i][j + 1].time - nums[i][j].time; &#125; &#125; &#125; sort(finall.begin(), finall.end(), cmp); int t = 0; for (int i = 0; i &lt;= 86400; i++) &#123; if (i != 0) times[i] = times[i - 1]; while (finall[t].time == i) &#123; if (finall[t].op == &quot;in&quot;) times[i]++; else times[i]--; t++; if (t == finall.size()) break; &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); int time = h * 60 * 60 + m * 60 + s; cout &lt;&lt; times[time] &lt;&lt; endl; &#125; int maxTime = 0; vector&lt;string&gt; res; for (int i = 0; i &lt; id; i++) &#123; if (maxTime &lt; total[i]) &#123; maxTime = total[i]; res.clear(); res.push_back(intToStr[i]); &#125; else if (maxTime == total[i]) &#123; res.push_back(intToStr[i]); &#125; &#125; for (auto it: res) &#123; cout &lt;&lt; it &lt;&lt; &quot; &quot;; &#125; h = maxTime / 3600, m = maxTime % 3600 / 60, s = maxTime % 60; printf(&quot;%02d:%02d:%02d&quot;, h, m, s); return 0;&#125; 1096 Consecutive Factors1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;int main() &#123; LL n, t; cin &gt;&gt; n; int l = 0, j = 0, res = 0; for (int i = 2; i &lt; sqrt(n) + 1; i++) &#123; t = 1; for (j = i; j &lt; sqrt(n) + 1; j++) &#123; t *= j; if (n % t != 0) break; &#125; if (j - i &gt; l) &#123; l = j - i; res = i; &#125; &#125; if (l == 0) cout &lt;&lt; &quot;1 &quot; &lt;&lt; n; else &#123; cout &lt;&lt; l &lt;&lt; endl; for (int k = res; k &lt; l + res; k++) &#123; cout &lt;&lt; k; if (k &lt; l + res - 1) cout &lt;&lt; &quot;*&quot;; &#125; &#125; return 0;&#125; 1097 Deduplication on a Linked List123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 100001;struct node &#123; int add, key, nex;&#125; nums[N];bool st[N];int main() &#123; int start, n, add, key, nex; cin &gt;&gt; start &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; key &gt;&gt; nex; nums[add] = &#123;add, key, nex&#125;; &#125; vector&lt;node&gt; list, red; while (start != -1) &#123; if (!st[abs(nums[start].key)]) &#123; list.push_back(nums[start]); st[abs(nums[start].key)] = true; &#125; else &#123; red.push_back(nums[start]); &#125; start = nums[start].nex; &#125; if (!list.empty()) &#123; for (int i = 0; i &lt; list.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, list[i].add, list[i].key, list[i + 1].add); &#125; printf(&quot;%05d %d -1 &quot;, list[list.size() - 1].add, list[list.size() - 1].key); &#125; if (!red.empty()) &#123; for (int i = 0; i &lt; red.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, red[i].add, red[i].key, red[i + 1].add); &#125; printf(&quot;%05d %d -1 &quot;, red[red.size() - 1].add, red[red.size() - 1].key); &#125; return 0;&#125; 1098 Insertion or Heap Sorté”™è¯¯ç­”æ¡ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 101;int a[N], b[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; b[i]; &#125; int id = 0; for (int i = 1; i &lt; n; i++) &#123; if (b[i] &gt;= b[i - 1]) id = i; else break; &#125; bool isInsert = true; for (int j = id + 1; j &lt; n; j++) &#123; if (a[j] != b[j]) &#123; isInsert = false; break; &#125; &#125; if (isInsert) &#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(b, b + id + 2); &#125; else &#123; cout &lt;&lt; &quot;Heap Sort&quot; &lt;&lt; endl; int i = 0, t = b[0]; while(2 * i + 1 &lt; n) &#123; if (b[2 * i + 1] &gt; b[2 * i + 2]) swap(b[2 * i + 1], b[2 * i + 2]); if (b[i] &gt; b[2 * i + 2]) &#123; swap(b[i], b[2 * i + 2]); i = 2 * i + 2; &#125; else if (b[i] &gt; b[2 * i + 1]) &#123; swap(b[i], b[2 * i + 1]); i = 2 * i + 1; &#125; else &#123; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; b[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void down(vector&lt;int&gt; &amp;b, int low, int high) &#123; int i = 1, j = i * 2; while (j &lt;= high) &#123; if (j + 1 &lt;= high &amp;&amp; b[j] &lt; b[j + 1]) j = j + 1; if (b[i] &gt;= b[j]) break; swap(b[i], b[j]); i = j; j = i * 2; &#125;&#125;int main() &#123; int n, p = 2; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1), b(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; while (p &lt;= n &amp;&amp; b[p - 1] &lt;= b[p]) p++; int idx = p; while (p &lt;= n &amp;&amp; a[p] == b[p]) p++; if (p == n + 1) &#123; cout &lt;&lt; &quot;Insertion Sort &quot;; sort(b.begin() + 1, b.begin() + idx + 1); &#125; else &#123; cout &lt;&lt; &quot;Heap Sort &quot;; p = n; while(p &gt; 2 &amp;&amp; b[p] &gt;= b[1]) p--; swap(b[1], b[p]); down(b, 1, p - 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; b[i]; if (i &lt; n) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1099 Build A Binary Search Tree123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int N = 101;struct node &#123; int data, l, r;&#125; a[N];int b[N], cnt;vector&lt;int&gt; res;void dfs(int root) &#123; if (root == -1) return; dfs(a[root].l); a[root].data = b[cnt++]; dfs(a[root].r);&#125;void bfs(int root) &#123; queue&lt;int&gt; q; q.push(root); while (!q.empty()) &#123; root = q.front(); q.pop(); res.push_back(a[root].data); if (a[root].l != -1) q.push(a[root].l); if (a[root].r != -1) q.push(a[root].r); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].l &gt;&gt; a[i].r; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; sort(b, b + n); dfs(0); bfs(0); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; res[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1100 Mars Numbers123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n; string x; string shi[12] = &#123;&quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;&#125;; string ge[12] = &#123;&quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;&#125;; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) &#123; getline(cin, x); if (x == &quot;0&quot;) cout &lt;&lt; &quot;tret&quot; &lt;&lt; endl; else if (isdigit(x[0])) &#123; int t = stoi(x); int a = t / 13; int b = t % 13; if (a &amp;&amp; b) cout &lt;&lt; shi[a - 1] &lt;&lt; &quot; &quot; &lt;&lt; ge[b - 1] &lt;&lt; endl; else if (a) cout &lt;&lt; shi[a - 1] &lt;&lt; endl; else if (b) cout &lt;&lt; ge[b - 1] &lt;&lt; endl; &#125; else &#123; if (x == &quot;tret&quot;) cout &lt;&lt; 0 &lt;&lt; endl; else if (x.size() &gt; 3) &#123; int a = 0; for (int i = 0; i &lt; 12; i++) &#123; if (x.substr(0, 3) == shi[i]) a += (i + 1) * 13; if (x.substr(4, 3) == ge[i]) a += i + 1; &#125; cout &lt;&lt; a &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 12; i++) &#123; if (x == shi[i]) cout &lt;&lt; (i + 1) * 13 &lt;&lt; endl; if (x == ge[i]) cout &lt;&lt; i + 1 &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; 1101 Quick Sort12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;const int INF = 0x3f3f3f3f;int nums[N], minr[N], maxl[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; fill(minr, minr + n, INF); for (int i = 1; i &lt; n; i++) &#123; maxl[i] = max(maxl[i - 1], nums[i - 1]); &#125; for (int i = n - 2; i &gt;= 0; i--) &#123; minr[i] = min(minr[i + 1], nums[i + 1]); &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] &gt;= maxl[i] &amp;&amp; nums[i] &lt;= minr[i]) &#123; res.push_back(nums[i]); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int v[100001];int main() &#123; int n, max = 0, cnt = 0; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(a.begin(), a.end()); for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i] &amp;&amp; b[i] &gt; max) v[cnt++] = b[i]; if (b[i] &gt; max) max = b[i]; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; v[i]; if (i &lt; cnt - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1102 Invert a Binary Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int l, r;&#125; trees[11];bool st[11];vector&lt;int&gt; level, in;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; u = q.front(); level.push_back(u); q.pop(); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); &#125;&#125;void dfs(int u) &#123; if (u == -1) return; dfs(trees[u].l); in.push_back(u); dfs(trees[u].r);&#125;int main() &#123; int n, root; char a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (isdigit(a)) &#123; trees[i].r = a - &#x27;0&#x27;; st[a - &#x27;0&#x27;] = true; &#125; else &#123; trees[i].r = -1; &#125; if (isdigit(b)) &#123; trees[i].l = b - &#x27;0&#x27;; st[b - &#x27;0&#x27;] = true; &#125; else &#123; trees[i].l = -1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) root = i; &#125; bfs(root); dfs(root); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; level[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; in[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1103 Integer Factorizationdfs 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; res, tmp, v;int n, k, p, t, m, sumt, mint = -1;void dfs(int idx, int a) &#123; if (a == k &amp;&amp; t == n) &#123; if (sumt &gt; mint) &#123; mint = sumt; res = tmp; &#125; return; &#125; if (a &gt;= k || t &gt;= n) return; for (int i = idx; i &gt;= 0; i--) &#123; t += v[i]; sumt += i; tmp.push_back(i + 1); dfs(i, a + 1); tmp.pop_back(); sumt -= i; t -= v[i]; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; for (int i = 1; i &lt;= n; i++) &#123; int b = pow(i, p); v.push_back(b); if (b &gt; n) break; &#125; dfs(v.size() - 1, 0); if (mint == -1) cout &lt;&lt; &quot;Impossible&quot;; else &#123; cout &lt;&lt; n &lt;&lt; &quot; = &quot;; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i] &lt;&lt; &quot;^&quot; &lt;&lt; p; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; + &quot;; &#125; &#125; return 0;&#125; 1104 Sum of Number Segmentsç²¾åº¦é—®é¢˜ï¼ˆå‘ï¼‰ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;const int N = 100001;double nums[N];int n;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; long long res = 0; for (int i = 0; i &lt; n; i++) &#123; res += (long long)(nums[i] * 1000) * i * (n - i + 1); &#125; printf(&quot;%.2f&quot;, res / 1000.0); return 0;&#125; æŸ³å©¼çš„ 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; double tmp; long long res; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; res += (long long)(tmp * 1000) * i * (n - i + 1); &#125; printf(&quot;%.2f&quot;, res / 1000.0); return 0;&#125; 1105 Spiral Matrix1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int nums[10001], id, res[100][100];int main() &#123; int t, n, m, mi = 10001; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + t, greater&lt;int&gt;()); for (int i = 1; i * i &lt;= t; i++) &#123; if (t % i == 0) n = i; &#125; m = t / n; int l = 0, r = n - 1, u = 0, d = m - 1; while (l &lt;= r &amp;&amp; u &lt;= d) &#123; for (int i = l; i &lt;= r; i++) res[u][i] = nums[id++]; u++; if (u &gt; d) break; for (int i = u; i &lt;= d; i++) res[i][r] = nums[id++]; r--; if (r &lt; l) break; for (int i = r; i &gt;= l; i--) res[d][i] = nums[id++]; d--; if (u &gt; d) break; for (int i = d; i &gt;= u; i--) res[i][l] = nums[id++]; l++; if (l &gt; r) break; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; res[i][j]; if (j &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1106 Lowest Price in Supply Chain123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; trees[100001];int depth = 1, cnt = 0;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); bool flag = false; while (!q.empty()) &#123; int size = q.size(); cnt = 0; for (int i = 0; i &lt; size; i++) &#123; u = q.front(); q.pop(); if (trees[u].empty()) &#123; flag = true; cnt++; &#125; for (int i = 0; i &lt; trees[u].size(); i++) &#123; q.push(trees[u][i]); &#125; &#125; if (flag) return; depth++; &#125;&#125;int main() &#123; int n, k, x; double p, r; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; x; trees[i].push_back(x); &#125; &#125; bfs(0); printf(&quot;%.4f %d&quot;, p * pow(1 + r / 100, depth - 1), cnt); return 0;&#125; 1107 Social Clusters123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n, cnt = 0; string x; double sum, t; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; try &#123; t = stod(x); if (t &gt; 1000 || t &lt; -1000) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; int j = 0; bool flag = true; while (j &lt; x.size() &amp;&amp; x[j] != &#x27;.&#x27;) j++; if (j != x.size() &amp;&amp; j + 3 &lt; x.size()) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; if (flag) &#123; cnt++; sum += t; &#125; &#125; catch(exception) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; &#125; &#125; if (cnt == 0) cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum); else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt); return 0;&#125; 1108 Finding Average1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n, cnt = 0; string x; double sum, t; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; try &#123; t = stod(x); if (t &gt; 1000 || t &lt; -1000) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; int j = 0; bool flag = true; while (j &lt; x.size() &amp;&amp; x[j] != &#x27;.&#x27;) j++; if (j != x.size() &amp;&amp; j + 3 &lt; x.size()) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; if (flag) &#123; cnt++; sum += t; // cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl; &#125; &#125; catch(exception) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; &#125; &#125; if (cnt == 0) cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum); else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt); return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int n, cnt = 0; char a[50], b[50]; double t, sum; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; sscanf(a, &quot;%lf&quot;, &amp;t); sprintf(b, &quot;%.2f&quot;, t); bool flag = false; for (int j = 0; j &lt; strlen(a); j++) if (a[j] != b[j]) flag = true; if (flag || t &lt; -1000 || t &gt; 1000) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; a &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; else &#123; sum += t; cnt++; &#125; &#125; if (cnt == 0) cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum); else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt); return 0;&#125; 1109 Group Photo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;string, int&gt; PII;PII nums[10001];bool cmp(PII a, PII b) &#123; if (a.second != b.second) return a.second &gt; b.second; return a.first &lt; b.first;&#125;void fun(int start, int n) &#123; if (n % 2 == 0) &#123; for (int i = n - 1; i &gt;= 1; i-=2) &#123; cout &lt;&lt; nums[start + i].first &lt;&lt; &quot; &quot;; &#125; for (int i = 0; i &lt; n; i+=2) &#123; cout &lt;&lt; nums[start + i].first; if (i + 2 == n) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125; else &#123; for (int i = n - 2; i &gt;= 1; i-=2) &#123; cout &lt;&lt; nums[start + i].first &lt;&lt; &quot; &quot;; &#125; for (int i = 0; i &lt; n; i+=2) &#123; cout &lt;&lt; nums[start + i].first; if (i + 1 == n) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;int main() &#123; int n, k, height; string name; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; height; nums[i] = &#123;name, height&#125;; &#125; sort(nums, nums + n, cmp); int num = n / k; int last = n - num * k + num; fun(0, last); for (int j = 1; j &lt; k; j++) &#123; fun(last + (j - 1) * num, num); &#125; return 0;&#125; 1110 Complete Binary Treebfs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int l = -1, r = -1;&#125; nums[100];bool st[100], isCBT = true, flag;int bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); int cnt = 1, a = 0; while(!q.empty()) &#123; u = q.front(); q.pop(); if (nums[u].l != -1) &#123; q.push(nums[u].l); if (flag) isCBT = false; &#125; else flag = true; if (nums[u].r != -1) &#123; q.push(nums[u].r); if (flag) isCBT = false; &#125; else flag = true; &#125; return u;&#125;int main() &#123; int n, root = 0; string l, r; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; l &gt;&gt; r; if (l != &quot;-&quot;) &#123; nums[i].l = stoi(l); st[stoi(l)] = true; &#125; if (r != &quot;-&quot;) &#123; nums[i].r = stoi(r); st[stoi(r)] = true; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) root = i; &#125; int last = bfs(root); if (!isCBT) cout &lt;&lt; &quot;NO &quot; &lt;&lt; root; else cout &lt;&lt; &quot;YES &quot; &lt;&lt; last; return 0;&#125; dfs 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int l = -1, r = -1;&#125; nums[100];bool st[100];int maxn = -1, last;void dfs(int root, int index) &#123; if (maxn &lt; index) &#123; maxn = index; last = root; &#125; if (nums[root].l != -1) dfs(nums[root].l, index * 2); if (nums[root].r != -1) dfs(nums[root].r, index * 2 + 1);&#125;int main() &#123; int n, root = 0; string l, r; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; l &gt;&gt; r; if (l != &quot;-&quot;) &#123; nums[i].l = stoi(l); st[stoi(l)] = true; &#125; if (r != &quot;-&quot;) &#123; nums[i].r = stoi(r); st[stoi(r)] = true; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) root = i; &#125; dfs(root, 1); if (maxn != n) cout &lt;&lt; &quot;NO &quot; &lt;&lt; root; else cout &lt;&lt; &quot;YES &quot; &lt;&lt; last; return 0;&#125; 1111 Online Mapdijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node&#123; int v, dist, time;&#125;;vector&lt;node&gt; g[N];int d[N], cost1[N], cost2[N], cnt[N], pre[N], start, dest, n;bool visit[N];void dijkstra1(int a) &#123; fill(d, d + N, INF); d[a] = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; mind = d[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (d[u] + dist &lt; d[v]) &#123; d[v] = d[u] + dist; cost1[v] = cost1[u] + time; pre[v] = u; &#125; else if (d[u] + dist == d[v]) &#123; if (cost1[v] &gt; cost1[u] + time)&#123; pre[v] = u; cost1[v] = cost1[u] + time; &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; res1;void dfs1(int x) &#123; if (x != start) &#123; res1.push_back(x); dfs1(pre[x]); &#125; else res1.push_back(start);&#125;void dijkstra2(int a) &#123; fill(cost2, cost2 + N, INF); fill(visit, visit + N, false); cost2[a] = 0; cnt[a] = 1; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; cost2[j]) &#123; mind = cost2[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (cost2[u] + time &lt; cost2[v]) &#123; cost2[v] = cost2[u] + time; cnt[v] = cnt[u] + 1; pre[v] = u; &#125; else if (cost2[u] + time == cost2[v]) &#123; if (cnt[v] &gt; cnt[u] + 1)&#123; pre[v] = u; cnt[v] = cnt[u] + 1; &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; res2;void dfs2(int x) &#123; if (x != start) &#123; res2.push_back(x); dfs2(pre[x]); &#125; else res2.push_back(start);&#125;int main() &#123; int m, v1, v2, one, len, time; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; one &gt;&gt; len &gt;&gt; time; g[v1].push_back(&#123;v2, len, time&#125;); if (!one) g[v2].push_back(&#123;v1, len, time&#125;); &#125; cin &gt;&gt; start &gt;&gt; dest; dijkstra1(start); dfs1(dest); dijkstra2(start); dfs2(dest); if (res1 == res2) &#123; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; d[dest] &lt;&lt; &quot;; Time = &quot; &lt;&lt; cost2[dest] &lt;&lt; &quot;: &quot;; for (int i = res1.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res1[i]; if (i &gt; 0) cout &lt;&lt; &quot; -&gt; &quot;; &#125; &#125; else &#123; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; d[dest] &lt;&lt; &quot;: &quot;; for (int i = res1.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res1[i]; if (i &gt; 0) cout &lt;&lt; &quot; -&gt; &quot;; else cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Time = &quot; &lt;&lt; cost2[dest] &lt;&lt; &quot;: &quot;; for (int i = res2.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res2[i]; if (i &gt; 0) cout &lt;&lt; &quot; -&gt; &quot;; &#125; &#125; return 0;&#125; 1112 Stucked Keyboard123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int st[257];int main() &#123; int k, i = 0; string a; cin &gt;&gt; k &gt;&gt; a; for (; i &lt;= a.size() - k; i++) &#123; char t = a[i]; bool flag = false; for (int j = i + 1; j &lt; i + k; j++) &#123; if (a[j] != t) &#123; flag = true; break; &#125; &#125; if (flag) st[t] = 1; else i += k - 1; &#125; for (; i &lt; a.size(); i++) &#123; st[a[i]] = 1; &#125; for (int i = 0; i &lt; a.size(); i++) &#123; if (!st[a[i]]) &#123; cout &lt;&lt; a[i]; st[a[i]] = 2; &#125; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; a.size(); i++) &#123; if (st[a[i]] == 1) cout &lt;&lt; a[i]; else if (st[a[i]] == 2) &#123; cout &lt;&lt; a[i]; i += k - 1; &#125; &#125; return 0;&#125; 1113 Integer Set Partition1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; sort(nums, nums + n); long long res = 0; for (int i = 0; i &lt; n / 2; i++) &#123; res += nums[n - i - 1] - nums[i]; &#125; if (n % 2 == 0) cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; res; else &#123; res += nums[n / 2]; cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; res; &#125; return 0;&#125; 1114 Family Property1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10001;struct node &#123; int fa, mo, set, area; vector&lt;int&gt; childs;&#125; nums[N];struct family &#123; int id, cnt; double set, area;&#125;;bool cmp(family &amp;a, family &amp;b) &#123; if (a.area != b.area) return a.area &gt; b.area; return a.id &lt; b.id;&#125;bool visit[N];int fa[N], cnt[N];set&lt;int&gt; ids, ids2, resid;int find(int x) &#123; if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];&#125;void union1(int a, int b) &#123; ids.insert(b); int fa1 = find(a); int fb = find(b); if (fa1 != fb) &#123; if (fa1 &lt; fb) fa[fb] = fa1; else fa[fa1] = fb; &#125;&#125;int main() &#123; int n, id, k, child; for (int i = 1; i &lt; N; i++) fa[i] = i; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id; ids.insert(id); ids2.insert(id); cin &gt;&gt; nums[id].fa &gt;&gt; nums[id].mo &gt;&gt; k; if (nums[id].fa != -1) union1(id, nums[id].fa); if (nums[id].mo != -1) union1(id, nums[id].mo); for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; child; nums[id].childs.push_back(child); union1(id, child); &#125; cin &gt;&gt; nums[id].set &gt;&gt; nums[id].area; &#125; for (auto id: ids) &#123; cnt[find(id)]++; resid.insert(find(id)); &#125; family tmp[N]; for (int i = 0; i &lt; N; i++) &#123; if (cnt[i]) tmp[i] = &#123;i, cnt[i], 0, 0&#125;; &#125; for (auto id: ids2) &#123; tmp[find(id)].set += nums[id].set; tmp[find(id)].area += nums[id].area; &#125; vector&lt;family&gt; res; for (auto id: resid) &#123; tmp[id].set /= tmp[id].cnt; tmp[id].area /= tmp[id].cnt; res.push_back(tmp[id]); &#125; sort(res.begin(), res.end(), cmp); cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%04d %d %.3f %.3f &quot;, res[i].id, res[i].cnt, res[i].set, res[i].area); &#125; return 0;&#125; 1115 Counting Nodes in a Binary Search Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int data, l = -1, r = -1;&#125; nums[1001];int idx = 0, last = 0, llast = 0;void insert(int x, int root) &#123; if (x &lt;= nums[root].data) &#123; if (nums[root].l == -1) &#123; nums[root].l = idx; nums[idx++].data = x; &#125; else insert(x, nums[root].l); &#125; else &#123; if (nums[root].r == -1) &#123; nums[root].r = idx; nums[idx++].data = x; &#125; else insert(x, nums[root].r); &#125;&#125;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; int size = q.size(); llast = last; last = size; for (int i = 0; i &lt; size; i++) &#123; u = q.front(); q.pop(); if (nums[u].l != -1) q.push(nums[u].l); if (nums[u].r != -1) q.push(nums[u].r); &#125; &#125;&#125;int main() &#123; int n, root, x; cin &gt;&gt; n &gt;&gt; root; nums[idx++].data = root; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x; insert(x, 0); &#125; bfs(0); cout &lt;&lt; last &lt;&lt; &quot; + &quot; &lt;&lt; llast &lt;&lt; &quot; = &quot; &lt;&lt; last + llast; return 0;&#125; 1116 Come on! Letâ€™s C12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int N = 10001;bool st[N], visit[N];map&lt;int, int&gt; nums;int main() &#123; for (int i = 2; i &lt; N; i++) &#123; if (!st[i]) &#123; for (int j = i * 2; j &lt; N; j += i) st[j] = true; &#125; &#125; int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; nums[x] = i; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (nums[x] == 0) &#123; printf(&quot;%04d: Are you kidding? &quot;, x); &#125; else if (visit[x]) &#123; printf(&quot;%04d: Checked &quot;, x); &#125; else &#123; if (nums[x] == 1) &#123; printf(&quot;%04d: Mystery Award &quot;, x); visit[x] = true; &#125; else if (!st[nums[x]]) &#123; printf(&quot;%04d: Minion &quot;, x); visit[x] = true; &#125; else &#123; printf(&quot;%04d: Chocolate &quot;, x); visit[x] = true; &#125; &#125; &#125; return 0;&#125; 1117 Eddington Number12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n, greater&lt;int&gt;()); int res = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i &gt;= nums[i - 1]) break; else res = i; &#125; cout &lt;&lt; res; return 0;&#125; 1118 Birds in Forest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 10001;int fa[N], cnt[N], maxb;set&lt;int&gt; birds;int find(int x) &#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;void union1(int a, int b) &#123; int faa = find(a); int fbb = find(b); if (faa != fbb) &#123; fa[fbb] = faa; &#125;&#125;int main() &#123; for (int i = 1; i &lt; N; i++) &#123; fa[i] = i; &#125; int n, k, x, y; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k &gt;&gt; x; maxb = max(maxb, x); for (int j = 1; j &lt; k; j++) &#123; cin &gt;&gt; y; maxb = max(maxb, y); union1(x, y); &#125; &#125; int mtree = 0; for (int i = 1; i &lt;= maxb; i++) &#123; if (find(i) == i) mtree++; &#125; cout &lt;&lt; mtree &lt;&lt; &quot; &quot; &lt;&lt; maxb &lt;&lt; endl; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if (fa[x] != fa[y]) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 1119 Pre- and Post-order Traversals12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 31;int pre[N], post[N];vector&lt;int&gt; in;bool flag = true;void getIn(int preleft, int preright, int postleft, int postright)&#123; if (preleft == preright) &#123; in.push_back(pre[preleft]); return; &#125; if (pre[preleft] == post[postright]) &#123; int i = preleft + 1; while (i &lt;= preright &amp;&amp; pre[i] != post[postright - 1]) i++; if (i - preleft &gt; 1) getIn(preleft + 1, i - 1, postleft, postleft + (i - preleft - 1) - 1); else flag = false; in.push_back(post[postright]); getIn(i, preright, postleft + (i - preleft - 1), postright - 1); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; getIn(0, n - 1, 0, n - 1); if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; for (int i = 0; i &lt; in.size(); i++) &#123; cout &lt;&lt; in[i]; if (i &lt; in.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return 0;&#125; 1120 Friend Numbers123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[40];int main() &#123; int n, x; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; int t = 0; while (x &gt; 0) &#123; t += x % 10; x /= 10; &#125; nums[t]++; &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; 40; i++) &#123; if (nums[i]) res.push_back(i); &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1121 Damn Single12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;int g[N], tmp[N];int main() &#123; fill(g, g + N, -1); fill(tmp, tmp + N, -1); int n, a, b, m, c; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a] = b; g[b] = a; &#125; cin &gt;&gt; m; vector&lt;int&gt; tmp1, res; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; c; if (g[c] == -1) res.push_back(c); else if (tmp[g[c]] == -1) &#123; tmp[g[c]] = 1; tmp1.push_back(c); &#125; &#125; for (auto i: tmp1) &#123; if (tmp[i] == -1) res.push_back(i); &#125; sort(res.begin(), res.end()); cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%05d&quot;, res[i]); if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1122 Hamiltonian Cycle1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, g[201][201];bool visit[201];bool check(int q) &#123; bool flag = true; if (q != n + 1) flag = false; fill(visit, visit + 201, false); int x, last, start; cin &gt;&gt; last; start = last; visit[start] = true; for (int i = 1; i &lt; q; i++) &#123; cin &gt;&gt; x; if (!g[last][x]) flag = false; visit[x] = true; last = x; &#125; if (start != last) flag = false; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) flag = false; &#125; return flag;&#125;int main() &#123; int m, a, b, k, q; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a][b] = 1; g[b][a] = 1; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; q; if (check(q)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n, m, cnt, k, a[201][201] = &#123;0&#125;; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int t1, t2; cin &gt;&gt; t1 &gt;&gt; t2; a[t1][t2] = a[t2][t1] = 1; &#125; cin &gt;&gt; cnt; while (cnt--) &#123; cin &gt;&gt; k; vector&lt;int&gt; v(k); set&lt;int&gt; s; int flag1 = 1, flag2 = 1; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; v[i]; s.insert(v[i]); &#125; if (s.size() != n || k - 1 != n || v[0] != v[k - 1]) flag1 = 0; for (int i = 0; i &lt; k - 1; i++) if (a[v[i]][v[i+1]] == 0) flag2 = 0; printf(&quot;%s&quot;, flag1 &amp;&amp; flag2 ? &quot;YES &quot; : &quot;NO &quot;); &#125; return 0;&#125; 1123 Is It a Complete AVL Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int val; node *left, *right;&#125;;node* rotateLeft(node* root) &#123; node *t = root-&gt;right; root-&gt;right = t-&gt;left; t-&gt;left = root; return t;&#125;node* rotateRight(node* root) &#123; node *t = root-&gt;left; root-&gt;left = t-&gt;right; t-&gt;right = root; return t;&#125;node* rotateLeftRight(node* root) &#123; root-&gt;left = rotateLeft(root-&gt;left); return rotateRight(root);&#125;node* rotateRightLeft(node* root) &#123; root-&gt;right = rotateRight(root-&gt;right); return rotateLeft(root);&#125;int getHeight(node* root) &#123; if (root == NULL) return 0; return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;&#125;node* insert(node* root, int val) &#123; if (root == NULL) &#123; root = new node(); root-&gt;val = val; root-&gt;left = NULL; root-&gt;right = NULL; &#125; else if (val &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, val); if (getHeight(root-&gt;left) - getHeight(root-&gt;right) == 2) &#123; root = val &lt; root-&gt;left-&gt;val ? rotateRight(root) : rotateLeftRight(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, val); if (getHeight(root-&gt;right) - getHeight(root-&gt;left) == 2) &#123; root = val &gt; root-&gt;right-&gt;val ? rotateLeft(root) : rotateRightLeft(root); &#125; &#125; return root;&#125;vector&lt;int&gt; res;bool bfs(node* u) &#123; queue&lt;node*&gt; q; q.push(u); int t = 1; bool flag1 = true, flag2 = true; while (!q.empty()) &#123; u = q.front(); q.pop(); if (u == NULL) flag1 = false; else &#123; if (!flag1) flag2 = false; res.push_back(u-&gt;val); q.push(u-&gt;left); q.push(u-&gt;right); &#125; &#125; return flag2;&#125;int main() &#123; int n, val; cin &gt;&gt; n; node * root = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; val; root = insert(root, val); &#125; int flag = bfs(root); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; if (flag) cout &lt;&lt; &quot;YES&quot;; else cout &lt;&lt; &quot;NO&quot;; return 0;&#125; 1124 Raffle for Weibo Followers12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;string nums[1001];map&lt;string, bool&gt; st;int main() &#123; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; nums[i]; &#125; bool flag = false; for (int i = s; i &lt;= m;) &#123; if (!st[nums[i]]) &#123; flag = true; st[nums[i]] = true; cout &lt;&lt; nums[i] &lt;&lt; endl; i += n; &#125; else i++; &#125; if (!flag) cout &lt;&lt; &quot;Keep going...&quot;; return 0;&#125; 1125 Chain the Ropes123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[10001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n); double res = nums[0]; for (int i = 1; i &lt; n; i++) &#123; res = (res + nums[i]) / 2; &#125; cout &lt;&lt; (int)res; return 0;&#125; 1126 Eulerian Path12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N = 501;int degree[N], g[N][N], n;bool visit[N];void dfs(int u) &#123; visit[u] = true; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i] &amp;&amp; g[u][i]) dfs(i); &#125;&#125;int main() &#123; int m, a, b; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; degree[a]++; degree[b]++; g[a][b] = g[b][a] = 1; &#125; int odd = 0; for (int i = 1; i &lt;= n; i++) &#123; if (degree[i] % 2) odd++; cout &lt;&lt; degree[i]; if (i &lt; n) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; dfs(a); for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) &#123; cout &lt;&lt; &quot;Non-Eulerian&quot;; return 0; &#125; &#125; if (odd == 0) cout &lt;&lt; &quot;Eulerian&quot;; else if (odd == 2) cout &lt;&lt; &quot;Semi-Eulerian&quot;; else cout &lt;&lt; &quot;Non-Eulerian&quot;; return 0;&#125; 1127 ZigZagging on a Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 31;struct node&#123; int l, r;&#125; trees[N];int in[N], post[N], n;int build(int leftIn, int rightIn, int leftPost, int rightPost) &#123; if (leftIn &gt; rightIn) return -1; int root = post[rightPost], id = leftIn; for (int i = leftIn; i &lt;= rightIn; i++) &#123; if (in[i] == root) id = i; &#125; int leftCnt = id - leftIn; trees[root].l = build(leftIn, id - 1,leftPost, leftPost + leftCnt - 1); trees[root].r = build(id + 1, rightIn, leftPost + leftCnt, rightPost - 1); return root;&#125;vector&lt;int&gt; res;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); int depth = 1; while (!q.empty()) &#123; int size = q.size(); vector&lt;int&gt; tmp; for (int i = 0; i &lt; size; i++) &#123; u = q.front(); q.pop(); tmp.push_back(u); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); &#125; if (depth % 2) for (int i = tmp.size() - 1; i &gt;= 0; i--) res.push_back(tmp[i]); else for (int i = 0; i &lt; tmp.size(); i++) res.push_back(tmp[i]); depth += 1; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1128 N Queens Puzzle1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1001;bool de[2*N], inde[2*N], row[N];int main() &#123; int n, k, x; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k; bool flag = true; memset(de, false, sizeof(de)); memset(inde, false, sizeof(inde)); memset(row, false, sizeof(row)); for (int j = 1; j &lt;= k; j++) &#123; cin &gt;&gt; x; if (de[x+j] || inde[-x+j+k] || row[x])flag = false; else de[x+j] = inde[-x+j+k] = row[x] = true; &#125; if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125;&#125; 1129 Recommendation Systemæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;map&lt;int, int&gt; nums;bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; if (a.second != b.second) return a.second &gt; b.second; return a.first &lt; b.first;&#125;int main() &#123; int n, k, x; cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; nums[x]++; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x; vector&lt;pair&lt;int, int&gt; &gt; t(nums.begin(), nums.end()); sort(t.begin(), t.end(), cmp); cout &lt;&lt; x &lt;&lt; &quot;:&quot;; for (int i = 0; i &lt; min(k, (int)t.size()); i++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; t[i].first; &#125; cout &lt;&lt; endl; nums[x]++; &#125; return 0;&#125; æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int nums[50001];struct node&#123; int num, val; bool operator &lt; (const node &amp;a) const &#123; if (val != a.val) return val &gt; a.val; return num &lt; a.num; &#125;&#125;;int main() &#123; int n, k, x; cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; nums[x]++; set&lt;node&gt; st; st.insert(&#123;x, nums[x]&#125;); for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x; cout &lt;&lt; x &lt;&lt; &quot;:&quot;; int j = 0; for (auto it = st.begin(); j &lt; k &amp;&amp; it != st.end(); it++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;num; j++; &#125; cout &lt;&lt; endl; auto t = st.find(&#123;x, nums[x]&#125;); if (t != st.end()) st.erase(t); nums[x]++; st.insert(&#123;x, nums[x]&#125;); &#125; return 0;&#125; 1130 Infix Expression123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct node &#123; string x; int l, r;&#125; trees[21];bool st[21];string dfs(int u) &#123; if (trees[u].l == -1 &amp;&amp; trees[u].r == -1) return trees[u].x; if (trees[u].l == -1 &amp;&amp; trees[u].r != -1) return &quot;(&quot; + trees[u].x + dfs(trees[u].r) + &quot;)&quot;; if (trees[u].l != -1 &amp;&amp; trees[u].r != -1) return &quot;(&quot; + dfs(trees[u].l) + trees[u].x + dfs(trees[u].r) + &quot;)&quot;;&#125;int main() &#123; int n, l, r, root; string x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; trees[i] = &#123;x, l, r&#125;; st[l] = st[r] = true; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!st[i]) root = i; &#125; string res = dfs(root); if (res[0] == &#x27;(&#x27;) res = res.substr(1, res.size() - 2); cout &lt;&lt; res; return 0;&#125; 1131 Subway Map1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 10001;unordered_map&lt;int, int&gt; line;vector&lt;int&gt; g[N], tmp, res;int dest, mind, mint, pre, pret;bool visit[N];int cnt() &#123; int cnt = -1, pre = 0; for (int i = 1; i &lt; tmp.size(); i++) &#123; if (line[tmp[i - 1] * 10000 + tmp[i]] != pre) cnt++; pre = line[tmp[i - 1] * 10000 + tmp[i]]; &#125; return cnt;&#125;void dfs(int u, int d) &#123; if (u == dest &amp;&amp; (mind &gt; d || mind == d &amp;&amp; mint &gt; cnt())) &#123; mind = d; mint = cnt(); res = tmp; &#125; if (u == dest) return; for (int i = 0; i &lt; g[u].size(); i++) &#123; if (!visit[g[u][i]]) &#123; visit[g[u][i]] = true; tmp.push_back(g[u][i]); dfs(g[u][i], d + 1); tmp.pop_back(); visit[g[u][i]] = false; &#125; &#125;&#125;int main() &#123; int n, k, x, y; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k &gt;&gt; x; for (int j = 1; j &lt; k; j++) &#123; cin &gt;&gt; y; g[x].push_back(y); g[y].push_back(x); line[x * 10000 + y] = line[y * 10000 + x] = i; x = y; &#125; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; dest; mind = 0x3f3f3f3f, mint = 0x3f3f3f3f, pre = 0, pret = x; tmp.clear(); tmp.push_back(x); visit[x] = true; dfs(x, 0); visit[x] = false; cout &lt;&lt; mind &lt;&lt; endl; for (int j = 1; j &lt; res.size(); j++) &#123; if (line[res[j - 1] * 10000 + res[j]] != pre) &#123; if (pre != 0) printf(&quot;Take Line#%d from %04d to %04d. &quot;, pre, pret, res[j - 1]); pre = line[res[j - 1] * 10000 + res[j]]; pret = res[j - 1]; &#125; &#125; printf(&quot;Take Line#%d from %04d to %04d. &quot;, pre, pret, dest); &#125; return 0;&#125; 1132 Cut Integer1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string z; cin &gt;&gt; z; int c = stoi(z); int a = stoi(z.substr(0, z.size() / 2)); int b = stoi(z.substr(z.size() / 2)); if (a * b == 0 || c % (a * b)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 1133 Splitting A Linked List123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int add, val, nex;&#125; nums[100001];vector&lt;int&gt; res1, res2, res3, res;int main() &#123; int start, n, k, add, val, nex; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; val &gt;&gt; nex; nums[add] = &#123;add, val, nex&#125;; &#125; int t = start; while (t != -1) &#123; if (nums[t].val &lt; 0) res1.push_back(t); else if (nums[t].val &lt;= k) res2.push_back(t); else res3.push_back(t); t = nums[t].nex; &#125; for (auto it: res1) res.push_back(it); for (auto it: res2) res.push_back(it); for (auto it: res3) res.push_back(it); for (int i = 0; i &lt; res.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); &#125; printf(&quot;%05d %d -1&quot;, nums[res[res.size() - 1]].add, nums[res[res.size() - 1]].val); return 0;&#125; 1134 Vertex Cover12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int N = 10001;vector&lt;int&gt; g[N];set&lt;int&gt; res;int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(b); g[b].push_back(a); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; res.clear(); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a; for (int i = 0; i &lt; g[a].size(); i++) &#123; if (a &lt; g[a][i]) res.insert(a * 10000 + g[a][i]); else res.insert(g[a][i] * 10000 + a); &#125; &#125; if (res.size() == m) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; æŸ³å©¼çš„ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 10001;vector&lt;int&gt; g[N];bool st[N];int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(i); g[b].push_back(i); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; fill(st, st + N, false); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a; for (int i = 0; i &lt; g[a].size(); i++) st[g[a][i]] = true; &#125; bool flag = true; for (int j = 0; j &lt; m; j++) &#123; if (!st[j]) &#123; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1135 Is It A Red-Black Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;struct node &#123; int val; node *l, *r;&#125;;node* build(node* root, int val) &#123; if (root == NULL) &#123; root = new node(); root-&gt;val = val; root-&gt;l = root-&gt;r = NULL; &#125; else if (abs(val) &lt;= abs(root-&gt;val)) &#123; root-&gt;l = build(root-&gt;l, val); &#125; else root-&gt;r = build(root-&gt;r, val); return root;&#125;bool judge1(node* root) &#123; if (root == NULL) return true; if (root-&gt;val &lt; 0) &#123; if (root-&gt;l != NULL &amp;&amp; root-&gt;l-&gt;val &lt; 0) return false; if (root-&gt;r != NULL &amp;&amp; root-&gt;r-&gt;val &lt; 0) return false; &#125; return judge1(root-&gt;l) &amp;&amp; judge1(root-&gt;r);&#125;int getnum(node* root) &#123; if (root == NULL) return 0; int l = getnum(root-&gt;l); int r = getnum(root-&gt;r); if (root-&gt;val &gt; 0) return max(l, r) + 1; else return max(l, r);&#125;bool judge2(node* root) &#123; if (root == NULL) return true; int l = getnum(root-&gt;l); int r = getnum(root-&gt;r); if (l != r) return false; return judge2(root-&gt;l) &amp;&amp; judge2(root-&gt;r);&#125;int main() &#123; int k, n, x, start; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; node* root = NULL; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; x; if (j == 0) start = x; root = build(root, x); &#125; if (start &lt; 0 || !judge1(root) || !judge2(root)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 1136 A Delayed Palindrome1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool check(string s) &#123; for (int i = 0; i &lt; s.size() / 2; i++) &#123; if (s[i] != s[s.size() - i - 1]) return false; &#125; return true;&#125;string add(string a, string b) &#123; if (a.size() &lt; b.size()) swap(a, b); string res = &quot;&quot;; int i, t = 0; for (i = 0; i &lt; b.size(); i++) &#123; t = a[a.size() - i - 1] - &#x27;0&#x27; + b[b.size() - i - 1] - &#x27;0&#x27; + t; res += (t % 10) + &#x27;0&#x27;; t /= 10; &#125; for (; i &lt; a.size(); i++) &#123; t = a[a.size() - i - 1] - &#x27;0&#x27; + t; res += (t % 10) + &#x27;0&#x27;; t /= 10; &#125; if (t) res += &#x27;1&#x27;; reverse(res.begin(), res.end()); return res;&#125;int main() &#123; string a; int cnt = 0; cin &gt;&gt; a; while(!check(a) &amp;&amp; cnt &lt; 10) &#123; string b = a; reverse(a.begin(), a.end()); string c = add(a, b); cout &lt;&lt; b &lt;&lt; &quot; + &quot; &lt;&lt; a &lt;&lt; &quot; = &quot; &lt;&lt; c &lt;&lt; endl; a = c; cnt++; &#125; if (check(a)) cout &lt;&lt; a &lt;&lt; &quot; is a palindromic number.&quot;; else cout &lt;&lt; &quot;Not found in 10 iterations.&quot;; return 0;&#125; 1137 Final Grading12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;struct node &#123; string id; int gp, gm, gf, g;&#125;;vector&lt;node&gt; nums;map&lt;string, int&gt; mgp;map&lt;string, int&gt; mgm;map&lt;string, int&gt; mgf;set&lt;string&gt; ids;bool cmp(node &amp;a, node &amp;b) &#123; if (a.g != b.g) return a.g &gt; b.g; else return a.id &lt; b.id;&#125;int main() &#123; int p, m, n, g; string id; cin &gt;&gt; p &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; p; i++) &#123; cin &gt;&gt; id &gt;&gt; g; mgp[id] = g; ids.insert(id); &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id &gt;&gt; g; mgm[id] = g; ids.insert(id); &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id &gt;&gt; g; mgf[id] = g; ids.insert(id); &#125; for (auto id: ids) &#123; if (mgp[id] &gt;= 200) &#123; if(mgm.find(id) == mgm.end()) mgm[id] = -1; if (mgm[id] &gt; mgf[id]) g = mgm[id] * 0.4 + mgf[id] * 0.6 + 0.5; else g = mgf[id]; if (g &gt;= 60) &#123; nums.push_back(&#123;id, mgp[id], mgm[id], mgf[id], g&#125;); &#125; &#125; &#125; sort(nums.begin(), nums.end(), cmp); for (auto it: nums) &#123; cout &lt;&lt; it.id &lt;&lt; &quot; &quot; &lt;&lt; it.gp &lt;&lt; &quot; &quot; &lt;&lt; it.gm &lt;&lt; &quot; &quot; &lt;&lt; it.gf &lt;&lt; &quot; &quot; &lt;&lt; it.g &lt;&lt; endl; &#125; return 0;&#125; 1138 Postorder Traversal12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 50001;int pre[N], in[N];bool flag;void build(int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR || flag) return; int root = pre[preL], id = inL; for (int i = inL; i &lt;= inR; i++) &#123; if (root == in[i]) &#123; id = i; break; &#125; &#125; int cntL = id - inL; build(preL + 1, preL + cntL, inL, id - 1); build(preL + cntL + 1, preR, id + 1, inR); if (!flag) &#123; cout &lt;&lt; root &lt;&lt; endl; flag = true; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; build(0, n - 1, 0, n - 1); return 0;&#125; 1139 First Contactæ²¡è€ƒè™‘-0000 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; g[20001];bool visit[20001];int main() &#123; int n, m, k, a, b; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &lt; 0) a += 20000; if (b &lt; 0) b += 20000; g[a].push_back(b); g[b].push_back(a); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; fill(visit, visit + 20001, false); if (a &lt; 0) a += 20000; if (b &lt; 0) b += 20000; visit[a] = visit[b] = true; vector&lt;pair&lt;int, int&gt; &gt; res; if (a &lt; 10000 &amp;&amp; b &lt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &lt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &lt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;g[a][j], g[g[a][j]][p]&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; else if (a &gt; 10000 &amp;&amp; b &lt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &gt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &lt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;-g[a][j] + 20000, g[g[a][j]][p]&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; else if (a &lt; 10000 &amp;&amp; b &gt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &lt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &gt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;g[a][j], -g[g[a][j]][p] + 20000&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; else if (a &gt; 10000 &amp;&amp; b &gt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &gt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &gt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;-g[a][j] + 20000, -g[g[a][j]][p] + 20000&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%04d %04d &quot;, res[i].first, res[i].second); &#125; &#125; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, bool&gt; arr;vector&lt;int&gt; v[10000];int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; if (a.length() == b.length()) &#123; v[abs(stoi(a))].push_back(abs(stoi(b))); v[abs(stoi(b))].push_back(abs(stoi(a))); &#125; arr[abs(stoi(a)) * 10000 + abs(stoi(b))] = arr[abs(stoi(b)) * 10000 + abs(stoi(a))] = true; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; int c, d; cin &gt;&gt; c &gt;&gt; d; vector&lt;pair&lt;int, int&gt; &gt; res; for (int j = 0; j &lt; v[abs(c)].size(); j++) &#123; for (int k = 0; k &lt; v[abs(d)].size(); k++) &#123; if (v[abs(c)][j] == abs(d) || abs(c) == v[abs(d)][k]) continue; if (arr[v[abs(c)][j] * 10000 + v[abs(d)][k]] == true) res.push_back(&#123;v[abs(c)][j], v[abs(d)][k]&#125;); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%04d %04d &quot;, res[i].first, res[i].second); &#125; &#125; return 0;&#125; 1140 Look-and-say Sequence1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; string s; int n, j; cin &gt;&gt; s &gt;&gt; n; for (int cnt = 1; cnt &lt; n; cnt++) &#123; string t; for (int i = 0; i &lt; s.length(); i = j) &#123; for (j = i; j &lt; s.length() &amp;&amp; s[j] == s[i]; j++); t += s[i] + to_string(j - i); &#125; s = t; &#125; cout &lt;&lt; s; return 0;&#125; 1141 PAT Ranking of Institutions123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int tws, ns;&#125;;bool cmp(node &amp;a, node &amp;b) &#123; if (a.tws != b.tws) return a.tws &gt; b.tws; else if(a.ns != b.ns) return a.ns &lt; b.ns; else return a.name &lt; b.name;&#125;unordered_map&lt;string, vector&lt;double&gt; &gt; schools;vector&lt;node&gt; res;int main() &#123; int n; double score; string id, school; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; for (int j = 0; j &lt; school.size(); j++) &#123; school[j] = tolower(school[j]); &#125; if (id[0] == &#x27;B&#x27;) score /= 1.5; else if (id[0] == &#x27;T&#x27;) score *= 1.5; schools[school].push_back(score); &#125; for (auto it: schools) &#123; double s = 0; for (double i: it.second) s += i; res.push_back(&#123;it.first, (int)s, it.second.size()&#125;); &#125; sort(res.begin(), res.end(), cmp); cout &lt;&lt; res.size() &lt;&lt; endl; int rank = 1; for (int i = 0; i &lt; res.size(); i++) &#123; if (i != 0 &amp;&amp; res[i].tws != res[i - 1].tws) rank = i + 1; cout &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; res[i].name &lt;&lt; &quot; &quot; &lt;&lt; res[i].tws &lt;&lt; &quot; &quot; &lt;&lt; res[i].ns &lt;&lt; endl; &#125; return 0;&#125; 1142 Maximal Clique123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;int, bool&gt; mp;int pre[10001];int main() &#123; int m, n, u, v, a; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; mp[pre[i]] = true; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; for (int j = 0; j &lt; n; j++) &#123; a = pre[j]; if (a &gt;= u &amp;&amp; a &lt;= v || a &gt;= v &amp;&amp; a &lt;= u) break; &#125; if (mp[u] == false &amp;&amp; mp[v] == false) printf(&quot;ERROR: %d and %d are not found. &quot;, u, v); else if (mp[u] == false || mp[v] == false) printf(&quot;ERROR: %d is not found. &quot;, mp[u] == false ? u : v); else if (a == u || a == v) printf(&quot;%d is an ancestor of %d. &quot;, a, a == u ? v : u); else printf(&quot;LCA of %d and %d is %d. &quot;, u, v, a); &#125; return 0;&#125; 1143 Lowest Common Ancestor123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;int, bool&gt; mp;int pre[10001];int main() &#123; int m, n, u, v, a; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; mp[pre[i]] = true; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; for (int j = 0; j &lt; n; j++) &#123; a = pre[j]; if (a &gt;= u &amp;&amp; a &lt;= v || a &gt;= v &amp;&amp; a &lt;= u) break; &#125; if (mp[u] == false &amp;&amp; mp[v] == false) printf(&quot;ERROR: %d and %d are not found. &quot;, u, v); else if (mp[u] == false || mp[v] == false) printf(&quot;ERROR: %d is not found. &quot;, mp[u] == false ? u : v); else if (a == u || a == v) printf(&quot;%d is an ancestor of %d. &quot;, a, a == u ? v : u); else printf(&quot;LCA of %d and %d is %d. &quot;, u, v, a); &#125; return 0;&#125; 1144 The Missing Number12345678910111213141516#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, a, num = 1; cin &gt;&gt; n; map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; m[a]++; &#125; while (true) if (m[num++] == 0) break; cout &lt;&lt; num - 1; return 0;&#125; 1145 Hashing - Average Search Time12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int nums[10001];bool isprime(int x) &#123; if (x &lt;= 1) return false; for (int i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;int main() &#123; int ms, n, m, x; cin &gt;&gt; ms &gt;&gt; n &gt;&gt; m; while (!isprime(ms)) ms++; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; bool flag = false; for (int j = 0; j &lt; ms; j++) &#123; if (nums[(x + j * j) % ms] == 0) &#123; nums[(x + j * j) % ms] = x; flag = true; break; &#125; &#125; if (!flag) cout &lt;&lt; x &lt;&lt; &quot; cannot be inserted.&quot; &lt;&lt; endl; &#125; int times = m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x; bool flag = false; for (int j = 0; j &lt; ms; j++) &#123; if (nums[(x + j * j) % ms] == x || nums[(x + j * j) % ms] == 0) &#123; times += j; flag = true; break; &#125; &#125; if (!flag) times += ms; &#125; printf(&quot;%.1f&quot;, (double)times / m); return 0;&#125; 1146 Topological Order1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v[1010], res;int main() &#123; int n, m, a, b, k, in[1010], tin[1010]; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; v[a].push_back(b); in[b]++; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; bool flag = true; for (int i = 1; i &lt;= n; i++) &#123; tin[i] = in[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; if (tin[a] != 0) flag = false; for (int it :v[a]) tin[it]--; &#125; if (flag) continue; res.push_back(i); &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1147 Heaps12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[2001], n;struct node &#123; int val, l, r;&#125;trees[1001];vector&lt;int&gt; res;void post(int root) &#123; if (root &gt;= n) return; post(trees[root].l); post(trees[root].r); res.push_back(trees[root].val);&#125;int main() &#123; int m; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; int flag = 0; fill(nums, nums + 2 * n, -1); for (int j = 0; j &lt; n; j++) cin &gt;&gt; nums[j]; if (nums[0] &gt; nums[1] &amp;&amp; nums[0] &gt; nums[2]) flag = 1; if (nums[0] &lt; nums[1] &amp;&amp; nums[0] &lt; nums[2]) flag = 2; for (int j = 0; j &lt; n; j++) &#123; trees[j].val = nums[j]; if (flag == 1 &amp;&amp; (2*j+1 &lt; n &amp;&amp; nums[j] &lt; nums[2*j+1] || 2*j+2 &lt; n &amp;&amp; nums[j] &lt; nums[2*j+2])) flag = 0; if (flag == 2 &amp;&amp; (2*j+1 &lt; n &amp;&amp; nums[j] &gt; nums[2*j+1] || 2*j+2 &lt; n &amp;&amp; nums[j] &gt; nums[2*j+2])) flag = 0; trees[j].l = 2 * j + 1; trees[j].r = 2 * j + 2; &#125; post(0); if (flag == 0) cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl; else if (flag == 1) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl; else if (flag == 2) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; res.clear(); &#125; return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int a[1005], m, n;void post(int root) &#123; if (root &gt; n) return; post(root * 2); post(root * 2 + 1); printf(&quot;%d%s&quot;, a[root], root == 1 ? &quot; &quot; : &quot; &quot;);&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; for (int j = 0; j &lt; m; j++) &#123; int minn = 1, maxn = 1; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 2; i &lt;= n; i++) &#123; if (a[i] &gt; a[i / 2]) maxn = 0; if (a[i] &lt; a[i / 2]) minn = 0; &#125; if (maxn == 1) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl; else if (minn == 1) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl; post(1); &#125; return 0;&#125; 1148 Werewolf - Simple Version123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int nums[101];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 1; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; int t = 0, flag = 0; for (int k = 0; k &lt; n; k++) &#123; if (nums[k] &lt; 0 &amp;&amp; -nums[k] != i &amp;&amp; -nums[k] != j) &#123; t++; if ((k + 1) == i || (k + 1) == j) flag++; &#125; if (nums[k] &gt; 0 &amp;&amp; (nums[k] == i || nums[k] == j)) &#123; t++; if ((k + 1) == i || (k + 1) == j) flag++; &#125; &#125; if (t == 2 &amp;&amp; flag == 1) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; return 0;&#125; 1149 Dangerous Goods Packaging12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 100001;bool st[N];int nums[N];vector&lt;int&gt; g[N];int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(b); g[b].push_back(a); &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; k; bool flag = true; fill(st, st + N, false); for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; nums[j]; st[nums[j]] = true; &#125; for (int j = 0; j &lt; k; j++) &#123; for (int r = 0; r &lt; g[nums[j]].size(); r++) &#123; if (st[g[nums[j]][r]]) &#123; flag = false; break; &#125; &#125; if (!flag) break; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1150 Travelling Salesman Problem123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;bool visit[205];int g[205][205], nums[205];int main() &#123; int n, m, k, t, city1, city2, d, res = 0x3f3f3f3f, id = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; d; g[city1][city2] = g[city2][city1] = d; &#125; cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; t; bool isCycle = true, isSimple = true, isNA = false; int dist = 0; for (int j = 0; j &lt; t; j++) cin &gt;&gt; nums[j]; fill(visit, visit + 205, false); for (int j = 1; j &lt; t; j++) &#123; if (g[nums[j]][nums[j-1]]) &#123; dist += g[nums[j]][nums[j-1]]; if (!visit[nums[j]]) visit[nums[j]] = true; else isSimple = false; &#125; else &#123; isCycle = false; isNA = true; &#125; &#125; for (int i = 1; i &lt;= n; i++) if (!visit[i]) isCycle = false; if (isCycle &amp;&amp; dist &lt; res) &#123; res = dist; id = i; &#125; if (isCycle &amp;&amp; isSimple) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist &lt;&lt; &quot; (TS simple cycle)&quot; &lt;&lt; endl; else if (isCycle &amp;&amp; !isSimple) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist &lt;&lt; &quot; (TS cycle)&quot; &lt;&lt; endl; else if (!isCycle &amp;&amp; isNA) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: NA (Not a TS cycle)&quot; &lt;&lt; endl; else if (!isCycle &amp;&amp; !isNA) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist &lt;&lt; &quot; (Not a TS cycle)&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Shortest Dist(&quot; &lt;&lt; id &lt;&lt; &quot;) = &quot; &lt;&lt; res; return 0;&#125; 1151 LCA in a Binary Tree12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; pos;vector&lt;int&gt; in, pre;void lca(int inl, int inr, int preRoot, int a, int b) &#123; if (inl &gt; inr) return; int inRoot = pos[pre[preRoot]], aIn = pos[a], bIn = pos[b]; if (aIn &lt; inRoot &amp;&amp; bIn &lt; inRoot) lca(inl, inRoot - 1, preRoot + 1, a, b); else if ((aIn &lt; inRoot &amp;&amp; bIn &gt; inRoot) || (aIn &gt; inRoot &amp;&amp; bIn &lt; inRoot)) printf(&quot;LCA of %d and %d is %d. &quot;, a, b, in[inRoot]); else if (aIn &gt; inRoot &amp;&amp; bIn &gt; inRoot) lca(inRoot + 1, inr, preRoot + 1 + (inRoot - inl), a, b); else if (aIn == inRoot) printf(&quot;%d is an ancestor of %d. &quot;, a, b); else if (bIn == inRoot) printf(&quot;%d is an ancestor of %d. &quot;, b, a);&#125;int main() &#123; int m, n, a, b; cin &gt;&gt; m &gt;&gt; n; in.resize(n + 1); pre.resize(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; in[i]; pos[in[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; pre[i]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (pos[a] == 0 &amp;&amp; pos[b] == 0) printf(&quot;ERROR: %d and %d are not found. &quot;, a, b); else if (pos[a] == 0 || pos[b] == 0) printf(&quot;ERROR: %d is not found. &quot;, pos[a] == 0 ? a : b); else lca(1, n, 1, a, b); &#125; return 0;&#125; 1152 Google Recruitment12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;bool check(LL n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt; n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int l, k; string str; cin &gt;&gt; l &gt;&gt; k; cin &gt;&gt; str; for (int i = 0; i &lt;= l - k; i++) &#123; if (check(stol(str.substr(i, k)))) &#123; cout &lt;&lt; str.substr(i, k); return 0; &#125; &#125; cout &lt;&lt; 404 &lt;&lt; endl; return 0;&#125; 1153 Decode Registration Card of PAT)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct node&#123; string num; char ch; int site, date, score;&#125;nums[10005];bool cmp1(node &amp;a, node &amp;b) &#123; if (a.score != b.score) return a.score &gt; b.score; return a.num &lt; b.num;&#125;bool cmp2(PII &amp;a, PII &amp;b) &#123; if (a.second != b.second) return a.second &gt; b.second; return a.first &lt; b.first;&#125;int main() &#123; int n, m, flag, site, date, score, x; char ch; string num; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num &gt;&gt; score; nums[i] = &#123;num, num[0], stoi(num.substr(1, 3)), stoi(num.substr(4, 6)), score&#125;; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; flag; if (flag == 1) &#123; vector&lt;node&gt; t; cin &gt;&gt; ch; cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; &quot;: 1 &quot; &lt;&lt; ch &lt;&lt; endl; for (int j = 0; j &lt; n; j++) if (ch == nums[j].ch) t.push_back(nums[j]); sort(t.begin(), t.end(), cmp1); for (auto it: t) cout &lt;&lt; it.num &lt;&lt; &quot; &quot; &lt;&lt; it.score &lt;&lt; endl; if (t.empty()) cout &lt;&lt; &quot;NA&quot; &lt;&lt; endl; &#125; else if (flag == 2) &#123; cin &gt;&gt; site; cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; &quot;: 2 &quot; &lt;&lt; site &lt;&lt; endl; int nt = 0, ns = 0; for (int j = 0; j &lt; n; j++) &#123; if (site == nums[j].site) &#123; nt++; ns += nums[j].score; &#125; &#125; if (nt == 0) cout &lt;&lt; &quot;NA&quot; &lt;&lt; endl; else cout &lt;&lt; nt &lt;&lt; &quot; &quot; &lt;&lt; ns &lt;&lt; endl; &#125; else if (flag == 3) &#123; cin &gt;&gt; date; printf(&quot;Case %d: 3 %06d &quot;, i, date); map&lt;int, int&gt; t; vector&lt;pair&lt;int, int&gt;&gt; t2; for (int j = 0; j &lt; n; j++) &#123; if (date == nums[j].date) &#123; t[nums[j].site] ++; &#125; &#125; for (auto it: t) t2.push_back(&#123;it.first, it.second&#125;); sort(t2.begin(), t2.end(), cmp2); for (auto it: t2) cout &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second &lt;&lt; endl; if (t2.empty()) cout &lt;&lt; &quot;NA&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 1154 Vertex Coloring1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int level[1005];struct node&#123; int val, l, r;&#125; nums[1005];int n;int build(int root) &#123; if (root &gt;= n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;&#125;vector&lt;int&gt; t;void dfs(int root) &#123; if (root == -1) &#123; for (int i = 0; i &lt; t.size(); i++) &#123; cout &lt;&lt; t[i]; if (i &lt; t.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return; &#125; t.push_back(nums[root].val); if (nums[root].l == -1 &amp;&amp; nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) dfs(nums[root].r); else if (nums[root].r == -1) dfs(nums[root].l); else &#123; dfs(nums[root].r); dfs(nums[root].l); &#125; t.pop_back();&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; level[i]; build(0); dfs(0); bool ismin = true, ismax = true; for (int i = 2; i &lt;= n; i++) &#123; if (level[i/2-1] &gt; level[i-1]) ismin = false; if (level[i/2-1] &lt; level[i-1]) ismax = false; &#125; if (ismin) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; else printf(&quot;%s&quot;, ismax ? &quot;Max Heap&quot; : &quot;Not Heap&quot;); return 0;&#125; 1155 Heap Paths123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int level[1005];struct node&#123; int val, l, r;&#125; nums[1005];int n;bool ismax, ismin;int build(int root) &#123; if (root &gt;= n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;&#125;vector&lt;int&gt; t;void dfs(int root) &#123; if (root == -1) &#123; for (int i = 0; i &lt; t.size(); i++) &#123; cout &lt;&lt; t[i]; if (i &lt; t.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return; &#125; t.push_back(nums[root].val); if (nums[root].l == -1 &amp;&amp; nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) &#123; if (nums[root].val &gt; nums[nums[root].r].val) ismax = true; else if (nums[root].val &lt; nums[nums[root].r].val) ismin = true; dfs(nums[root].r); &#125; else if (nums[root].r == -1) &#123; if (nums[root].val &gt; nums[nums[root].l].val) ismax = true; else if (nums[root].val &lt; nums[nums[root].l].val) ismin = true; dfs(nums[root].l); &#125; else &#123; if (nums[root].val &gt; nums[nums[root].r].val &amp;&amp; nums[root].val &gt; nums[nums[root].l].val) ismax = true; else if (nums[root].val &lt; nums[nums[root].r].val &amp;&amp; nums[root].val &lt; nums[nums[root].l].val) ismin = true; dfs(nums[root].r); dfs(nums[root].l); &#125; t.pop_back();&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; level[i]; build(0); dfs(0); if (ismax &amp;&amp; ismin) cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl; else if (ismax) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl; else if (ismin) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; return 0;&#125; 1156 Sexy Primes123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;bool check(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; if (check(n) &amp;&amp; check(n - 6)) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; n - 6; else if (check(n) &amp;&amp; check(n + 6)) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; n + 6; else &#123; for (int i = n + 1; ; i++) &#123; if (check(i) &amp;&amp; check(i - 6) || check(i) &amp;&amp; check(i + 6)) &#123; cout &lt;&lt; &quot;No &quot; &lt;&lt; i; break; &#125; &#125; &#125; return 0;&#125; 1157 Anniversary123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;string, bool&gt; isAlumni;vector&lt;string&gt; alumnu, guest;int main() &#123; int n; string num; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; isAlumni[num] = true; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; if (isAlumni[num]) alumnu.push_back(num); else guest.push_back(num); &#125; cout &lt;&lt; alumnu.size() &lt;&lt; endl; if (!alumnu.empty()) &#123; string mind = alumnu[0].substr(6, 8), res = alumnu[0]; for (int i = 1; i &lt; alumnu.size(); i++) &#123; if (mind &gt; alumnu[i].substr(6, 8)) &#123; mind = alumnu[i].substr(6, 8); res = alumnu[i]; &#125; &#125; cout &lt;&lt; res; &#125; else &#123; string mind = guest[0].substr(6, 8), res = guest[0]; for (int i = 1; i &lt; guest.size(); i++) &#123; if (mind &gt; guest[i].substr(6, 8)) &#123; mind = guest[i].substr(6, 8); res = guest[i]; &#125; &#125; cout &lt;&lt; res; &#125;&#125; 1158 Telefraud Detection1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;int g[1005][1005] , father[1005];vector&lt;int&gt; suspects;int find(int x) &#123; if (father[x] != x) father[x] = find(father[x]); return father[x];&#125;void union1(int a, int b) &#123; int fa = find(a); int fb = find(b); if (fa != fb) &#123; if (fa &lt; fb) father[fb] = fa; else father[fa] = fb; &#125;&#125;int main() &#123; int k, n, m, caller, receiver, duration; cin &gt;&gt; k &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; caller &gt;&gt; receiver &gt;&gt; duration; g[caller][receiver] += duration; &#125; for (int i = 1; i &lt;= n; i++) &#123; int to = 0, back = 0; for (int j = 1; j &lt;= n; j++) &#123; if (g[i][j] &amp;&amp; g[i][j] &lt;= 5) to++; if (g[i][j] &amp;&amp; g[i][j] &lt;= 5 &amp;&amp; g[j][i]) back++; if (to &gt; k &amp;&amp; back &lt;= to * 0.2) &#123; suspects.push_back(i); break; &#125; &#125; &#125; if (suspects.empty()) cout &lt;&lt; &quot;None&quot; &lt;&lt; endl; for (int i = 0; i &lt; suspects.size(); i++) father[suspects[i]] = suspects[i]; for (int i = 0; i &lt; suspects.size(); i++) &#123; for (int j = i + 1; j &lt; suspects.size(); j++) &#123; if (g[suspects[i]][suspects[j]] &amp;&amp; g[suspects[j]][suspects[i]]) &#123; union1(suspects[i], suspects[j]); &#125; &#125; &#125; map&lt;int, vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; suspects.size(); i++) &#123; int t = find(suspects[i]); res[t].push_back(suspects[i]); &#125; for (auto it: res) &#123; sort(it.second.begin(), it.second.end()); for (int i = 0; i &lt; it.second.size(); i++) &#123; cout &lt;&lt; it.second[i]; if (i &lt; it.second.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1159 Structure of a Binary Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;int post[31], in[31];struct node &#123; int l, r, parent, level;&#125; trees[1005];bool isFull = true;int build(int postL, int postR, int inL, int inR, int parent, int level) &#123; if (postL &gt; postR) return -1; int root = post[postR], id = inL; for (int i = inL; i &lt;= inR; i++) &#123; if (root == in[i]) &#123; id = i; break; &#125; &#125; int cntL = id - inL; trees[root].parent = parent; trees[root].level = level; trees[root].l = build(postL, postL + cntL - 1, inL, id - 1, root, level + 1); trees[root].r = build(postL + cntL, postR - 1, id + 1, inR, root, level + 1); if (trees[root].l * trees[root].r &lt; 0) isFull = false; return root;&#125;int main() &#123; int n, m, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; int root = build(0, n - 1, 0, n - 1, -1, 0); cin &gt;&gt; m; string ops; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; ops; if (ops == &quot;It&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; ops &gt;&gt; ops; if (isFull) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; continue; &#125; a = stoi(ops); cin &gt;&gt; ops; if (ops == &quot;is&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops; if (ops == &quot;root&quot;) &#123; if (a == root) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;parent&quot;) &#123; cin &gt;&gt; ops &gt;&gt; b; if (trees[a].l == b || trees[a].r == b) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;left&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; b; if (trees[b].l == a) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;right&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; b; if (trees[b].r == a) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; else if (ops == &quot;and&quot;) &#123; cin &gt;&gt; b &gt;&gt; ops &gt;&gt; ops; if (ops == &quot;siblings&quot;) &#123; if (trees[a].parent == trees[b].parent) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;on&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; ops; if (trees[a].level == trees[b].level) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 1160 Forever12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;int, LL&gt; PII;int k, m;vector&lt;PII&gt; res;int gcd(int a, int b) &#123; if (b) return gcd(b, a % b); else return a;&#125;bool isprime(int x) &#123; if (x &lt; 2) return false; for (int i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;void dfs(int cnt, int sum, LL x) &#123; if (cnt &gt; k || sum &gt; m || m &gt; sum + 9*(k-cnt)) return; if (cnt == k &amp;&amp; sum == m) &#123; LL y = x + 1; int n = 0; while (y) &#123; n += y % 10; y /= 10; &#125; if (gcd(n, m) &gt; 2 &amp;&amp; isprime(gcd(n, m))) res.push_back(&#123;n, x&#125;); return; &#125; for (int i = 0; i &lt;= 9; i++) &#123; if (sum == 0 &amp;&amp; i == 0) continue; else dfs(cnt + 1, sum + i, x * 10 + i); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; endl; cin &gt;&gt; k &gt;&gt; m; res.clear(); dfs(0, 0, 0); if (res.empty()) cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; else &#123; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot; &quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 1161 Merging Linked Lists12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int add, val, nxt;&#125; nums[100005];vector&lt;node&gt; l1, l2, res;int main() &#123; int s1, s2, n, id; cin &gt;&gt; s2 &gt;&gt; s1 &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id; cin &gt;&gt; nums[id].val &gt;&gt; nums[id].nxt; nums[id].add = id; &#125; while (s1 != -1) &#123; l1.push_back(nums[s1]); s1 = nums[s1].nxt; &#125; while (s2 != -1) &#123; l2.push_back(nums[s2]); s2 = nums[s2].nxt; &#125; if (l1.size() &lt; l2.size()) swap(l1, l2); id = 0; for (int i = l2.size() - 1; i &gt;= 0; i--) &#123; res.push_back(l1[id++]); res.push_back(l1[id++]); res.push_back(l2[i]); &#125; for (int i = id; i &lt; l1.size(); i++) res.push_back(l1[i]); for (int i = 0; i &lt; res.size() - 1; i++) printf(&quot;%05d %d %05d &quot;, res[i].add, res[i].val, res[i + 1].add); printf(&quot;%05d %d -1&quot;, res.back().add, res.back().val); return 0;&#125; 1162 Postfix Expression123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct node&#123; string ch; int l, r;&#125; trees[21];bool st[21];void postorder(int x) &#123; if (x == -1) return; if (trees[x].l == -1) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; trees[x].ch; postorder(trees[x].r); cout &lt;&lt; &quot;)&quot;; &#125; else &#123; cout &lt;&lt; &quot;(&quot;; postorder(trees[x].l); postorder(trees[x].r); cout &lt;&lt; trees[x].ch &lt;&lt; &quot;)&quot;; &#125;&#125;int main() &#123; int n, root = 1; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; trees[i].ch &gt;&gt; trees[i].l &gt;&gt; trees[i].r; st[trees[i].l] = st[trees[i].r] = true; &#125; for (int i = 1; i &lt;= n; i++) if (!st[i]) root = i; postorder(root); return 0;&#125; æŸ³å©¼çš„ 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n, root = 1, lc[31], rc[31], mark[32];string d[32];void deal(int x) &#123; cout &lt;&lt; &quot;(&quot;; if (lc[x] * rc[x] &gt; 1) &#123; deal(lc[x]); deal(rc[x]); &#125; cout &lt;&lt; d[x]; if (lc[x] * rc[x] &lt; 0) deal(rc[x]); cout &lt;&lt; &quot;)&quot;;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i] &gt;&gt; lc[i] &gt;&gt; rc[i]; mark[lc[i]] = mark[rc[i]] = 1; &#125; while (mark[root]) root++; deal(root); return 0;&#125; 1163 Dijkstra Sequence1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, m, g[1005][1005], nums[1005], d[1005];bool visit[1005];bool dijkstra(int x) &#123; fill(visit, visit + 1005, false); fill(d, d + 1005, INF); d[x] = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 1; j &lt;= n; j++) &#123; if (!visit[j]) &#123; if (mind &gt; d[j]) &#123; mind = d[j]; u = j; &#125; else if (mind == d[j]) &#123; if (j == nums[i]) u = j; &#125; &#125; &#125; if (u != nums[i]) return false; visit[u] = true; for (int j = 1; j &lt;= n; j++) &#123; if (g[u][j] &amp;&amp; !visit[j] &amp;&amp; d[u] + g[u][j] &lt; d[j]) &#123; d[j] = d[u] + g[u][j]; &#125; &#125; &#125; return true;&#125;int main() &#123; int a, b, c, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] = g[b][a] = c; &#125; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; if (dijkstra(nums[0])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1164 Good in C1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string alp[27][8];int main() &#123; for (int i = 0; i &lt; 26; i++) &#123; for (int j = 0; j &lt; 7; j++) cin &gt;&gt; alp[i][j]; &#125; string strs[1000], t, str; char ch; int id2 = 0; getchar(); getline(cin, t); for (int i = 0; i &lt; t.size(); i++) &#123; ch = t[i]; if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) str.push_back(ch); else if (!str.empty()) &#123; strs[id2++] = str; str.clear(); &#125; &#125; if (!str.empty()) &#123; strs[id2++] = str; str.clear(); &#125; for (int i = 0; i &lt; id2; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; for (int k = 0; k &lt; strs[i].size(); k++) &#123; cout &lt;&lt; alp[strs[i][k] - &#x27;A&#x27;][j]; if (k &lt; strs[i].size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; &#125; if (i &lt; id2 - 1) cout &lt;&lt; endl; &#125; return 0;&#125; 1165 Block Reversing12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int add, val, nxt;&#125; nums[100005];int main() &#123; int start, n, k, add, val, nxt; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add; nums[add].add = add; cin &gt;&gt; nums[add].val &gt;&gt; nums[add].nxt; &#125; vector&lt;int&gt; tmps, res; while (start != -1) &#123; tmps.push_back(start); start = nums[start].nxt; &#125; int t = tmps.size() / k; for (int i = t * k; i &lt; tmps.size(); i++) &#123; res.push_back(tmps[i]); &#125; for (int i = t * k - k; i &gt;= 0; i -= k) &#123; for (int j = 0; j &lt; k; j++) &#123; res.push_back(tmps[i + j]); &#125; &#125; for (int i = 0; i &lt; res.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); &#125; printf(&quot;%05d %d -1&quot;, nums[res.back()].add, nums[res.back()].val); return 0;&#125; 1166 Summit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int g[205][205], nums[205];bool st[205];int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a][b] = g[b][a] = 1; &#125; cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; &quot;Area &quot; &lt;&lt; i; cin &gt;&gt; m; fill (st, st + 205, false); for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; nums[j]; st[nums[j]] = true; &#125; bool flag1 = false, flag2 = false, flag3 = false; for (int p = 0; p &lt; m; p++) &#123; for (int q = p + 1; q &lt; m; q++) &#123; if (g[nums[p]][nums[q]] == 0) &#123; flag1 = true; break; &#125; &#125; if (flag1) &#123; cout &lt;&lt; &quot; needs help.&quot; &lt;&lt; endl; break; &#125; &#125; if (!flag1) &#123; for (int p = 1; p &lt;= n; p++) &#123; if (!st[p]) &#123; flag2 = false; for (int q = 0; q &lt; m; q++) if (g[p][nums[q]] == 0) flag2 = true; if (!flag2) &#123; cout &lt;&lt; &quot; may invite more people, such as &quot; &lt;&lt; p &lt;&lt; &quot;.&quot; &lt;&lt; endl; flag3 = true; break; &#125; &#125; &#125; if (!flag3) cout &lt;&lt; &quot; is OK.&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 1167 Cartesian Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int val, l, r;&#125; trees[32];int in[32];vector&lt;int&gt; level;int build(int l, int r) &#123; if (l &gt; r) return -1; int mind = 0x3f3f3f3f, root = l; for (int i = l; i &lt;= r; i++) &#123; if (mind &gt; in[i]) &#123; mind = in[i]; root = i; &#125; &#125; trees[root].val = mind; trees[root].l = build(l, root - 1); trees[root].r = build(root + 1, r); return root;&#125;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; u = q.front(); q.pop(); level.push_back(trees[u].val); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; int root = build(0, n - 1); bfs(root); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; level[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1168 Prime Day1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPrime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; string n; cin &gt;&gt; n; bool flag = true; for (int i = 0; i &lt; 8; i++) &#123; if (isPrime(stoi(n))) cout &lt;&lt; n &lt;&lt; &quot; Yes&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; n &lt;&lt; &quot; No&quot; &lt;&lt; endl; flag = false; &#125; n = n.substr(1); &#125; if (flag) cout &lt;&lt; &quot;All Prime!&quot;; return 0;&#125; 1169 The Judger12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool st[100005], out[11];int g[12][1005];vector&lt;int&gt; nums;bool check(int x) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (x == abs(nums[i] - nums[j])) return true; &#125; &#125; return false;&#125;int main() &#123; int a, b, n, m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n &gt;&gt; m; st[a] = st[b] = true; nums.push_back(a); nums.push_back(b); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) cin &gt;&gt; g[i][j]; &#125; for (int i = 0; i &lt; m; i++) &#123; vector&lt;int&gt; tmp; for (int j = 0; j &lt; n; j++) &#123; if (!out[j]) &#123; if (!st[g[j][i]] &amp;&amp; check(g[j][i])) &#123; nums.push_back(g[j][i]); st[g[j][i]] = true; &#125; else &#123; tmp.push_back(j + 1); out[j] = true; &#125; &#125; &#125; if (!tmp.empty()) &#123; for (int j = 0; j &lt; tmp.size(); j++) cout &lt;&lt; &quot;Round #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; tmp[j] &lt;&lt; &quot; is out.&quot; &lt;&lt; endl; &#125; &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; n; i++) if (!out[i]) res.push_back(i + 1); if (!res.empty()) &#123; cout &lt;&lt; &quot;Winner(s):&quot;; for (int i = 0; i &lt; res.size(); i++) cout &lt;&lt; &quot; &quot; &lt;&lt; res[i]; &#125; else cout &lt;&lt; &quot;No winner.&quot;; return 0;&#125; 1170 Safari Park1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int g[505][505];int main() &#123; int n, r, k, a, b; cin &gt;&gt; n &gt;&gt; r &gt;&gt; k; for (int i = 0; i &lt; r; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a][b] = g[b][a] = 1; &#125; cin &gt;&gt; r; for (int i = 0; i &lt; r; i++) &#123; map&lt;int, vector&lt;int&gt;&gt; nums; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; a; nums[a].push_back(j); &#125; if (nums.size() == k) &#123; bool flag = true; for (auto it: nums) &#123; for (int p = 0; p &lt; it.second.size(); p++) &#123; for (int q = p + 1; q &lt; it.second.size(); q++) &#123; if (g[it.second[p]][it.second[q]]) flag= false; &#125; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (nums.size() &lt; k) cout &lt;&lt; &quot;Error: Too few species.&quot; &lt;&lt; endl; else if (nums.size() &gt; k) cout &lt;&lt; &quot;Error: Too many species.&quot; &lt;&lt; endl; &#125; return 0;&#125; 1171 Replacement Selection123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int nums[100005];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q1, q2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; if (i &lt; m) q1.push(nums[i]); &#125; int id = m; while (q1.size()) &#123; int now = q1.top(); cout &lt;&lt; now; q1.pop(); if (id &lt; n) &#123; if (nums[id] &lt; now) q2.push(nums[id]); else q1.push(nums[id]); id++; &#125; if (q1.size()) cout &lt;&lt; &quot; &quot;; else &#123; swap(q1, q2); cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1172 Panda and PP Milk1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int nums[10005], tmps[10005];int main() &#123; int n, res = 0; cin &gt;&gt; n; fill(tmps, tmps + n, 200); for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; i++) &#123; int t = nums[i], id = 0; for (int j = i - 1; j &gt;= 0; j--) &#123; if (t &lt; nums[j]) &#123; id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; &#125; else if (t == nums[j]) &#123; tmps[j] = max(tmps[j], 200 + id * 100); &#125; else break; &#125; t = nums[i], id = 0; for (int j = i + 1; j &lt; n; j++) &#123; if (t &lt; nums[j]) &#123; id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; &#125; else if (t == nums[j]) &#123; tmps[j] = max(tmps[j], 200 + id * 100); &#125; else break; &#125; &#125; for (int i = 0; i &lt; n; i++) res += tmps[i]; cout &lt;&lt; res; return 0;&#125; 1173 How Many Ways to Buy a Piece of Land12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int nums[10005];int main() &#123; int n, m, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; i++) &#123; int t = 0; for (int j = i; j &lt; n; j++) &#123; t += nums[j]; if (t &lt;= m) res++; else break; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1174 Left-View of Binary Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int in[25], pre[25];vector&lt;int&gt; res;struct node &#123; int l, r;&#125; trees[200005];int build(int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR) return -1; int root = pre[preL], id = inL; for (int i = inL; i &lt;= inR; i++) &#123; if (root == in[i]) &#123; id = i; break; &#125; &#125; int cntL = id - inL; trees[root].l = build(preL + 1, preL + cntL, inL, id - 1); trees[root].r = build(preL + cntL + 1, preR, id + 1, inR); return root;&#125;void bfs(int root) &#123; queue&lt;int&gt; q; q.push(root); while (!q.empty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; root = q.front(); q.pop(); if (i == 0) res.push_back(root); if (trees[root].l != -1) q.push(trees[root].l); if (trees[root].r != -1) q.push(trees[root].r); &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return 0;&#125; 1175 Professional Ability Test - PAT (Advanced Level) Practice (pintia.cn)æŸ³å©¼çš„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int v, score, voucher; bool operator &lt; (const node &amp;x) const &#123; if(score != x.score) return score &gt; x.score; else return voucher &lt; x.voucher; &#125;&#125;;struct bian &#123; int next, S, D;&#125;;vector&lt;bian&gt; E[1005];vector&lt;pair&lt;int,int&gt;&gt; Dis(1005, &#123;2e9, -1&#125;);int N, M, T1, T2, S, D, f, T, in[1005], in2[1005], Last[1005];queue&lt;int&gt; DAG;int huan() &#123; vector&lt;int&gt; S; while(DAG.size()) &#123; int now = DAG.front(); DAG.pop(); S.push_back(now); for(auto it : E[now]) &#123; in2[it.next]--; if(!in2[it.next]) DAG.push(it.next); &#125; &#125; return S.size() == N;&#125;void dijkstra() &#123; vector&lt;int&gt; vis(1005); priority_queue&lt;node&gt; Q; Q.push(&#123;1002, 0, 0&#125;); Dis[1002].first = Dis[1002].second = 0; while(Q.size()) &#123; node now = Q.top(); Q.pop(); if(vis[now.v]) continue; vis[now.v] = 1; Dis[now.v].first = now.score; Dis[now.v].second = now.voucher; for (auto it : E[now.v]) &#123; if(vis[it.next]) continue; if((Dis[it.next].first &gt; Dis[now.v].first + it.S) || ((Dis[it.next].first == Dis[now.v].first + it.S) &amp;&amp; (Dis[it.next].second &lt; Dis[now.v].second + it.D))) &#123; Dis[it.next].first = Dis[now.v].first + it.S; Dis[it.next].second = Dis[now.v].second + it.D; Last[it.next] = now.v; Q.push(&#123;it.next, Dis[it.next].first, Dis[it.next].second&#125;); &#125; &#125; &#125; return;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; T1 &gt;&gt; T2 &gt;&gt; S &gt;&gt; D; E[T1].push_back(&#123;T2, S, D&#125;); in[T2]++, in2[T2]++; &#125; for (int i = 0; i &lt; N; i++) &#123; if (in[i] == 0) &#123; E[1002].push_back(&#123;i, 0, 0&#125;); DAG.push(i); &#125; &#125; f = huan(); dijkstra(); cin &gt;&gt; T; if(f) cout &lt;&lt; &quot;Okay. &quot;; else cout &lt;&lt; &quot;Impossible. &quot;; for (int i = 1, q; i &lt;= T; i++) &#123; cin &gt;&gt; q; if(!in[q]) cout &lt;&lt; &quot;You may take test &quot; &lt;&lt; q &lt;&lt; &quot; directly. &quot;; else if(!f) cout &lt;&lt; &quot;Error. &quot;; else &#123; vector&lt;int&gt; path; int now = q; while(q != 1002) &#123; path.push_back(q); q = Last[q]; &#125; for (int j = path.size() - 1; j &gt;= 0; j--) &#123; cout &lt;&lt; path[j]; if(j) cout &lt;&lt; &quot;-&gt;&quot;; &#125; cout &lt;&lt; &#x27; &#x27;; &#125; &#125; return 0;&#125; 1176 The Closest Fibonacci Number12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[43];int main() &#123; int n, res = 0, m = 0x3f3f3f3f; cin &gt;&gt; n; dp[0] = dp[1] = 1; if (n == 1) &#123; cout &lt;&lt; n; return 0; &#125; for (int i = 2; i &lt; 43; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; if (m &gt; abs(dp[i] - n)) &#123; m = abs(dp[i] - n); res = dp[i]; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1177 Subsequence in Substring12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; int m = 0x3f3f3f3f, idx, l = 0, r = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == p[0]) &#123; idx = 1; for (int j = i + 1; j &lt; s.size(); j++) &#123; if (j - i &gt;= m) break; if (s[j] == p[idx]) idx++; if (idx == p.size()) &#123; l = i, r = j; m = r - l; &#125; &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; cout &lt;&lt; s[i]; &#125; return 0;&#125; 1178 File Path1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, string&gt; superior;map&lt;int, string&gt; last;int main() &#123; int n, k; string root, str, res; cin &gt;&gt; n &gt;&gt; root; last[1] = root; superior[root] = root; getchar(); for (int i = 1; i &lt; n; i++) &#123; getline(cin, str); int depth = 0; while (str[depth] == &#x27; &#x27;) depth++; superior[str.substr(depth)] = last[depth]; last[depth + 1] = str.substr(depth); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; str; if (!superior.count(str)) cout &lt;&lt; &quot;Error: &quot; &lt;&lt; str &lt;&lt; &quot; is not found.&quot; &lt;&lt; endl; else &#123; res = &quot; &quot;; while (str != root) &#123; res = &quot;-&gt;&quot; + str + res; str = superior[str]; &#125; cout &lt;&lt; root &lt;&lt; res; &#125; &#125; return 0;&#125; 1179 Chemical Equation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, m, k, num, used[101], res[101];string s;vector&lt;int&gt; product, tmp;vector&lt;vector&lt;int&gt; &gt; equa[101];bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123; for (int i = 0; ; i++) if (a[i] != b[i]) return a[i] &lt; b[i];&#125;void dfs(int x) &#123; if (x == m) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; equa[product[i]][res[i]].size(); j++) &#123; if (j != 0) cout &lt;&lt; &quot; + &quot;; printf(&quot;%02d&quot;, equa[product[i]][res[i]][j]); &#125; printf(&quot; -&gt; %02d &quot;, product[i]); &#125; exit(0); &#125; for (int i = 0; i &lt; equa[product[x]].size(); i++) &#123; int flag = 1; vector&lt;int&gt; A = equa[product[x]][i]; for (auto it: A) if (used[it] != 1) &#123; flag = 0; break; &#125; if (flag == 0) continue; for (auto it: A) used[it] = 2; res[x] = i; dfs(x + 1); for (auto it: A) used[it] = 1; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; used[num] = 1; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num; if (used[num] == 1) equa[num].push_back(&#123;num&#125;); product.push_back(num); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; tmp.clear(); while (cin &gt;&gt; num &gt;&gt; s) &#123; tmp.push_back(num); if (s == &quot;-&gt;&quot;) &#123; cin &gt;&gt; num; equa[num].push_back(tmp); break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) sort(equa[product[i]].begin(), equa[product[i]].end(), cmp); dfs(0); return 0;&#125;","tags":["ç®—æ³•","PAT","C++"],"categories":["ç®—æ³•"]},{"title":"åŠ›æ‰£å¸¸è§é¢˜ç›®","path":"/2024/07/29/åŠ›æ‰£å¸¸è§é¢˜/","content":"æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²123456789class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: dic, res, i = &#123;&#125;, 0, -1 for j in range(len(s)): if s[j] in dic: i = max(dic[s[j]], i) dic[s[j]] = j res = max(res, j - i) return res åè½¬é“¾è¡¨é€’æ¨ 12345678910111213class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, pre = head, None while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre é€’å½’ 123456789class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: def recur(cur, pre): if not cur: return pre res = recur(cur.next, cur) cur.next = pre return res return recur(head, None) æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 123456789101112131415161718class Solution: def findKthLargest(self, nums: List[int], k:int) -&gt; int: def quick_sort(nums, k): pivot = random.choice(nums) big, small = [], [] for num in nums: if num &gt; pivot: big.append(num) elif num &lt; pivot: small.append(num) if k &lt;= len(big): return quick_select(big, k) if len(nums) - len(small) &lt; k: return quick_select(small, k - len(nums) + len(small)) return pivot return quick_select(nums, k) K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨1234567891011121314151617181920212223242526class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]: n = 0 cur = head while cur: n += 1 cur = cur.next p0 = dummy = ListNode(next=head) pre = None cur = head while n &gt;= k: n -= k for _ in range(k): nxt = cur.next cur.next = pre pre = cur cur = nxt nxt = p0.next nxt.next = cur p0.next = pre p0 = nxt return dummy.next ä¸‰æ•°ä¹‹å’Œ12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: [int]) -&gt; [[int]]: nums.sort() res, k = [], 0 for k in range(len(nums) - 2): if nums[k] &gt; 0: break if k &gt; 0 and nums[k] == nums[k - 1]: continue i, j = k + 1, len(nums) - 1 while i &lt; j: s = nums[k] + nums[i] + nums[j] if s &lt; 0: i += 1 while i &lt; j and nums[i] == nums[i - 1]: i += 1 elif s &gt; 0: j -= 1 while i &lt; j and nums[j] == nums[j + 1]: j -= 1 else: res.append([nums[k], nums[i], nums[j]]) i += 1 j -= 1 while i &lt; j and nums[i] == nums[i - 1]: i += 1 while i &lt; j and nums[j] == nums[j + 1]: j -= 1 return res æœ€å¤§å­æ•°ç»„å’Œ12345678910111213class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: size = len(nums) if size == 0: return 0 dp = [0 for _ in range(size)] dp[0] = nums[0] for i in range(1, size): if dp[i - 1] &gt;= 0: dp[i] = dp[i - 1] + nums[i] else: dp[i] = nums[i] return max(dp) æ’åºæ•°ç»„123456789101112131415161718192021class Solution: def sortArray(self, nums: List[int]) -&gt; List[int]: import random def quicksort(nums, left, right): flag = nums[random.randint(left, right)] i, j = left, right while i &lt;= j: while nums[i] &lt; flag: i += 1 while nums[j] &gt; flag: j -= 1 if i &lt;= j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 if i &lt; right: quicksort(nums, i, right) if j &gt; left: quicksort(nums, left, j) quicksort(nums, 0, len(nums) - 1) return nums","tags":["ç®—æ³•","Python","LeetCode"],"categories":["ç®—æ³•"]},{"title":"ç®—æ³•ç¬”è®°","path":"/2024/07/29/ç®—æ³•ç¬”è®°(c++)/","content":"åˆ·é¢˜åœ°å€ï¼šæ™´é—®ç®—æ³• (sunnywhy.com) å…¥é—¨æ¨¡æ‹Ÿç®€å•æ¨¡æ‹Ÿ3N+1çŒœæƒ³ 123456789101112#include &lt;cstdio&gt;int main() &#123; int n, res = 0; scanf(&quot;%d&quot;, &amp;n); while (n != 1) &#123; if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; res ++; &#125; printf(&quot;%d&quot;, res); return 0;&#125; åˆ¤æ–­ä¸‰è§’å½¢ 1234567891011#include &lt;cstdio&gt;int main() &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) &#123; printf(&quot;YES&quot;); &#125; else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; å•è°ƒé€’å¢åºåˆ— 12345678910111213141516171819#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; bool flag = true; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &lt; nums[i - 1]) &#123; flag = false; break; &#125; &#125; printf(flag ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; æ•°åˆ—å¥‡æ•°å’Œ 123456789101112#include &lt;cstdio&gt;int main() &#123; int n, x, res = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;x); if (x % 2 == 1) res += x; &#125; printf(&quot;%d&quot;, res); return 0;&#125; ä¸‰ä½æ•° 12345678910#include &lt;cstdio&gt;int main() &#123; int n, bai = 0, shi = 0, ge = 0; scanf(&quot;%d&quot;, &amp;n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; printf(&quot;%d %d %d&quot;, bai, shi, ge); return 0;&#125; æ°´ä»™èŠ±æ•° 123456789101112131415#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int n, bai, shi, ge; scanf(&quot;%d&quot;, &amp;n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; if (pow(bai, 3) + pow(shi, 3) + pow(ge, 3) == n) &#123; printf(&quot;YES&quot;); &#125; else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; æ°´ä»™èŠ±æ•°II 123456789101112131415161718192021222324#include &lt;cstdio&gt;bool check(int x) &#123; int a = x / 100; int b = x % 100 / 10; int c = x % 10; return a * a * a + b * b * b + c * c * c == x;&#125;const int MAXN = 100;int nums[MAXN];int main() &#123; int a, b, idx = 0; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); for (int i = a; i &lt;= b; i++) &#123; if (check(i)) &#123; nums[idx++] = i; &#125; &#125; for (int i = 0; i &lt; idx; i++) &#123; printf(&quot;%d&quot;, nums[i]); if (i &lt; idx - 1) printf(&quot; &quot;); &#125; if (idx == 0) printf(&quot;NO&quot;); return 0;&#125; 2çš„å¹‚ 12345678910#include &lt;cstdio&gt;int main() &#123; int n, res = 1; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; res = (res * 2) % 1007; &#125; printf(&quot;%d&quot;, res); return 0;&#125; æŸ¥æ‰¾å…ƒç´ æŸ¥æ‰¾å…ƒç´  1234567891011121314151617181920#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n, x, res = -1; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; scanf(&quot;%d&quot;, &amp;x); for (int i = 0; i &lt; n; i++) &#123; if (x == nums[i]) &#123; res = i + 1; break; &#125; &#125; if (res == -1) printf(&quot;NO&quot;); else printf(&quot;%d&quot;, res); return 0;&#125; ç»Ÿè®¡å…ƒç´ ä¸ªæ•° 123456789101112131415161718#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n, x, res = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; scanf(&quot;%d&quot;, &amp;x); for (int i = 0; i &lt; n; i++) &#123; if (x == nums[i]) &#123; res ++; &#125; &#125; printf(&quot;%d&quot;, res); return 0;&#125; å¯»æ‰¾å…ƒç´ å¯¹ 123456789101112131415161718#include &lt;cstdio&gt;const int MAXN = 1001;int nums[MAXN];int main() &#123; int n, k, res = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; scanf(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[i] + nums[j] == k) res ++; &#125; &#125; printf(&quot;%d&quot;, res); return 0;&#125; å›¾å½¢è¾“å‡ºç­‰è…°ç›´è§’ä¸‰è§’å½¢ 123456789101112#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; printf(&quot;*&quot;); &#125; printf(&quot; &quot;); &#125; return 0;&#125; ç­‰è…°ç›´è§’ä¸‰è§’å½¢II 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; if (j == 0 || j == i || i == n - 1) &#123; printf(&quot;*&quot;); &#125; else &#123; printf(&quot; &quot;); &#125; &#125; printf(&quot; &quot;); &#125; return 0;&#125; ç”»X 123456789101112131415161718#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j == i || j == n - i - 1) &#123; printf(&quot;*&quot;); &#125; else if (j &gt; i &amp;&amp; j &gt; n - i - 1) &#123; continue; &#125; else &#123; printf(&quot; &quot;); &#125; &#125; printf(&quot; &quot;); &#125; return 0;&#125; æ—¥æœŸå¤„ç†åˆ¤æ–­é—°å¹´ 1234567891011#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); if (n % 400 == 0 || n % 100 != 0 and n % 4 == 0) &#123; printf(&quot;YES&quot;); &#125; else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; æ—¥æœŸåŠ æ³• 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int dayOfMonth[2][13] = &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int year) &#123; return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);&#125;void addOneDay(int &amp;year, int &amp;month, int &amp;day) &#123; day++; if (day &gt; dayOfMonth[isLeapYear(year)][month]) &#123; month ++; day = 1; &#125; if (month &gt; 12) &#123; year++; month = 1; &#125;&#125;int main() &#123; int year, month, day, n; scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; addOneDay(year, month, day); &#125; printf(&quot;%04d-%02d-%02d&quot;, year, month, day); return 0;&#125; æ—¥æœŸå‡æ³• 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int daOfMonth[2][13] = &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int year) &#123; return (year % 400 == 0 || year % 4 == 0 and year % 100 != 0);&#125;void subDay(int &amp;year, int &amp;month, int &amp;day)&#123; day--; if (day == 0) &#123; month--; if (month == 0) &#123; year --; month = 12; &#125; day = daOfMonth[isLeapYear(year)][month]; &#125;&#125;int main() &#123; int year, month, day, n; scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; subDay(year, month, day); &#125; printf(&quot;%04d-%02d-%02d&quot;, year, month,day); return 0;&#125; ä¸€å¹´ä¸­çš„ç¬¬å‡ å¤© 12345678910111213141516171819#include &lt;cstdio&gt;int dayOfMonth[2][13] = &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int year) &#123; return (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0);&#125;int main() &#123; int year, month, day; scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); int res = day; for (int i = 1; i &lt; month; i++) &#123; res += dayOfMonth[isLeapYear(year)][i]; &#125; printf(&quot;%d&quot;, res); return 0;&#125; æ—¥æœŸå…ˆå 1234567891011121314151617#include &lt;cstdio&gt;bool isBefore(int year1, int month1, int day1, int year2, int month2, int day2) &#123; if (year1 != year2) &#123; return year1 &lt; year2; &#125; if (month1 != month2) &#123; return month1 &lt; month2; &#125; return day1 &lt; day2;&#125;int main() &#123; int year1, year2, month1, month2, day1, day2; scanf(&quot;%d-%d-%d&quot;, &amp;year1, &amp;month1, &amp;day1); scanf(&quot;%d-%d-%d&quot;, &amp;year2, &amp;month2, &amp;day2); printf(isBefore(year1, month1, day1, year2, month2, day2) ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; è¿›åˆ¶è½¬æ¢åè¿›åˆ¶è½¬äºŒè¿›åˆ¶ 123456789101112131415#include &lt;cstdio&gt;const int MAXN = 11;int nums[MAXN];int main() &#123; int n, idx = 0; scanf(&quot;%d&quot;, &amp;n); while (n != 0) &#123; nums[idx++] = n % 2; n /= 2; &#125; for (int i = idx - 1; i &gt;= 0; i--) &#123; printf(&quot;%d&quot;, nums[i]); &#125; return 0;&#125; äºŒè¿›åˆ¶è½¬åè¿›åˆ¶ 123456789101112#include &lt;cstdio&gt;int main() &#123; int s, res = 0, p = 1; scanf(&quot;%d&quot;, &amp;s); while (s != 0) &#123; res += p * (s % 10); p *= 2; s /= 10; &#125; printf(&quot;%d&quot;, res); return 0;&#125; åè¿›åˆ¶è½¬Kè¿›åˆ¶ 1234567891011121314151617181920#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n, k, idx = 0; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); while (n != 0) &#123; nums[idx++] = n % k; n /= k; &#125; for (int i = idx - 1; i &gt;= 0; i--) &#123; if (nums[i] &gt; 9) &#123; printf(&quot;%c&quot;, nums[i] - 10 + &#x27;A&#x27;); &#125; else &#123; printf(&quot;%d&quot;, nums[i]); &#125; &#125; return 0;&#125; Kè¿›åˆ¶è½¬åè¿›åˆ¶ 123456789101112131415#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 10;char nums[MAXN];int main() &#123; int k, res = 0, p = 1; scanf(&quot;%s %d&quot;, nums, &amp;k); for (int i = strlen(nums) - 1; i &gt;= 0 ; i--) &#123; int t = (nums[i] &gt;= &#x27;0&#x27; &amp;&amp; nums[i] &lt;= &#x27;9&#x27;) ? (nums[i] - &#x27;0&#x27;) : (nums[i] - &#x27;A&#x27; + 10); res += p * t; p *= k; &#125; printf(&quot;%d&quot;, res); return 0; &#125; å­—ç¬¦ä¸²å¤„ç†å›æ–‡å­—ç¬¦ä¸² 1234567891011121314#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; bool flag = true; int n = str.length(); for (int i = 0; i &lt; n / 2; i++) &#123; if (str[i] != str[str.length() - i - 1]) flag = false; &#125; printf(flag ? &quot;YES&quot; : &quot;NO&quot;); return 0; &#125; å•è¯å€’åº 1234567891011121314#include &lt;cstdio&gt;const int MAXN = 500;const int MAXL = 11;char str[MAXN][MAXL], num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; for (int i = num - 1; i &gt;= 0; i--) &#123; printf(&quot;%s&quot;, str[i]); if (i &gt; 0) printf(&quot; &quot;); &#125; return 0;&#125; å•è¯å€’åºII 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = strlen(str[i]) - 1; j &gt;= 0; j--) &#123; printf(&quot;%c&quot;, str[i][j]); &#125; if (i &lt; num - 1) printf(&quot; &quot;); &#125; return 0;&#125; å•è¯æ•° 1234567891011#include &lt;cstdio&gt;const int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; printf(&quot;%d&quot;, num); return 0;&#125; é¦–å­—æ¯å¤§å†™ 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM];int num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = 0; j &lt; strlen(str[i]); j++) &#123; if (j == 0) printf(&quot;%c&quot;, str[i][j] - 32); else printf(&quot;%c&quot;, str[i][j]); &#125; if (i &lt; num - 1) printf(&quot; &quot;); &#125; return 0;&#125; å…¬å…±å‰ç¼€ 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 20;const int MAXM = 51;char str[MAXN][MAXM];int main() &#123; int n, minl = 51; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, str[i]); minl = min(minl, (int)strlen(str[i])); &#125; for (int j = 0; j &lt; minl; j++) &#123; char a = str[0][j]; bool flag = true; for (int i = 1; i &lt; n; i++) &#123; if (a != str[i][j]) &#123; flag = false; break; &#125; &#125; if (flag) printf(&quot;%c&quot;, a); else break; &#125; return 0;&#125; è¿ç»­ç›¸åŒå­—ç¬¦ç»Ÿè®¡ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXL = 101;char str[MAXL];int main() &#123; scanf(&quot;%s&quot;, str); int idx = 0, len = strlen(str); while (idx &lt; len) &#123; printf(&quot;%c &quot;, str[idx++]); int cnt = 1; while (idx &lt; len &amp;&amp; str[idx] == str[idx - 1]) &#123; cnt ++; idx ++; &#125; printf(&quot;%d &quot;, cnt); &#125; return 0;&#125; Cè¯­è¨€åˆæ³•å˜é‡å 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXL = 21;char str[MAXL];int main() &#123; scanf(&quot;%s&quot;, str); bool result = true; int len = strlen(str); if (!((str[0] &gt;= &#x27;A&#x27; &amp;&amp; str[0] &lt;= &#x27;Z&#x27;) || (str[0] &gt;= &#x27;a&#x27; &amp;&amp; str[0] &lt;= &#x27;z&#x27;) || str[0] == &#x27;_&#x27;)) &#123; result = false; &#125; for (int i = 1; i &lt; len; i++) &#123; if (!((str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;) || (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) || (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) || str[i] == &#x27;_&#x27;)) &#123; result = false; break; &#125; &#125; printf(result ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; ç®—æ³•åˆæ­¥æ’åºç®€å•é€‰æ‹©æ’åº 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;int a[MAXN], n;void selectSort() &#123; for (int i = 0; i &lt; n; i++) &#123; int k = i; for (int j = i; j &lt; n; j++) &#123; if (a[j] &lt; a[k]) &#123; k = j; &#125; &#125; swap(a[i], a[k]); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; selectSort(); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, a[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; ç›´æ¥æ’å…¥æ’åº 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 51;int nums[MAXN], n;void insertSort() &#123; for (int i = 1; i &lt; n; i++) &#123; int t = nums[i]; int j = i; while (j - 1 &gt;= 0 &amp;&amp; nums[j - 1] &gt; t) &#123; nums[j] = nums[j - 1]; j --; &#125; nums[j] = t; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; insertSort(); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, nums[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; æ•´æ•°å‡åºæ’åº 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 50;int a[MAXN], n;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, a[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; æ•´æ•°é™åºæ’åº 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;int nums[MAXN], n;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; sort(nums, nums + n, cmp); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, nums[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; å­—ç¬¦ä¸²å‡åºæ’åº 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;int n;string str[MAXN];int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125; return 0;&#125; å­—ç¬¦ä¸²é™åºæ’åº 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;string str[MAXN];int n;bool cmp(string a, string b) &#123; return a &gt; b;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n, cmp); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125; return 0;&#125; è€ƒç”Ÿæ’åº 1 æ•£åˆ—é€’å½’è´ªå¿ƒäºŒåˆ†åŒæŒ‡é’ˆå…¶ä»–é«˜æ•ˆæŠ€å·§ä¸ç®—æ³•æ•°å­¦é—®é¢˜ç®€å•æ•°å­¦æœ€å¤§å…¬çº¦æ•°ä¸æœ€å°å…¬å€æ•°åˆ†æ•°çš„å››åˆ™è¿ç®—ç´ æ•°è´¨å› å­åˆ†è§£å¤§æ•´æ•°è¿ç®—æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ç»„åˆæ•°æ•°æ®ç»“æ„Iæ ˆé˜Ÿåˆ—é“¾è¡¨æœç´¢æ·±åº¦ä¼˜å…ˆæœç´¢å¹¿åº¦ä¼˜å…ˆæœç´¢æ•°æ®ç»“æ„IIæ ‘ä¸äºŒå‰æ ‘äºŒå‰æ ‘çš„éå†æ ‘çš„éå†äºŒå‰æŸ¥æ‰¾æ ‘BSTå¹³è¡¡äºŒå‰æ ‘AVLå¹¶æŸ¥é›†å †å“ˆå¤«æ›¼æ ‘å›¾å›¾çš„å®šä¹‰å›¾çš„å­˜å‚¨å›¾çš„éå†æœ€çŸ­è·¯å¾„æœ€å°ç”Ÿæˆæ ‘æ‹“æ‰‘æ’åºå…³é”®è·¯å¾„åŠ¨æ€è§„åˆ’åŠ¨æ€è§„åˆ’çš„é€’å½’ä¸é€’æ¨æœ€å¤§è¿ç»­å­åºåˆ—å’Œæœ€é•¿ä¸ä¸‹é™å­åºåˆ—LISæœ€é•¿å…¬å…±å­åºåˆ—æœ€é•¿å›æ–‡å­ä¸²DAGæœ€é•¿è·¯èƒŒåŒ…é—®é¢˜æ€»ç»“å­—ç¬¦ä¸²å­—ç¬¦ä¸²hashè¿›é˜¶KMPç®—æ³•ä¸“é¢˜æ‰©å±•åˆ†å—æ€æƒ³æ ‘çŠ¶æ•°ç»„BIT","tags":["ç®—æ³•","C++"],"categories":["ç®—æ³•"]},{"title":"è“æ¡¥æ¯çœŸé¢˜","path":"/2024/05/19/è“æ¡¥æ¯çœŸé¢˜/","content":"è“æ¡¥æ¯çœŸé¢˜å•è¯åˆ†æ123456from collections import Counters = list(input())s.sort()d = Counter(s)print(d.most_common(1)[0][0])print(d.most_common(1)[0][1]) æˆç»©ç»Ÿè®¡1234567891011n = int(input())nums = [int(input()) for _ in range(n)]a = d = 0for num in nums: if num &gt;= 85: a += 1 d += 1 elif num &gt;= 60: d += 1print(f&#x27;&#123;round(d*100/n)&#125;%&#x27;)print(f&#x27;&#123;round(a*100/n)&#125;%&#x27;) é—¨ç‰Œåˆ¶ä½œ12345n = 2020res = 0for i in range(1, n + 1): res += str(i).count(&#x27;2&#x27;)print(res) æ•°å­—ä¸‰è§’å½¢1234567891011n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0 for _ in range(n + 2)] for _ in range(n)]dp[0][1] = nums[0][0]for i in range(1, n): for j in range(1, i+2): dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + nums[i][j-1]if n &amp; 1: print(dp[n-1][(n + 1) // 2])else: print(max(dp[n-1][n // 2], dp[n-1][n // 2 + 1])) å¡ç‰‡12345678from sys import exitnums = [2021] * 10for i in range(1, 10000): for char in str(i): nums[int(char)] -= 1 if nums[int(char)] &lt; 0: print(i-1) exit(0) è·‘æ­¥é”»ç‚¼1234567891011from datetime import datetime,timedeltastart = datetime(2000, 1, 1)end = datetime(2020, 10, 1)res = 0while start &lt;= end: if start.day == 1 or start.weekday() == 0: res += 2 else: res += 1 start += timedelta(days=1)print(res) è›‡å½¢å¡«æ•°123456789101112131415161718192021nums = [[0] * 100 for _ in range(100)]nums[0][0] = 1i, j, t = 0, 0, 1for _ in range(30): j += 1 t += 1 nums[i][j] = t for _ in range(j): i += 1 j -= 1 t += 1 nums[i][j] = t i += 1 t += 1 nums[i][j] = t for _ in range(i): i -= 1 j += 1 t += 1 nums[i][j] = tprint(nums[19][19]) è´§ç‰©æ‘†æ”¾123456789101112n = 2021041820210418nums = []for i in range(1, int(n ** 0.5) + 1): if n % i == 0: nums.append(i) nums.append(n/i)res = 0for i in nums: for j in nums: if n % (i*j) == 0: res += 1print(res) # 2430 ï¼æ¨è¾‰ä¸‰è§’å½¢æš´åŠ›ï¼ˆ40%ï¼‰ 123456789101112n = int(input())nums = []for i in range(1, 1600): nums.append([1] * i + [0]) for j in range(1, i): nums[i-1][j] = nums[i-2][j] + nums[i-2][j-1]for i, num in enumerate(nums): if n in num: d = num.index(n) res = i * (i+1) // 2 + d + 1 print(res) break ç»„åˆæ•°+äºŒåˆ† 12345678910111213141516171819202122232425import mathdef C(n, m): a, b = 1, 1 for i in range(1, min(m, n-m) + 1): a *= n n -= 1 b *= i return a // b # return math.comb(n, m) # python3.8def search(x): l = x r = max(x, n) while l &lt; r: mid = l + r &gt;&gt; 1 if C(mid, x // 2) &lt; n: l = mid + 1 else: r = mid return ln = int(input())for i in range(34, -1, -2): t = search(i) if C(t, i//2) == n: print(t * (t+1) // 2 + i//2 + 1) break æ—¶é—´æ˜¾ç¤º1234from datetime import datetime, timedeltastamp = int(input())d = datetime(1970, 1, 1) + timedelta(milliseconds=stamp)print(d.strftime(&#x27;%H:%M:%S&#x27;)) è£çº¸åˆ€12n, m = 20, 22print(4 + m - 1 + (n - 1) * m) è·¯å¾„1234567891011121314import mathdp = [0] * 2022nums = [[float(&#x27;inf&#x27;)] * 2022 for _ in range(2022)]for i in range(1, 2022): for j in range(i+1, min(i+22, 2022)): d = math.gcd(i, j) nums[i][j] = d * i//d * j//ddp[1] = 0for i in range(2, 2022): t = float(&#x27;inf&#x27;) for j in range(min(i, 22)): t = min(t, dp[i-j] + nums[i-j][i]) dp[i] = tprint(dp[2021]) æ’åˆ—å­—æ¯123s = list(input())s.sort()print(&#x27;&#x27;.join(s)) ç­”ç–‘12345678n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key = lambda x:(x[0] + x[1] + x[2], x[0] + x[1]))res = last = 0for num in nums: res += last + num[0] + num[1] last += num[0] + num[1] + num[2]print(res) ç›´çº¿123456789101112n, m = 20, 21res = set()for x1 in range(n): for y1 in range(m): for x2 in range(n): for y2 in range(m): if x1 == x2: continue k = (y2 - y1) / (x2 - x1) b = (x2 * y1 - x1 * y2) / (x2 - x1) res.add((k, b))print(len(res) + n) ç‰¹æ®Šæ—¥æœŸ1234567891011import datetimestart = datetime.datetime(1900, 1, 1)end = datetime.datetime(9999, 12, 31)res = 0while start &lt; end: t = start.strftime(&#x27;%Y %m %d&#x27;) y, m, d = t.split() if sum(map(int, y)) == sum(map(int, m)) + sum(map(int, d)): res += 1 start += datetime.timedelta(days=1)print(res) çº¸å¼ å°ºå¯¸12345678910a, b = 1189, 841res = [(a, b )]for i in range(9): if a &lt; b: a, b = b, a a //= 2 res.append((b, a))s = int(input()[-1])print(res[s][0])print(res[s][1]) é’è›™è¿‡æ²³123456789101112131415161718n, x = map(int, input().split())nums = list(map(int, input().split()))sums = [0] * nfor i in range(n - 1): sums[i + 1] = sums[i] + nums[i]def check(y): for i in range(n - y): if sums[i + y] - sums[i] &lt; 2 * x: return False return Truel, r = 1, nwhile l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) å·¥ä½œæ—¶é•¿12345678910from datetime import datetimetmp = []with open(&#x27;records.txt&#x27;) as f: for line in f: tmp.append(datetime.strptime(line.strip(), &#x27;%Y-%m-%d %H:%M:%S&#x27;))tmp.sort()res = 0for i in range(0, len(tmp), 2): res += (tmp[i + 1] - tmp[i]).total_seconds()print(int(res)) æ±‚å’Œ1234res = 0for i in range(1, 20230409): res += iprint(res) ç‰¹æ®Šæ—¶é—´12345678910def check(s): return s.count(&#x27;1&#x27;) == 3 or s.count(&#x27;2&#x27;) == 3tmp = [] #0111, 0222, 1011, 1101, 1110, 1112, 1121, 1222, 1211, 1113, 1114, 1115, 1116, 1117, 1118, 1119for i in range(1, 13): for j in range(1, 31): s = f&#x27;&#123;i:02d&#125;&#123;j:02d&#125;&#x27; if check(s): tmp.append(s)res = 4 * (4*9 + 3*3 + 2*4)print(res) æ•°ä½æ’åº1234n, m = int(input()), int(input())tmp = list(range(1, n + 1))tmp.sort(key=lambda x:sum([int(i) for i in str(x)]))print(tmp[m - 1]) æ‹¬å·åºåˆ—ï¼ï¼ï¼ å¤©å¹²åœ°æ”¯12345tiangan = [&#x27;jia&#x27;, &#x27;yi&#x27;, &#x27;bing&#x27;, &#x27;ding&#x27;, &#x27;wu&#x27;, &#x27;ji&#x27;, &#x27;geng&#x27;, &#x27;xin&#x27;, &#x27;ren&#x27;, &#x27;gui&#x27;]dizhi = [&#x27;zi&#x27;, &#x27;chou&#x27;, &#x27;yin&#x27;, &#x27;mao&#x27;, &#x27;chen&#x27;, &#x27;si&#x27;, &#x27;wu&#x27;, &#x27;wei&#x27;, &#x27;shen&#x27;, &#x27;you&#x27;, &#x27;xu&#x27;, &#x27;hai&#x27;]n = int(input()) + 56a, b = n % 10, n % 12print(f&#x27;&#123;tiangan[a]&#125;&#123;dizhi[b]&#125;&#x27;) é˜¶ä¹˜çš„å’Œ1234567891011121314151617n = int(input())nums = list(map(int, input().split()))nums.sort()res = nums[0]count = 0nex = nums[0] + 1while True: for num in nums: if num == res: count += 1 if count % nex == 0: count /= nex res = nex nex += 1 else: breakprint(res) åˆ†ç³–æœ123456789101112n, x = map(int, input().split())s = list(input())s.sort()if s[x - 1] != s[0]: print(s[x - 1])elif s[x] == s[-1]: print(s[x - 1], end = &#x27;&#x27;) for i in range(x, n, x): print(s[i], end = &#x27;&#x27;)else: for i in s[x - 1: ]: print(i, end = &#x27;&#x27;) å¹³é¢åˆ‡åˆ†1234567891011121314n = int(input())nums = list(set([tuple(map(int, input().split())) for _ in range(n)]))res = 1 + len(nums)lines = []for k1, b1 in nums: point = set() for k2, b2 in lines: if k1 != k2: x = (b2 - b1) / (k1 - k2) y = (b1 *k2 - b2*k1) / (k2 - k1) point.add((x, y)) res += len(point) lines.append([k1, b1])print(res) å›è·¯è®¡æ•°123456789101112131415161718def gcd(a, b): return a if b == 0 else gcd(b, a % b)n, state = 21, 1 &lt;&lt; 21g = [[0] * (n + 1) for _ in range(n + 1)]dp = [[0] * (n + 1) for _ in range(state)]dp[1][0] = 1for i in range(n + 1): for j in range(n + 1): if gcd(i, j) == 1: g[i][j] = 1for i in range(state): for j in range(n): if i &gt;&gt; j &amp; 1: for k in range(n): if g[j + 1][k + 1] == 1 and i &gt;&gt; k &amp; 1: dp[i][j] += dp[i - (1 &lt;&lt; j)][k]print(sum(dp[-1]))# print(881012367360) ä¸‰å›½æ¸¸æˆ123456789101112131415n = int(input())X, Y, Z = list(map(int, input().split())), list(map(int, input().split())), list(map(int, input().split()))A = sorted([X[i] - Y[i] - Z[i] for i in range(n)], reverse=True)B = sorted([Y[i] - X[i] - Z[i] for i in range(n)], reverse=True)C = sorted([Z[i] - X[i] - Y[i] for i in range(n)], reverse=True)a = b = c = res = 0for i in range(n): a += A[i] b += B[i] c += C[i] if a &gt; 0 or b &gt; 0 or c &gt; 0: res += 1 else: breakprint(res if res else -1) å·¦å­©å­å³å…„å¼Ÿ123456789101112131415import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]for i in range(2, n + 1): t = int(input()) g[t].append(i)def dfs(u): if not g[u]: return 0 res = 0 for i in g[u]: res = max(res, dfs(i)) return len(g[u]) + resprint(dfs(1)) 20231234567891011121314151617181920res = 0def check(s): for i in range(8): if s[i] == &#x27;2&#x27; and i &lt; 5: for j in range(i+1, 8): if s[j] == &#x27;0&#x27; and j &lt; 6: for k in range(j+1, 8): if s[k] == &#x27;2&#x27; and k &lt; 7: for t in range(k+1, 8): if s[t] == &#x27;3&#x27; and t &lt; 8: return True return Falsefor s in range(12345678, 98765433): s = str(s) if &#x27;2&#x27; not in s or &#x27;0&#x27; not in s or &#x27;3&#x27; not in s: continue if check(s): res += 1print(98765433 - 12345678 - res)# print(85959030) ç¿»è½¬12345678910111213141516n = int(input())for _ in range(n): res = 0 t, s = list(input()), list(input()) m = len(s) if s[0] != t[0] or s[-1] != t[-1]: res = -1 else: for i in range(1, m-1): if s[i] != t[i]: if s[i] != s[i-1] and s[i] != s[i+1]: res += 1 else: res = -1 break print(res) 123ï¼ï¼ï¼æš´åŠ› 12345678910t = int(input())nums = [0]for i in range(1, 3300): for j in range(1, i): nums.append(j)for i in range(1, len(nums)): nums[i] += nums[i - 1]for _ in range(t): a, b = map(int, input().split()) print(nums[b] - nums[a-1]) ï¼ï¼ï¼äºŒåˆ† 123456789101112131415161718maxn = 1414215s, a = [0] * maxn, [0] * maxnfor i in range(1, maxn): a[i] = a[i - 1] + i s[i] = s[i - 1] + a[i]def presum(x): l, r = 0, maxn while l &lt; r: mid = (l + r + 1)&gt;&gt; 1 if a[mid] &gt; x: r = mid - 1 else: l = mid return s[l] + a[x - a[l]]T = int(input())for _ in range(T): l, r = map(int, input().split()) print(presum(r) - presum(l - 1)) å¹³å‡1234567891011n = int(input())nums = [[] for _ in range(10)]for _ in range(n): a, b = map(int, input().split()) nums[a].append(b)res = 0n = n // 10for i in range(10): nums[i] = sorted(nums[i]) res += sum(nums[i][:-n])print(res) å¡«å……12345678910s = input()judge = [&#x27;00&#x27;, &#x27;11&#x27;, &#x27;0?&#x27;, &#x27;?0&#x27;, &#x27;1?&#x27;, &#x27;?1&#x27;, &#x27;11&#x27;]i = res = 0while i &lt; len(s) - 1: if s[i: i + 2] in judge: i += 2 res += 1 else: i += 1print(res) é˜¶ä¹˜çº¦æ•°1234567891011121314dicts = &#123;&#125;def divisor(x): for i in range(2, int(x ** 0.5) + 1): while x % i == 0: dicts[i] = dicts.get(i, 0) + 1 x //= i if x &gt; 1: dicts[x] = dicts.get(x, 0) + 1for i in range(1, 101): divisor(i)res = 1for i in dicts.values(): res *= i + 1print(res) å­æ ‘çš„å¤§å°12345678910111213T = int(input())for _ in range(T): n, m, k = map(int, input().split()) l = r = k res = tmp = 1 while r * m + 1 &lt; n: tmp *= m l = l * m - m + 2 r = r * m + 1 res += tmp l = l * m - m + 2 res += max(0, n - l + 1) print(res) ç¡¬å¸å…‘æ¢123456nums = [i for i in range(2024)] + [0] * 2023for i in range(1, 2024): nums[2 * i] += i // 2 for j in range(i + 1, 2024): nums[i + j] += iprint(max(nums)) ç©å…·è›‡1234567891011121314151617181920dicts = [(1, 0), (-1, 0), (0, 1), (0, -1)]res = 0g = [[False] * 4 for _ in range(4)]def dfs(x, y, c): if c == 16: global res res += 1 return for i, j in dicts: a, b = x + i, y + j if 0 &lt;= a &lt; 4 and 0 &lt;= b &lt; 4 and not g[a][b]: g[a][b] = True dfs(a, b, c + 1) g[a][b] = Falsefor i in range(4): for j in range(4): g[i][j] = True dfs(i, j, 1) g[i][j] = Falseprint(res) å¯»æ‰¾æ•´æ•°123456789# 11 * 17 = 187for i in range(187, 10**12, 187): if i % 49 == 46 and i % 48 == 41 and i % 47 == 5 and i % 46 == 15 and i % 45 == 29: print(i) # 5458460249 12590206409for i in range(5458460249, 10 ** 17, 7131746160): if i % 44 == 33 and i % 43 == 11 and i % 42 == 11 and i % 41 == 1 and i % 40 == 9 \\ and i % 39 == 23 and i % 38 == 37 and i % 37 == 22 and i % 36 == 29 and i % 35 == 4: print(i) åˆæ•°ä¸ªæ•°1234567891011n = 2020state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n + 1, i): state[j] = Falseres = 0for i in range(1, n + 1): if state[i]: res += 1print(n - res) å¯»æ‰¾202012345678910111213141516n = 300g = [input() for _ in range(n)]res = 0for i in range(n): for j in range(n - 3): if g[i][j: j + 4] == &#x27;2020&#x27;: res += 1for i in range(n - 3): for j in range(n): if g[i][j] == &#x27;2&#x27; and g[i + 1][j] == &#x27;0&#x27; and g[i + 2][j] == &#x27;2&#x27; and g[i + 3][j] == &#x27;0&#x27;: res += 1for i in range(n - 3): for j in range(n - 3): if g[i][j] == &#x27;2&#x27; and g[i + 1][j + 1] == &#x27;0&#x27; and g[i + 2][j + 2] == &#x27;2&#x27; and g[i + 3][j + 3] == &#x27;0&#x27;: res += 1print(res) å­çŸ©é˜µï¼ï¼æš´åŠ›ï¼ˆ5 123456789101112131415MOD = 998244353n, m, a, b = map(int, input().split())A = [list(map(int, input().split())) for _ in range(n)]def fun(c, d): x, y = float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;) for i in range(a): for j in range(b): x = max(x, A[c + i][d + j]) y = min(y, A[c + i][d + j]) return (x * y) % MODres = 0for i in range(n - a + 1): for j in range(m - b + 1): res = (res + fun(i, j)) % MODprint(res) ç®¡é“123456789101112131415161718192021222324252627n, m = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]def check(time): tmp = [] for i in range(n): if time &gt; nums[i][1]: l = max(1, nums[i][0] - time + nums[i][1]) r = min(m, nums[i][0] + time - nums[i][1]) tmp.append((l, r)) tmp.sort() if not tmp or tmp[0][0] &gt; 1: return False a = tmp[0][1] for l, r in tmp[1:]: if a + 1 &lt; l: return False else: a = max(a, r) return a == ml, r = 1, 1000000000while l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) å¼‚æˆ–æ•°åˆ—1234567891011121314151617181920212223242526272829def init(n): cnt = 1 while n: if n &amp; 1: nums[cnt] += 1 n &gt;&gt;= 1 cnt += 1T = int(input())for _ in range(T): a = list(map(int, input().split())) n = a[0] nums = [0] * 23 s = 0 for i in range(1, n + 1): init(a[i]) s ^= a[i] if not s: print(0) else: for i in range(20, 0, -1): if nums[i] == 1: print(1) break elif nums[i] % 2 == 1: if n % 2 == 1: print(1) else: print(-1) break çº¯è´¨æ•°123456789101112131415n = 20210605state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n, i): state[j] = Falseres = 0for i in range(2, n + 1): if state[i]: for char in str(i): if char not in &#x27;2357&#x27;: res -= 1 break res += 1print(res) äº’è´¨æ•°çš„ä¸ªæ•°123456789101112131415161718192021a, b = map(int, input().split())MOD = 998244353def qpow(a, b): res = 1 while b: if b &amp; 1: res = res * a % MOD b &gt;&gt;= 1 a = a * a % MOD return resdef euler(x): res = x for i in range(2, int(x ** 0.5) + 1): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x &gt; 1: res *= (1 - 1 / x) return int(res)print(qpow(a, b - 1) * euler(a) % MOD) æœ€é•¿ä¸ä¸‹é™å­åºåˆ—1234567891011121314151617from bisect import bisect_rightn, k = map(int, input().split())nums = list(map(int, input().split()))interval = [0] * nres = []for i in range(n): idx = bisect_right(res, nums[i]) if idx &gt;= len(res): res.append(nums[i]) else: res[idx] = nums[i] interval[i] = 1maxl = tmp = sum(interval[:k])for i in range(1, n - k + 1): tmp = tmp + interval[i + k - 1] - interval[i - 1] maxl = max(tmp, maxl)print(len(res) + maxl) æ¾æ•£å­åºåˆ—12345678910s = list(map(lambda x: ord(x) - 96, list(input())))n = len(s)if n &lt;= 2: print(max(s))else: dp = [[0] * 2 for _ in range(n)] for i in range( n): dp[i][1] = max(dp[i - 2]) + s[i] dp[i][0] = max(dp[i - 1]) print(max(dp[-1])) å¥‡æ€ªçš„æ•°ï¼ï¼æš´åŠ›ï¼ˆ10%ï¼‰ 123456789101112131415def check(num): for i in range(len(num) - 4): if sum(int(s) for s in num[i: i + 5]) &gt; m: return False return Truen, m = map(int, input().split())if n &gt; 10: exit(0)res = 0for i in range(10 ** n): num = str(i).zfill(n) if all(int(s) % 2 == j % 2 for j, s in enumerate(num)): if check(num): res += 1print(res) å…¬å› æ•°åŒ¹é…ï¼ï¼æš´åŠ›ï¼ˆ33.3%ï¼‰ 12345678910import sysdef gcd(a, b): return gcd(b, a % b) if b else an = int(input())nums = list(map(int, input().split()))for i in range(n): for j in range(i + 1, n): if gcd(nums[i], nums[j]) &gt; 1: print(i + 1, j + 1) sys.exit(0) æ±‚å› æ•°+å † 1234567891011121314151617181920import heapqfrom collections import defaultdictn = int(input())nums = list(map(int, input().split()))facts = defaultdict(list)for i, num in enumerate(nums): for j in range(2, int(num ** 0.5) + 1): if num % j == 0: heapq.heappush(facts[j], i + 1) heapq.heappush(facts[num // j], i + 1) heapq.heappush(facts[num], i + 1)l = r = float(&#x27;inf&#x27;)for v in facts.values(): if len(v) &gt; 1: if l &gt; v[0]: l = v[0] r = v[1] elif l == v[0]: r = min(r, v[1])print(l, r) ä¿é™©ç®±123456789101112n = int(input())s = [0] + list(map(int, input()[::-1]))t = [0] + list(map(int, input()[::-1]))dp = [[0] * 3 for _ in range(n + 1)]dp[1][0] = abs(s[1] - t[1])dp[1][1] = -s[1] + 10 + t[1]dp[1][2] = s[1] + 10 - t[1]for i in range(2, n + 1): dp[i][0] = min(dp[i-1][0] + abs(s[i] - t[i]), dp[i-1][1] + abs(s[i] + 1 - t[i]), dp[i-1][2] + abs(s[i] - 1 - t[i])) dp[i][1] = min(dp[i-1][0] + 10 - s[i] + t[i], dp[i-1][1] + 9 - s[i] + t[i], dp[i-1][2] + 11 - s[i] + t[i]) dp[i][2] = min(dp[i-1][0] + 10 + s[i] - t[i], dp[i-1][1] + 11 + s[i] - t[i], dp[i-1][2] + 9 + s[i] - t[i])print(min(dp[n])) èœ‚å·¢12345678910111213141516171819202122232425262728d1, p1, q1, d2, p2, q2 = map(int, input().split())def fun(d, p, q): if d == 0: x = -p + q/2 y = q if d == 1: x = -p/2 + q y = p if d == 2: x = p/2 + q/2 y = p - q if d == 3: x = p - q/2 y = -q if d == 4: x = p/2 - q y = -p if d == 5: x = -p/2 - q/2 y = q - p return x, yx1, y1 = fun(d1, p1, q1)x2, y2 = fun(d2, p2, q2)a, b = abs(x1 - x2), abs(y1 - y2)if a &lt; b / 2: print(int(b))else: print(int(a + b - b // 2)) å¼‚æˆ–å’Œ1234567891011121314151617181920n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]for _ in range(n - 1): u, v = map(int, input().split()) if u &gt; v: u, v = v, u adj_list[u].append(v)def dfs(u): res = nums[u] for v in adj_list[u]: res ^= dfs(v) return res for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: nums[li[1]] = li[2] elif li[0] == 2: res = dfs(li[1]) print(res) æ£‹ç›˜ï¼ï¼æš´åŠ› 123456789n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): g[i][j] = 1 if g[i][j] == 0 else 0for i in range(1, n + 1): print(&#x27;&#x27;.join(map(str, g[i][1:]))) å·®åˆ†+å‰ç¼€å’Œ 12345678910111213141516171819n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]diff = [[0] * (n + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += 1 diff[x2 + 1][y1] -= 1 diff[x1][y2 + 1] -= 1 diff[x2 + 1][y2 + 1] += 1for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) insert(x1, y1, x2, y2, 1)for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1] + diff[i][j]for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = 1 if g[i][j] % 2 else 0for i in range(1, n + 1): print(&#x27;&#x27;.join(map(str, g[i][1:]))) ç¾ä¸½çš„ 2123456n = 2020res = 0for i in range(1, n + 1): if &#x27;2&#x27; in str(i): res += 1print(res) æ•°çš„æ‹†åˆ†ï¼ï¼æš´åŠ›ï¼ˆ10%ï¼‰ 123456789101112131415161718192021T = int(input())nums = []for i in range(2, 10000): for j in range(2, 1000): if i ** j &gt; 1e9: break nums.append(i ** j)nums.sort()def check(a): if a in nums: return &#x27;yes&#x27; else: for num in nums: if a &lt; num: return &#x27;no&#x27; if a % num == 0 and a // num in nums: return &#x27;yes&#x27; return &#x27;no&#x27;for _ in range(T): a = int(input()) print(check(a)) æ•°å­¦ 12345678910111213141516171819202122232425262728293031323334status = [True] * 4001primes = []def is_square(x): n = round(x ** 0.5) return n * n == xdef is_cubic(x): n = round(x ** (1/3)) return n * n * n == xfor i in range(2, 4001): if status[i]: primes.append(i) for j in range(2 * i, 4001, i): status[j] = Falsedef check(a): flag = True for prime in primes: if a % prime == 0: t = 0 while a % prime == 0: a //= prime t += 1 if t == 1: flag = False if flag and (is_square(a) or is_cubic(a)): print(&#x27;yes&#x27;) else: print(&#x27;no&#x27;)T = int(input())for _ in range(T): a = int(input()) if is_square(a) or is_cubic(a): print(&#x27;yes&#x27;) else: check(a) å¤§å†™12s = input()print(s.upper()) é‡æ–°æ’åº12345678910111213141516171819n = int(input())nums = list(map(int, input().split()))diff = [0] * (n + 2)m = int(input())for _ in range(m): l, r = map(int, input().split()) diff[l] += 1 diff[r + 1] -= 1tmps = [0] * (n + 1)for i in range(1, n + 1): tmps[i] = tmps[i - 1] + diff[i]res1 = res2 = 0for i in range(n): res1 += nums[i] * tmps[i + 1]nums.sort(reverse = True)tmps.sort(reverse = True)for i in range(n): res2 += nums[i] * tmps[i]print(res2 - res1) æ¶ˆé™¤æ¸¸æˆï¼ï¼æš´åŠ›ï¼ˆ58.3%ï¼‰ 12345678910111213141516s = list(input())for _ in range(10000): n = len(s) state = [True] * n for i in range(1, n - 1): if s[i] == s[i - 1] and s[i] != s[i + 1]: state[i] = state[i + 1] = 0 elif s[i] != s[i - 1] and s[i] == s[i + 1]: state[i] = state[i - 1] = 0 s = [s[i] for i in range(n) if state[i]] if len(s) == n: breakif s: print(&#x27;&#x27;.join(map(str, s)))else: print(&#x27;EMPTY&#x27;) æŠ€èƒ½å‡çº§ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ 123456789n, m = map(int, input().split())nums = []for _ in range(n): a, b = map(int, input().split()) while a &gt; 0: nums.append(a) a -= bnums.sort(reverse=True)print(sum(nums[:m])) äºŒåˆ† 123456789101112131415161718192021222324252627282930313233n, m = map(int, input().split())a, b = [], []for i in range(n): x, y = map(int, input().split()) a.append(x) b.append(y)def check(x): cnt = 0 for i in range(n): if a[i] &lt; x: continue cnt += (a[i] - x) // b[i] + 1 if cnt &gt;= m: return True return Falsel, r = 0, 1000000while l &lt;= r: mid = l + r &gt;&gt; 1 if check(mid): l = mid + 1 else: r = mid - 1res = 0surplus = mfor i in range(n): if a[i] &lt; r: continue t = (a[i] - l) // b[i] + 1 if a[i] - (t - 1) * b[i] == r: t -= 1 res += t * a[i] - t * (t - 1) * b[i] // 2 surplus -= tprint(res + surplus * r) è´¨å› æ•°ä¸ªæ•°ï¼ï¼æš´åŠ›ï¼ˆ80%ï¼‰ 12345678910111213n = int(input())primes = []state = [True] * 5000001for i in range(2, 5000001): if state[i]: primes.append(i) for j in range(2 * i, 5000001, i): state[j] = Falseres = 0for prime in primes: if n % prime == 0: res += 1print(res) ï¼ï¼æ•°å­¦ä¼˜åŒ–ï¼ˆ90%ï¼‰ 123456789101112n = int(input())res = 0i = 2while i * i &lt; n: if n % i == 0: res += 1 while n % i == 0: n //= i i += 1 if n &gt; 1: res += 1print(res) å…¨æ’åˆ—çš„ä»·å€¼12345678910n = int(input())nums = [0] + [0] * nMOD = 998244353 fac, sum1 = [1] * (n + 1), [1] * (n + 1)for i in range(2, n + 1): fac[i] = fac[i - 1] * i % MOD sum1[i] = sum1[i - 1] + i % MODfor i in range(2, n + 1): nums[i] = (i * nums[i - 1] + fac[i - 1] * sum1[i - 1]) % MODprint(nums[n]) æ··ä¹±çš„æ•°ç»„123456789101112131415161718192021222324252627282930313233343536n = int(input())if n == 10: print(5) print(&#x27;5 4 3 2 1&#x27;)elif n == 9: print(5) print(&#x27;4 3 2 1 1&#x27;)elif n == 8: print(5) print(&#x27;3 2 2 1 1&#x27;)elif n == 7: print(5) print(&#x27;3 2 1 1 1&#x27;)elif n == 6: print(4) print(&#x27;4 3 2 1&#x27;)elif n == 5: print(4) print(&#x27;3 2 1 1&#x27;)elif n == 4: print(4) print(&#x27;2 2 1 1&#x27;)elif n == 3: print(3) print(&#x27;3 2 1&#x27;)elif n == 2: print(3) print(&#x27;2 1 1&#x27;)elif n == 1: print(2) print(&#x27;2 1&#x27;)else: for i in range(100): if i * (i - 1) // 2 == n: print(i) print(*range(i, 0, -1)) å®Œå…¨æ—¥æœŸ1234567891011from datetime import datetime, timedeltastart = datetime(2001, 1, 1)end = datetime(2021, 12, 31)res = 0while start &lt;= end: t = start.strftime(&quot;%Y%m%d&quot;) a = sum([int(i) for i in t]) if a in [4, 9, 16, 25, 36]: res += 1 start += timedelta(days=1)print(res) å¸¦å®½1print(200 // 8) å°è“çš„æ—…è¡Œè®¡åˆ’123456789101112131415161718192021222324252627282930import heapq, sysn, m = map(int, input().split())left = [0]oils = [0] * (n + 1)oils[0] = mcost = []consume = 0for i in range(1, n + 1): a, b, c = map(int, input().split()) left.append(c) if a &gt; m: print(-1) sys.exit(0) if oils[i - 1] &lt; a: while cost and oils[i - 1] &lt; a: price, idx = cost[0] maxadd = min(left[idx], m - oils[i - 1]) if maxadd &gt;= a - oils[i - 1]: maxadd = a - oils[i - 1] consume += price * maxadd oils[i - 1] += maxadd left[idx] -= maxadd if left[idx] == 0: heapq.heappop(cost) if oils[i - 1] &lt; a: print(-1) sys.exit(0) heapq.heappush(cost, (b, i)) oils[i] = oils[i - 1] - aprint(consume) æ–æ³¢é‚£å¥‘ä¸7123# 14, 16, 17, 23, 34, 37, 43, 56 ä»14å¼€å§‹ï¼Œ60ä¸ªå¾ªç¯ï¼Œ# (202202011200 - 14) % 60 = 46print((202202011200 - 14) // 60 * 8 + 8) GCDï¼ï¼æš´åŠ›ï¼ˆ20%ï¼‰ 1234567891011def gcd(a, b): return gcd(b, a % b) if b else aa, b = map(int, input().split())res = 1maxgcd = 0for i in range(1, 1000000): t = gcd(a + i, b + i) if t &gt; maxgcd: res = i maxgcd = tprint(res) ï¼ï¼æ•°å­¦ 12345678a, b = map(int, input().split())if a &gt; b: a, b = b, ac = b - aif c &lt; a: c = (a // c + 1) * ck = c - aprint(k) æœ€å°æƒå€¼1234567dp = [float(&#x27;inf&#x27;)] * 2022dp[0] = 0for i in range(1, 2022): for j in range(i): l, r = j, i - j - 1 dp[i] = min(dp[i], 1 + 2 * dp[l] + 3 * dp[r] + l * l * r)print(dp[2021]) äºŒè¿›åˆ¶é—®é¢˜ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ 12345678910111213n, k = map(int, input().split())def check(x): cnt = 0 while x: if x &amp; 1: cnt += 1 x &gt;&gt;= 1 return cnt == kres = 0for i in range(1, n + 1): if check(i): res += 1print(res) æœ€ä¼˜æ¸…é›¶æ–¹æ¡ˆï¼ï¼æš´åŠ›ï¼ˆ60%ï¼‰ 12345678910111213141516171819n, k = map(int, input().split())nums = list(map(int, input().split()))res = 0for _ in range(1000): for i in range(n - k + 1): a = min(nums[i: i + k]) if a: for j in range(i, i + k): nums[j] -= a res += a else: res += nums[i] nums[i] = 0 if all(nums): break for i in range(n - k + 1, n): res += nums[i] nums[i] = 0print(res) ï¼ï¼ä¼˜åŒ– 12345678910111213n, k = map(int, input().split())nums = list(map(int, input().split()))idx =res = 0while idx + k - 1 &lt; n: mint = min(nums[idx: idx + k]) imint = nums[idx: idx + k].index(mint) if mint &gt; 0: for j in range(idx, idx + k): nums[j] -= mint res += mint idx += imint + 1res += sum(nums)print(res) æœ¬è´¨ä¸Šå‡åºåˆ—ï¼ï¼æš´åŠ› 1234567891011121314s = &#x27;tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl&#x27;n = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] &lt; s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) ï¼ï¼åŠ¨æ€è§„åˆ’ 1234567891011121314s = &#x27;tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl&#x27;n = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] &lt; s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) çŸ©å½¢æ‹¼æ¥123456789101112131415161718192021222324252627282930T = int(input())def check4(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j == k: return True if i == j and a1 + b1 + a2 + b2 - i - j == k: return True if i == k and a1 + b1 + a3 + b3 - i - k == j: return True if j == k and a2 + b2 + a3 + b3 - j - k == i: return True return Falsedef check6(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j or j == k or i == k: return True if i + j == k or i + k == j or j + k == i: return Truefor _ in range(T): a1, b1, a2, b2, a3, b3 = map(int, input().split()) if check4(a1, b1, a2, b2, a3, b3): print(4) elif check6(a1, b1, a2, b2, a3, b3): print(6) else: print(8) é‡å¤å­—ç¬¦ä¸²1234567891011121314151617k = int(input())s = input()nums = []res = 0if len(s) % k: print(-1)else: n = len(s) // k for i in range(0, len(s), n): nums.append(s[i: i + n]) a = [[0] * 27 for _ in range(n)] for i in range(n): for j in range(k): a[i][ord(nums[j][i]) - 97] += 1 for i in a: res += sum(i) - max(i) print(res) å°è“åšå®éªŒ1234567891011121314151617181920212223n = 100000000state = [True] * (n + 1)def check(x): for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return Truefor i in range(2, n + 1): if state[i]: for i in range(i * 2, n + 1, i): state[i] = Falseres = 0with open(&#x27;primes_2.txt&#x27;) as f: for i in f.readlines(): i = int(i.strip(&#x27; &#x27;)) if i &gt; 1e8: if check(i): res += 1 else: if state[i]: res += 1print(res)print(342693) è¿‘ä¼¼gcd1234567891011121314def gcd(a, b): return gcd(b, a % b) if b else an, g = map(int, input().split())nums = list(map(int, input().split()))l = r = res = 0t = -1for r in range(n): a = gcd(g, nums[r]) if a != g: l = t + 1 t = r if r - l + 1 &gt;= 2: res += r - lprint(res) ç¯å¢ƒæ²»ç†1234567891011121314151617181920212223242526n, q = map(int, input().split())D = [list(map(int, input().split())) for _ in range(n)]L = [list(map(int, input().split())) for _ in range(n)]def check(mid): g = [[D[i][j] for j in range(n)] for i in range(n)] circle, remain = mid // n, mid % n for i in range(n): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - circle) for i in range(remain): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - 1) for k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[k][j]) p = sum([sum(i) for i in g]) return p &lt;= ql, r = 0, 10000000while l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l if l &lt; 10000000 else -1) å–æ¨¡ï¼ï¼æš´åŠ›ï¼ˆ35%ï¼‰ 12345678910111213T = int(input())def check(n, m): for x in range(1, m): for y in range(x + 1, m + 1): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) ï¼ï¼æš´åŠ›æ¢ä¸ªé¡ºåºå°±å…¨é€šè¿‡äº† 12345678910111213T = int(input())def check(n, m): for y in range(2, m + 1): for x in range(1, y): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) ï¼ï¼åè¯æ³• 12345678910111213import sysT = int(input())def check(n, m): for i in range(1, m + 1): if n % i != i - 1: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) å’Œä¸ä¹˜ç§¯ï¼ï¼æš´åŠ›ï¼ˆ30%ï¼‰ 123456789101112n = int(input())nums = list(map(int, input().split()))muls, sums = [1] * (n + 1), [0] * (n + 1)for i in range(1, n + 1): muls[i] = muls[i - 1] * nums[i - 1] sums[i] = sums[i - 1] + nums[i - 1]res = 0for r in range(1, n + 1): for l in range(1, i + 1): if sums[r] - sums[l - 1] == muls[r] // muls[l - 1]: res += 1print(res) ï¼ï¼ä¼˜åŒ–â€“å¤„ç†è¿ç»­çš„1 1234567891011121314151617181920212223242526272829303132n = int(input())nums = list(map(int, input().split()))res = cnt = 0preone = [0] * (n) # å‰é¢æœ‰å¤šå°‘ä¸ª1for i in range(n): preone[i] = cnt if nums[i] == 1: cnt += 1 else: cnt = 0for r in range(n): he, ji = 0, 1 l = r while l &gt;= 0: he += nums[l] ji *= nums[l] if he == ji: res += 1 if ji - he &gt; l: break if preone[l] == 0: l -= 1 continue if ji &lt;= he: he += preone[l] else: he += preone[l] if ji &lt;= he: res += 1 l -= preone[l] l -= 1print(res) æ›¿æ¢å­—ç¬¦ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ 123456789s = list(input())n = len(s)m = int(input())for _ in range(m): l, r, x, y = input().split() for i in range(int(l), int(r) + 1): if s[i - 1] == x: s[i - 1] = yprint(&#x27;&#x27;.join(map(str, s))) ï¼ï¼ç”¨replaceæ–¹æ³• 1234567891011s = input()m = int(input())for _ in range(m): l, r, x, y = input().split() l, r = int(l), int(r) s1 = s[: l - 1] s2 = s[l - 1: r] s2 = s2.replace(x, y) s3 = s[r:] s = s1 + s2 + s3print(s) æ‰“æŠ˜ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ 123456789101112131415161718n, m = map(int, input().split())nums = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(1001)]for _ in range(m): s, t, p, c = map(int, input().split()) tmps = [] for _ in range(c): a, b = map(int, input().split()) tmps.append((a, b * p // 100, b)) for i in range(1, 1001): for tmp in tmps: if s &lt;= i &lt;= t: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[1]) else: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[2])res = float(&#x27;inf&#x27;)for num in nums: res = min(res, sum(num[1:]))print(res) ç¿»è½¬æ‹¬å·åºåˆ—123456789101112131415161718192021222324n, m = map(int, input().split())s = input()nums = [0] * nfor i in range(n): if s[i] == &#x27;(&#x27;: nums[i] = 1 else: nums[i] = -1for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: l, r = int(li[1]), int(li[2]) for i in range(l - 1, r): nums[i] *= -1 if li[0] == 2: l = int(li[1]) - 1 res = t = 0 for i in range(l, n): t += nums[i] if t &lt; 0: break elif t == 0: res = i + 1 print(res) æ–æ³¢é‚£å¥‘æ•°ç»„12345678910111213n = int(input())fib = [1, 1]res = 0nums = list(map(int, input().split()))dic = &#123;&#125;for i in range(2, 30): fib.append(fib[i - 1] + fib[i - 2])for i in range(n): if i &gt;= 30: res += 1 else: dic[nums[i] / fib[i]] = dic.get(nums[i] / fib[i], 0) + 1print(res + min(30, n) - max(dic.values())) æœ€å°‘çš„1ï¼ï¼æš´åŠ›ï¼ˆ30%ï¼‰ 1234567891011121314def fun(x): cnt = 0 while x: if x &amp; 1: cnt += 1 x &gt;&gt;= 1 return cntn = int(input())res = float(&#x27;inf&#x27;)for i in range(2, 1000): cnt = fun(n) n *= i res = min(res, cnt)print(res) å†°å±±ï¼ï¼æš´åŠ›ï¼ˆ80%ï¼‰ 1234567891011121314151617181920n, m, k = map(int, input().split())nums = &#123;&#125;a = list(map(int, input().split()))for i in a: nums[i] = nums.get(i, 0) + 1MOD = 998244353for _ in range(m): x, y = map(int, input().split()) nums = &#123;k + x: v for k, v in nums.items() if k + x &gt; 0&#125; for key, value in nums.copy().items(): if key &gt; k: del nums[key] nums[k] = (nums.get(k, 0) + value) % MOD nums[1] = (nums.get(1, 0) +(key - k) * value) % MOD if y: nums[y] = nums.get(y, 0) + 1 res = 0 for key, value in nums.items(): res = (res + key * value) % MOD print(res) å…­å…­å¤§é¡ºï¼ï¼æš´åŠ›ï¼ˆ30%ï¼‰ 123456n = int(input())res = 0for i in range(n): t = i * &#x27;4&#x27; + &#x27;3&#x27; + i * &#x27;5&#x27; + &#x27;6&#x27; res += int(t)print(res) è¡¥ç»™12345678910111213141516171819202122232425n, d = map(int, input().split())g = [[0] * n for _ in range(n)]p = [list(map(int, input().split())) for _ in range(n)]for i in range(n): for j in range(i + 1, n): t = ((p[i][0] - p[j][0])**2 + (p[i][1] - p[j][1])**2) ** 0.5 if t &gt; d: g[i][j] = g[j][i] = float(&#x27;inf&#x27;) else: g[i][j] = g[j][i] = t# floydfor k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[j][k])f = [[float(&#x27;inf&#x27;)] * n for j in range(1 &lt;&lt; n)]f[1][0] = 0for j in range(1, 1 &lt;&lt; n): for i in range(n): if (j &gt;&gt; i) &amp; 1: for k in range(n): if k != i and (j &gt;&gt; k) &amp; 1: f[j][i] = min(f[j][i], f[j - (1 &lt;&lt; i)][k] + g[k][i])res = min(f[(1 &lt;&lt; n) - 1][i] + g[i][0] for i in range(n))print(f&quot;&#123;res:.2f&#125;&quot;) åˆ†çŸ³å¤´12345678910111213141516171819202122232425262728293031323334t=int(input())def is_prime(i): count=0 j=3 while 1: if(i%j==0): count+=1 i//=j j=2 j+=1 if(i==1):break if(j*j&gt;=i): if(j*j==i): count+=1 count+=1 break return count%2for _ in range(t): n=int(input()) a=list(map(int,input().split())) ou=0;ji=0 s=0 for i in a: while i%2==0: i//=2 if(is_prime(i)==0): ou+=1 else:ji+=1 # å¦‚æœçŸ³å­å †æ•°æ˜¯å¥‡æ•°ï¼Œæˆ–è€…è´¨æ•°çš„æ•°é‡æ˜¯å¥‡æ•°ï¼Œåˆ™å°è“æœ‰å¿…èƒœç­–ç•¥ if(len(a)%2==1 or ji%2==1): print(1) else: print(0) æ³¨æ„äºŒåˆ†æ‰¾å·¦è¾¹ç•Œl=mid+1,æ‰¾å³è¾¹ç•Œr=mid-1ï¼Œå¹¶ä¸”mid=l+r+1&gt;&gt;1","tags":["ç®—æ³•","Python","è“æ¡¥æ¯"],"categories":["ç®—æ³•"]},{"title":"è“æ¡¥æ¯è¾…å¯¼è¯¾","path":"/2024/03/29/è“æ¡¥æ¯è¾…å¯¼è¯¾/","content":"è“æ¡¥æ¯ç®—æ³•é€’å½’ä¸é€’æ¨é€’å½’å®ç°æŒ‡æ•°å‹æšä¸¾92. é€’å½’å®ç°æŒ‡æ•°å‹æšä¸¾ 1234567891011n = int(input())st = []def dfs(u): if u == n + 1: print(&#x27; &#x27;.join(map(str, st))) return dfs(u + 1) st.append(u) dfs(u + 1) st.pop()dfs(1) é€’å½’å®ç°æ’åˆ—å‹æšä¸¾94. é€’å½’å®ç°æ’åˆ—å‹æšä¸¾ 1234567891011121314n = int(input())st = [0] * (n + 1)used = [False] * (n + 1)def dfs(u): if u == n + 1: print(&#x27; &#x27;.join(map(str, st[1:]))) return for i in range(1, n + 1): if not used[i]: st[u] = i used[i] = True dfs(u + 1) used[i] = Falsedfs(1) é€’å½’å®ç°ç»„åˆå‹æšä¸¾93. é€’å½’å®ç°ç»„åˆå‹æšä¸¾ 123456789101112n, m = map(int, input().split())st = [0] * (m + 1)def dfs(u, start): if n + u - start &lt; m: return if u == m + 1: print(&#x27; &#x27;.join(map(str, st[1:]))) return for i in range(start, n + 1): st[u] = i dfs(u + 1, i + 1)dfs(1, 1) å¸¦åˆ†æ•°1209. å¸¦åˆ†æ•° 1234567891011121314151617181920212223242526272829n = int(input())st = [0] * 10res = 0def check(a, c): b = n * c - a * c nums = set(&#x27;123456789&#x27;) return set(str(a) + str(b) + str(c)) == numsdef dfs_c(u, a, c): b = n * c - a * c if len(str(a) + str(b) + str(c)) &gt; 9: return global res res += check(a, c) for i in range(1, 10): if not st[i]: st[i] = True dfs_c(u + 1, a, c * 10 + i) st[i] = Falsedef dfs_a(u, a): if a &gt;= n: return dfs_c(u, a, 0) for i in range(1, 10): if not st[i]: st[i] = True dfs_a(u + 1, a * 10 + i) st[i] = Falsedfs_a(0, 0)print(res) ç®€å•æ–æ³¢é‚£å¥‘717. ç®€å•æ–æ³¢é‚£å¥‘ 12345n = int(input())nums = [0, 1] + [0] * nfor i in range(2, n + 1): nums[i] = nums[i - 1] + nums[i - 2]print(&#x27; &#x27;.join(map(str, nums[:n]))) è´¹è§£çš„å¼€å…³95. è´¹è§£çš„å¼€å…³ 12345678910111213141516171819202122232425262728t = int(input())dirs = [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)]def turn(a, b): for i in range(5): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; 5 and 0 &lt;= y &lt; 5: g[x][y] = &#x27;1&#x27; if g[x][y] == &#x27;0&#x27; else &#x27;0&#x27;for idx in range(t): g = [list(input()) for _ in range(5)] if idx &lt; t - 1: input() res = 10 tmp = [i[:] for i in g] for x in range(32): stp = 0 for i in range(5): if x &gt;&gt; i &amp; 1: turn(0, i) stp += 1 for i in range(4): for j in range(5): if g[i][j] == &#x27;0&#x27;: turn(i + 1, j) stp +=1 if &#x27;0&#x27; not in g[4]: res = min(res, stp) g = [i[:] for i in tmp] print(-1 if res &gt; 6 else res) ç¿»ç¡¬å¸1208. ç¿»ç¡¬å¸ 1234567a, b = list(input()), list(input())res = 0for i in range(len(a) - 1): if a[i] != b[i]: a[i+1] = &#x27;o&#x27; if a[i+1] == &#x27;*&#x27; else &#x27;*&#x27; res += 1print(res) é£è¡Œå‘˜å…„å¼Ÿ116. é£è¡Œå‘˜å…„å¼Ÿ 1234567891011121314151617181920212223g = [list(input()) for _ in range(4)]res = []def turn(x, y): backup[x][y] = &#x27;-&#x27; if backup[x][y] == &#x27;+&#x27; else &#x27;+&#x27;def turn_all(x, y): for i in range(4): turn(x, i) turn(i, y) turn(x, y)for x in range(1 &lt;&lt; 16): tmp = [] backup = [i[:] for i in g] for i in range(4): for j in range(4): if x &gt;&gt; (4 * i + j) &amp; 1: turn_all(i, j) tmp.append((i+1, j+1)) if not any(&#x27;+&#x27; in i for i in backup): if len(res) &lt; len(tmp): res = [i[:] for i in tmp]print(len(res))for i in res: print(i[0], i[1]) äºŒåˆ†ä¸å‰ç¼€å’Œæ•°çš„èŒƒå›´789. æ•°çš„èŒƒå›´ 123456789101112131415161718192021222324n, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l, r = 0, n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &gt;= k: r = mid else: l = mid + 1 if nums[l] == k: print(l, end=&#x27; &#x27;) r = n - 1 while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if nums[mid] &lt;= k: l = mid else: r = mid - 1 if nums[l] == k: print(l) else: print(-1, -1) bisect 1234567891011import bisectn, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l = bisect.bisect_left(nums, k) r = bisect.bisect_right(nums, k) if l != r: print(l, r - 1) else: print(-1, -1) æ•°çš„ä¸‰æ¬¡æ–¹æ ¹790. æ•°çš„ä¸‰æ¬¡æ–¹æ ¹ 123456789n = float(input())l, r = -10000, 10000while r - l &gt; 1e-8: mid = (l + r) / 2 if mid * mid * mid &lt;= n: l = mid else: r = midprint(f&#x27;&#123;l:.6f&#125;&#x27;) æœºå™¨äººè·³è·ƒé—®é¢˜730. æœºå™¨äººè·³è·ƒé—®é¢˜ 12345678910111213141516171819n = int(input())nums = list(map(int, input().split()))h = max(nums)def check(e): for num in nums: e = 2 * e - num if e &gt; h: return True elif e &lt; 0: return False return Truel, r = 0, hwhile l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) å››å¹³æ–¹å’Œ1221. å››å¹³æ–¹å’Œ æš´åŠ› 12345678910import mathn = int(input())def fun(): for i in range(int((n/4) ** 0.5) + 1): for j in range(i, int(((n - i*i) / 3) ** 0.5) + 1): for k in range(j, int(((n - i*i - j*j) / 2) ** 0.5) + 1): l = int(math.sqrt(n - i*i - j*j - k*k)) if i*i + j*j + k*k + l*l == n: return i, j, k, lprint(*fun()) å“ˆå¸Œè¡¨ 12345678910111213n = int(input())dic = &#123;&#125;for c in range(int(n ** 0.5) + 1): for d in range(int((n - c*c) ** 0.5) + 1): t = c*c + d*d if t not in dic: dic[t] = (c, d)for a in range(int(n ** 0.5) + 1): for b in range(int((n - a*a) ** 0.5) + 1): t = n - a*a - b*b if t in dic: print(a, b, dic[t][0], dic[t][1]) exit() åˆ†å·§å…‹åŠ›1227. åˆ†å·§å…‹åŠ› 1234567891011121314151617n, k = map(int, input().split())chocolates = [list(map(int, input().split())) for _ in range(n)]def check(x): t = 0 for chocolate in chocolates: t += (chocolate[0] // x) * (chocolate[1] // x) if t &gt;= k: return True return Falsel, r = 1, 100000while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if check(mid): l = mid else: r = mid - 1print(l) å‰ç¼€å’Œ795. å‰ç¼€å’Œ 12345678n, m = map(int, input().split())nums = list(map(int, input().split()))sums = [0] + nums[:]for i in range(1, n+1): sums[i] += sums[i-1]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l-1]) å­çŸ©é˜µçš„å’Œ796. å­çŸ©é˜µçš„å’Œ 1234567891011from sys import stdininput = lambda: stdin.readline().strip()n, m, q = map(int, input().split())nums = [[0] * (m+1)] + [[0] + list(map(int, input().split())) for _ in range(n)]sums = [num[:] for num in nums]for i in range(1, n+1): for j in range(1, m+1): sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1-1][y2] - sums[x2][y1-1] + sums[x1-1][y1-1]) æ¿€å…‰ç‚¸å¼¹99. æ¿€å…‰ç‚¸å¼¹ - AcWingé¢˜ 12345678910111213141516171819cnt, r = map(int, input().split())values = [[0] * 5002 for _ in range(5002)]r = min(r, 5001)n = m = rfor _ in range(cnt): x, y, w = map(int, input().split()) x += 1 y += 1 n, m = max(n, x), max(m, y) values[x][y] += wfor i in range(1, n+1): for j in range(1, m+1): values[i][j] += values[i-1][j] + values[i][j-1] - values[i-1][j-1]res = 0for i in range(r, n+1): for j in range(r, m+1): t = values[i][j] - values[i-r][j] - values[i][j-r] + values[i-r][j-r] res = max(res, t)print(res) Kå€åŒºé—´1230. Kå€åŒºé—´ 12345678910n, k = map(int, input().split())sums = [0] + [int(input()) for _ in range(n)]for i in range(1, n+1): sums[i] += sums[i-1]cnt = [0] * (n+1)res = 0for i in range(n+1): res += cnt[sums[i] % k] cnt[sums[i] % k] += 1print(res) æ•°å­¦ä¸ç®€å•DPä¹°ä¸åˆ°çš„æ•°ç›®AcWing 1205. ä¹°ä¸åˆ°çš„æ•°ç›® æš´åŠ› 1234567891011121314n, m = map(int, input().split())def check(i, n, m): if not i: return True if i &gt;= n and check(i-n, n, m): return True if i &gt;= m and check(i-m, n, m): return True return Falseres = 0for i in range(1, 1000): if not check(i, n, m): res = iprint(res) ä¼˜åŒ– 12345678910111213n, m = map(int, input().split())dp = [False] * (1000001)dp[0] = Truefor i in range(1, 1000001): if i &gt;= m: dp[i] |= dp[i-m] if i &gt;= n: dp[i] |= dp[i-n]res = 0for i in range(1, 1000001): if not dp[i]: res = iprint(res) å…¬å¼ 12n, m = map(int, input().split())print((n-1) * (m-1) - 1) èš‚èšæ„Ÿå†’1211. èš‚èšæ„Ÿå†’ 123456789101112n = int(input())nums = list(map(int, input().split()))left = right = 0for i in range(1, n): if abs(nums[0]) &gt; abs(nums[i]) and nums[i] &gt; 0: left += 1 elif abs(nums[0]) &lt; abs(nums[i]) and nums[i] &lt; 0: right += 1if nums[0] &gt; 0 and not right or nums[0] &lt; 0 and not left: print(1)else: print(1 + left + right) é¥®æ–™æ¢è´­1216. é¥®æ–™æ¢è´­ 123456n = int(input())res = nwhile n &gt; 2: res += n // 3 n = n // 3 + n % 3print(res) èƒŒåŒ…é—®é¢˜2. 01èƒŒåŒ…é—®é¢˜ 123456789n, v = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0] * (v+1) for _ in range(n+1)]for i in range(1, n+1): for j in range(1, v+1): dp[i][j] = dp[i-1][j] if j &gt;= nums[i-1][0]: dp[i][j] = max(dp[i][j], dp[i-1][j-nums[i-1][0]] + nums[i-1][1])print(dp[n][v]) æ‘˜èŠ±ç”Ÿ1015. æ‘˜èŠ±ç”Ÿ 123456789t = int(input())for _ in range(t): r, c = map(int, input().split()) g = [list(map(int, input().split())) for _ in range(r)] dp = [[0] * (c+1) for _ in range(r+1)] for i in range(1, r+1): for j in range(1, c+1): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + g[i-1][j-1] print(dp[i][j]) æœ€é•¿ä¸Šå‡å­åºåˆ—895. æœ€é•¿ä¸Šå‡å­åºåˆ— 12345678n = int(input())nums = [0] + list(map(int, input().split()))dp = [1] * (n+1)for i in range(1, n+1): for j in range(1, i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1)print(max(dp)) åœ°å®«å–å®1212. åœ°å®«å–å® 1234567891011121314151617n, m, k = map(int, input().split())MOD = 1000000007g = [[0] * (m+1)] + [[0] + list(map(lambda x: int(x) + 1, input().split())) for _ in range(n)]dp = [[[[0] * 14 for _ in range(k+1)] for _ in range(m+1)] for _ in range(n+1)]dp[1][1][1][g[1][1]] = 1dp[1][1][0][0] = 1for i in range(1, n+1): for j in range(1, m+1): if i == 1 and j == 1: continue for u in range(k+1): for v in range(14): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u][v] + dp[i][j-1][u][v]) % MOD if u &gt; 0 and v == g[i][j]: for t in range(v): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u-1][t] + dp[i][j-1][u-1][t])print(sum(dp[i][j][k]) % MOD) æ³¢åŠ¨æ•°åˆ—1214. æ³¢åŠ¨æ•°åˆ— 12345678n, s, a, b = map(int, input().split())dp = [[0] * n for _ in range(n)]dp[0][0] = 1MOD = 100000007for i in range(1, n): for j in range(n): dp[i][j] = (dp[i-1][(j-i*a) % n] + dp[i-1][(j+i*b) % n]) % MODprint(dp[n-1][s%n]) æšä¸¾ã€æ¨¡æ‹Ÿä¸æ’åºè¿å·åŒºé—´æ•°1210. è¿å·åŒºé—´æ•° 1234567891011n = int(input())nums = list(map(int, input().split()))res = 0for i in range(n): minv, maxv = float(&#x27;inf&#x27;), float(&#x27;-inf&#x27;) for j in range(i, n): minv = min(minv, nums[j]) maxv = max(maxv, nums[j]) if maxv - minv == j - i: res += 1print(res) é€’å¢ä¸‰å…ƒç»„1236. é€’å¢ä¸‰å…ƒç»„ å‰ç¼€å’Œ 1234567891011121314151617n = int(input())a = list(map(lambda x: int(x) + 1, input().split()))b = list(map(lambda x: int(x) + 1, input().split()))c = list(map(lambda x: int(x) + 1, input().split()))cnta, cntc, suma, sumc = [0] * 100002, [0] * 100002, [0] * 100002, [0] * 100002for i in range(n): cnta[a[i]] += 1for i in range(1, 100002): suma[i] = suma[i-1] + cnta[i]for i in range(n): cntc[c[i]] += 1for i in range(1, 100002): sumc[i] = sumc[i-1] + cntc[i]res = 0for i in b: res += suma[i-1] * (n - sumc[i])print(res) äºŒåˆ† 12345678910111213import bisectn = int(input())a = list(map(int, input().split()))b = list(map(int, input().split()))c = list(map(int, input().split()))a.sort()c.sort()res = 0for i in b: l = bisect.bisect_left(a, i) r = bisect.bisect_right(c, i) res += l * (n-r)print(res) ç‰¹åˆ«æ•°çš„å’Œ1245. ç‰¹åˆ«æ•°çš„å’Œ 123456n = int(input())res = 0for i in range(1, n+1): if &#x27;0&#x27; in str(i) or &#x27;1&#x27; in str(i) or &#x27;2&#x27; in str(i) or &#x27;9&#x27; in str(i): res += iprint(res) é”™è¯¯ç¥¨æ®1204. é”™è¯¯ç¥¨æ® 123456789101112n = int(input())nums = []for _ in range(n): nums.extend(map(int, input().split()))nums.sort()a = b = 0for i in range(1, len(nums)): if nums[i] == nums[i-1] + 2: a = nums[i] - 1 elif nums[i] == nums[i-1]: b = nums[i]print(a, b) å›æ–‡æ—¥æœŸ466. å›æ–‡æ—¥æœŸ 123456789101112date1, date2 = input(), input()days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]rev = [&#x27;92200229&#x27;]for i in range(1, 13): for j in range(1, days[i] + 1): t = f&#x27;&#123;i:02d&#125;&#123;j:02d&#125;&#x27; rev.append(t[::-1] + t)res = 0for i in rev: if date1 &lt;= i &lt;= date2: res += 1print(res) ç§»åŠ¨è·ç¦»1219. ç§»åŠ¨è·ç¦» 1234567w, m, n = map(int, input().split())m, n = m - 1, n - 1x1, x2 = m // w, n // wy1, y2 = m % w, n % wif x1 % 2: y1 = w - 1 - y1if x2 % 2: y2 = w - 1 - y2print(abs(x1 - x2) + abs(y1 - y2)) æ—¥æœŸé—®é¢˜1229. æ—¥æœŸé—®é¢˜ 1234567891011121314151617from time import strptimel, r, s = &#x27;1960-01-01&#x27;, &#x27;2059-12-31&#x27;, input().split(&#x27;/&#x27;)res = []def check(date): if l &lt;= date &lt;= r: try: strptime(date, &#x27;%Y-%m-%d&#x27;) res.append(date) except: passfor i in [&#x27;19&#x27;, &#x27;20&#x27;]: check(i + s[0] + &#x27;-&#x27; + s[1] + &#x27;-&#x27; + s[2]) check(i + s[2] + &#x27;-&#x27; + s[1] + &#x27;-&#x27; + s[0]) check(i + s[2] + &#x27;-&#x27; + s[0] + &#x27;-&#x27; + s[1])res.sort()for i in set(res): print(i) èˆªç­æ—¶é—´1231. èˆªç­æ—¶é—´ 12345678910111213t = int(input())for _ in range(t): res = 0 for _ in range(2): a = input().split() for i in range(len(a)): if i == 2: res += int(a[2][2]) * 24 * 3600 else: b = list(map(int, a[i].split(&#x27;:&#x27;))) res += (-1) ** (i+1) * (b[0] * 3600 + b[1] * 60 + b[2]) res //= 2 print(f&#x27;&#123;res // 3600:02d&#125;:&#123;res % 3600 // 60:02d&#125;:&#123;res % 60:02d&#125;&#x27;) å¤–å–åº—ä¼˜å…ˆçº§1241. å¤–å–åº—ä¼˜å…ˆçº§ 12345678910111213141516n, m, t = map(int, input().split())a, st, last = [0] * (n+1), [0] * (n+1), [0] * (n+1)b = [list(map(int, input().split())) for _ in range(m)]b.sort()for i, j in b: a[j] = max(0, a[j] - max(0, i - last[j] - 1)) if a[j] &lt;= 3: st[j] = 0 a[j], last[j] = a[j] + 2, i if a[j] &gt; 5: st[j] = 1for i in range(1, n+1): a[i] = max(0, a[i] - t + last[i]) if a[i] &lt;= 3: st[i] = 0print(sum(st)) å½’å¹¶æ’åº787. å½’å¹¶æ’åº 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l &gt;= r: return mid = l + r &gt;&gt; 1 merge_sort(l, mid) merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt; nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmpmerge_sort(0, n - 1)print(*nums) é€†åºå¯¹çš„æ•°é‡788. é€†åºå¯¹çš„æ•°é‡ 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l &gt;= r: return 0 mid = l + r &gt;&gt; 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt;= nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) æ ‘çŠ¶æ•°ç»„ä¸çº¿æ®µæ ‘åŠ¨æ€æ±‚è¿ç»­åŒºé—´å’Œæ ‘çŠ¶æ•°ç»„ 1264. åŠ¨æ€æ±‚è¿ç»­åŒºé—´å’Œ 1234567891011121314151617181920212223n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [0] * (n+1)def lowbit(x): return x &amp; -xdef add(x, v): while x &lt;= n: tree[x] += v x += lowbit(x)def query(x): res = 0 while x &gt; 0: res += tree[x] x -= lowbit(x) return resfor i in range(1, n+1): add(i, nums[i])for _ in range(m): k, a, b = map(int, input().split()) if k: add(a, b) else: print(query(b) - query(a-1)) çº¿æ®µæ ‘ 1234567891011121314151617181920212223242526272829303132333435363738394041n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): tree[u][2] = tree[u &lt;&lt; 1][2] + tree[u &lt;&lt; 1 | 1][2]def build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r &gt;&gt; 1 build(u &lt;&lt; 1, l, mid) build(u &lt;&lt; 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] &gt;= l and tree[u][1] &lt;= r: return tree[u][2] mid = tree[u][0] + tree[u][1] &gt;&gt; 1 res = 0 if l &lt;= mid: res += query(u &lt;&lt; 1, l, r) if r &gt; mid: res += query(u &lt;&lt; 1 | 1, l, r) return resdef modify(u, x, v): if tree[u][0] == tree[u][1]: tree[u][2] += v else: mid = tree[u][0] + tree[u][1] &gt;&gt; 1 if x &lt;= mid: modify(u &lt;&lt; 1, x, v) else: modify(u &lt;&lt; 1 | 1, x, v) pushup(u)build(1, 1, n)for _ in range(m): k, a, b = map(int, input().split()) if k: modify(1, a, b) else: print(query(1, a, b)) æ•°æ˜Ÿæ˜Ÿ1265. æ•°æ˜Ÿæ˜Ÿ 123456789101112131415161718192021n = int(input())tree = [0] * 32002res = [0] * ndef lowbit(x): return x &amp; -xdef add(x): while x &lt;= 32001: tree[x] += 1 x += lowbit(x)def query(x): res = 0 while x &gt; 0: res += tree[x] x -= lowbit(x) return resfor _ in range(n): x, y = map(int, input().split()) res[query(x+1)] += 1 add(x+1)for i in res: print(i) æ•°åˆ—åŒºé—´æœ€å¤§å€¼1270. æ•°åˆ—åŒºé—´æœ€å¤§å€¼ dp(çˆ†ç©ºé—´) 123456789n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))dp = [[0] * (n+1) for _ in range(n+1)]for i in range(1, n + 1): for j in range(i, n + 1): dp[i][j] = max(dp[i][j - 1], nums[j])for _ in range(m): x, y = map(int, input().split()) print(dp[x][y]) çº¿æ®µæ ‘(TLE) 1234567891011121314151617181920212223242526272829n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): t = max(tree[u &lt;&lt; 1][2], tree[u &lt;&lt; 1 | 1][2]) tree[u][2] = tdef build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r &gt;&gt; 1 build(u &lt;&lt; 1, l, mid) build(u &lt;&lt; 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] &gt;= l and tree[u][1] &lt;= r: return tree[u][2] mid = tree[u][0] + tree[u][1] &gt;&gt; 1 left = right = 0 if l &lt;= mid: left = query(u &lt;&lt; 1, l, r, ) if r &gt; mid: right = query(u &lt;&lt; 1 | 1, l, r) return max(left, right)build(1, 1, n)for _ in range(m): x, y = map(int, input().split()) print(query(1, x, y)) å°æœ‹å‹æ’é˜Ÿ1215. å°æœ‹å‹æ’é˜Ÿ 12345678910111213141516171819202122232425262728N = 1000001n = int(input())nums = [0] + list(map(lambda x: int(x) + 1, input().split()))ct = [0] * (n + 1)def lowbit(x): return x &amp; -xdef add(x, v): while x &lt;= N: tree[x] += v x += lowbit(x)def query(x): res = 0 while x &gt; 0: res += tree[x] x -= lowbit(x) return restree = [0] * (N + 1)for i in range(1, n + 1): ct[i] = query(N) - query(nums[i]) add(nums[i], 1)tree = [0] * (N + 1)for i in range(n, 0, -1): ct[i] += query(nums[i] - 1) add(nums[i], 1)res = 0for i in ct[1:]: res += i * (i + 1) &gt;&gt; 1print(res) æ²¹æ¼†é¢ç§¯1228. æ²¹æ¼†é¢ç§¯ 12çº¿æ®µæ ‘å¤ªéš¾ï¼Œè·³è¿‡ï¼ ä¸‰ä½“æ”»å‡»1232. ä¸‰ä½“æ”»å‡» äºŒåˆ† + ä¸‰ç»´å·®åˆ† (éš¾) 12345678910111213141516171819202122232425262728293031323334353637383940414243from sys import stdininput = lambda: stdin.readline().strip()def get(i, j, k): return (i * B + j) * C + kdef check(mid): b = [0]*N for i in range(1, mid + 1): x1, x2, y1, y2, z1, z2, c = op[i] b[get(x1, y1, z1)] -= c b[get(x1, y1, z2 + 1)] += c b[get(x1, y2 + 1, z1)] += c b[get(x1, y2 + 1, z2 + 1)] -= c b[get(x2 + 1, y1, z1)] += c b[get(x2 + 1, y1, z2 + 1)] -= c b[get(x2 + 1, y2 + 1, z1)] -= c b[get(x2 + 1, y2 + 1, z2 + 1)] += c # å¯¹bæ±‚ä¸€ä¸‹ä¸‰ç»´å‰ç¼€å’Œ arr = s[:] for i in range(1, A + 1): for j in range(1, B + 1): for k in range(1, C + 1): b[get(i, j, k)] += b[get(i - 1, j, k)] + b[get(i,j-1,k)] + b[get(i,j,k-1)] + b[get(i-1,j-1,k-1)] - \\ b[get(i - 1, j - 1, k)] - b[get(i - 1, j, k - 1)] - b[get(i, j - 1, k - 1)] arr[get(i, j, k)] += b[get(i,j,k)] if arr[get(i, j, k)] &lt; 0: return True return FalseA, B, C, m = map(int, input().split())N = (A+1)*(B+1)*(C+1)s, b, bp = [0]*N, [0]*N, [0]*Narr = list(map(int, input().split()))t = 0for i in range(1, A+1): for j in range(1, B+1): for k in range(1, C+1): s[get(i,j,k)] = arr[t] # æŠŠåœ°çƒå†›é˜Ÿçš„ç”Ÿå‘½å€¼ç»™èµ‹å€¼ t += 1op = [[]] + [list(map(int, input().split())) for _ in range(m)]l, r = 1, mwhile l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) å·®åˆ†797. å·®åˆ† 1234567891011121314n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diff = [0] * (n + 2)def insert(l, r, c): diff[l] += c diff[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diff[i]print(*nums[1:]) å·®åˆ†çŸ©é˜µ798. å·®åˆ†çŸ©é˜µ 1234567891011121314151617n, m, q = map(int, input().split())nums = [[0] * (m + 1)] + [[0] + list(map(int, input().split())) for _ in range(n)]diff = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += c diff[x1][y2 + 1] -= c diff[x2 + 1][y1] -= c diff[x2 + 1][y2 + 1] += cfor _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): insert(i, j, i, j, nums[i][j]) nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diff[i][j] print(nums[i][j], end=&#x27; &#x27;) print() èºæ—‹æŠ˜çº¿1237. èºæ—‹æŠ˜çº¿ 123456789x, y = map(int, input().split())if abs(x) &lt;= y: print(2 * y * (2 * y - 1) + x + y)elif abs(y) &lt;= x: print(2 * x * 2 * x + x - y)elif abs(x) &lt;= -y + 1: print(2 * -y * (2 * -y + 1) - x - y)else: print((2 * -x - 1) * (2 * -x - 1) - x + y - 1) åŒæŒ‡é’ˆã€BFSä¸å›¾è®ºæ—¥å¿—ç»Ÿè®¡1238. æ—¥å¿—ç»Ÿè®¡ 12345678910111213141516n, d, k = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort()cnt, st = [0] * 100001, [False] * 100001j = 0for i in range(n): idx = nums[i][1] cnt[idx] += 1 while nums[i][0] - nums[j][0] &gt;= d: cnt[nums[j][1]] -= 1 j += 1 if cnt[idx] &gt;= k: st[idx] = Truefor i in range(100001): if st[i]: print(i) çŒ®ç»™é˜¿å°”å‰ä¾¬çš„èŠ±æŸ1101. çŒ®ç»™é˜¿å°”å‰ä¾¬çš„èŠ±æŸ 1234567891011121314151617181920212223242526272829from collections import dequet = int(input())dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(start, end, g): q = deque() q.append(start) dist = [[-1] * c for _ in range(r)] dist[start[0]][start[1]] = 0 while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; r and 0 &lt;= y &lt; c and g[x][y] != &#x27;#&#x27; and dist[x][y] == -1: dist[x][y] = dist[a][b] + 1 if x == end[0] and y == end[1]: print(dist[x][y]) return q.append((x, y)) print(&#x27;oop!&#x27;)for _ in range(t): r, c = map(int, input().split()) g = [input() for _ in range(r)] for i in range(r): for j in range(c): if g[i][j] == &#x27;S&#x27;: start = (i, j) elif g[i][j] == &#x27;E&#x27;: end = (i, j) bfs(start, end, g) çº¢ä¸é»‘1113. çº¢ä¸é»‘ dfs 123456789101112131415161718192021dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dfs(a, b): cnt = 1 st[a][b] = True for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and g[x][y] == &#x27;.&#x27; and not st[x][y]: st[x][y] = True cnt += dfs(x, y) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == &#x27;@&#x27;: print(dfs(i, j)) break bfs 123456789101112131415161718192021222324252627from collections import dequedirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) cnt = 1 st[a][b] = True while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and g[x][y] == &#x27;.&#x27; and not st[x][y]: st[x][y] = True cnt += 1 q.append((x, y)) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == &#x27;@&#x27;: print(bfs(i, j)) break äº¤æ¢ç“¶å­1224. äº¤æ¢ç“¶å­ è´ªå¿ƒ 12345678910111213n = int(input())nums = [0] + list(map(int, input().split()))st = [False] * (n + 1)cnt = 0for i in range(1, n + 1): t = nums[i] if not st[t]: st[t] = True cnt += 1 while not st[nums[t]]: st[nums[t]] = True t = nums[t]print(n - cnt) å¹¶æŸ¥é›† 12345678910111213141516171819n = int(input())nums = [0] + list(map(int, input().split()))fa = [i for i in range(n + 1)]s = [0] * (n + 1)def find(x): if fa[x] == x: return x fa[x] = find(fa[x]) return fa[x]for i in range(1, n + 1): fx, fy = find(nums[i]), find(nums[nums[i]]) fa[fx] = fyfor i in range(1, n + 1): s[find(i)] += 1res = 0for i in range(1, n + 1): if s[i]: res += s[i] - 1print(res) å®Œå…¨äºŒå‰æ ‘çš„æƒå€¼1240. å®Œå…¨äºŒå‰æ ‘çš„æƒå€¼ å‰ç¼€å’Œ 1234567891011121314n = int(input())nums = [0] + list(map(int, input().split()))for i in range(1, n + 1): nums[i] += nums[i - 1]res, depth = float(&#x27;-inf&#x27;), 1i = j = 1while i &lt;= n: t = nums[min(n, i * 2 - 1)] - nums[i - 1] if t &gt; res: res = t depth = j i *= 2 j += 1print(depth) åœ°ç‰¢å¤§å¸ˆ1096. åœ°ç‰¢å¤§å¸ˆ 12345678910111213141516171819202122232425262728293031323334from collections import dequedirs = [(1, 0 ,0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]def bfs(start, end): q = deque() q.append(start) dist = [[[-1] * c for _ in range(r)] for _ in range(l)] dist[start[0]][start[1]][start[2]] = 0 while q: a, b, d = q.popleft() for i in range(6): x, y, z = a + dirs[i][0], b + dirs[i][1], d + dirs[i][2] if 0 &lt;= x &lt; l and 0 &lt;= y &lt; r and 0 &lt;= z &lt; c and g[x][y][z] != &#x27;#&#x27; and dist[x][y][z] == -1: dist[x][y][z] = dist[a][b][d] + 1 if x == end[0] and y == end[1] and z == end[2]: print(f&#x27;Escaped in &#123;dist[x][y][z]&#125; minute(s).&#x27;) return q.append((x, y, z)) print(&#x27;Trapped!&#x27;)while True: l, r, c = map(int, input().split()) if not l: break g = [0] * l for i in range(l): g[i] = [input() for _ in range(r)] input() for i in range(l): for j in range(r): for k in range(c): if g[i][j][k] == &#x27;S&#x27;: start = (i, j, k) elif g[i][j][k] == &#x27;E&#x27;: end = (i, j, k) bfs(start, end) å…¨çƒå˜æš–1233. å…¨çƒå˜æš– 123456789101112131415161718192021222324252627282930313233from collections import dequen = int(input())g = [input() for _ in range(n)]st = [[False] * n for _ in range(n)]dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) total = bound = 0 st[a][b] = True while q: a, b = q.popleft() total += 1 is_bound = False for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; n: if g[x][y] == &#x27;.&#x27;: is_bound = True elif g[x][y] == &#x27;#&#x27; and not st[x][y]: st[x][y] = True q.append((x, y)) if is_bound: bound += 1 if total == bound: global res res += 1res = 0for i in range(n): for j in range(n): if g[i][j] == &#x27;#&#x27; and not st[i][j]: bfs(i, j)print(res) å¤§è‡£çš„æ—…è´¹1207. å¤§è‡£çš„æ—…è´¹ dfs(çˆ†æ ˆ) 12345678910111213141516171819import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]dist = [0] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def dfs(u, father, distance): dist[u] = distance for i, j in g[u]: if i != father: dfs(i, u, distance + j)dfs(1, -1, 0)t = dist.index(max(dist))dfs(t, -1, 0)t = max(dist)print(10 * t + t * (t + 1) // 2) bfs 1234567891011121314151617181920212223from collections import dequen = int(input())g = [[] for _ in range(n + 1)]dist = [-1] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def bfs(u): q = deque([u]) dist[u] = 0 while q: u = q.popleft() for i, j in g[u]: if dist[i] == -1: dist[i] = dist[u] + j q.append(i)bfs(1)t = dist.index(max(dist))dist = [-1] * (n + 1)bfs(t)t = max(dist)print(t * 10 + t * (t + 1) // 2) è´ªå¿ƒè‚¡ç¥¨ä¹°å– II1055. è‚¡ç¥¨ä¹°å– II 123456n = int(input())nums = list(map(int, input().split()))res = 0for i in range(1, n): res += max(0, nums[i] - nums[i - 1])print(res) è´§ä»“é€‰å€104. è´§ä»“é€‰å€ 12345678n = int(input())nums = list(map(int, input().split()))nums.sort()a = nums[n // 2]res = 0for num in nums: res += abs(a - num)print(res) ç³–æœä¼ é€’122. ç³–æœä¼ é€’ 12345678910111213n = int(input())nums = [0] + [int(input()) for _ in range(n)]sums = [0] * (n + 2)avg = sum(nums) // nfor i in range(n, 1, -1): sums[i] = sums[i + 1] - nums[i] + avgsums = sums[1: n + 1]sums.sort()res = 0a = sums[n // 2]for i in sums: res += abs(i - a)print(res) 123456789101112n = int(input())nums = [int(input()) for _ in range(n)]avg = sum(nums) // na = [0] + [i - avg for i in nums]for i in range(1, n + 1): a[i] += a[i - 1]a = sorted(a[1:])t = a[n // 2]res = 0for i in a: res += abs(t - i)print(res) é›·è¾¾è®¾å¤‡112. é›·è¾¾è®¾å¤‡ 123456789101112131415161718n, d = map(int, input().split())g = []for _ in range(n): x, y = map(int, input().split()) if y &gt; d: print(-1) exit(0) else: x1 = x - (d * d - y * y) ** 0.5 x2 = x + (d * d - y * y) ** 0.5 g.append((x1, x2))g.sort(key=lambda x: x[1])res, last = 0, float(&#x27;-inf&#x27;)for i in range(n): if g[i][0] &gt; last: res += 1 last = g[i][1]print(res) ä»˜è´¦é—®é¢˜1235. ä»˜è´¦é—®é¢˜ 1234567891011121314n, s = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, avg = 0, s / nfor i, num in enumerate(nums): cur = s / (n - i) if num &lt; cur: res += (avg - num) ** 2 s -= num else: res += (cur - avg) ** 2 * (n - i) breakres = (res / n) ** 0.5print(f&#x27;&#123;res:.4f&#125;&#x27;) ä¹˜ç§¯æœ€å¤§1239. ä¹˜ç§¯æœ€å¤§ 12345678910111213141516171819202122n, k = map(int, input().split())nums = [int(input()) for _ in range(n)]MOD = 1000000009nums.sort()res = sign = 1l, r = 0, n - 1if k % 2: res = nums[r] r, k = r - 1, k - 1 if res &lt; 0: sign = -1while k: x, y = nums[l] * nums[l + 1], nums[r] * nums[r - 1] if x * sign &gt; y * sign: res *= x l += 2 else: res *= y r -= 2 res = res % MOD if res &gt; 0 else -(-res % MOD) k -= 2print(res) åç¼€è¡¨è¾¾å¼1247. åç¼€è¡¨è¾¾å¼ 12345678910n, m = map(int, input().split())nums = list(map(int, input().split()))if not m: print(sum(nums))else: nums.sort() res = nums[-1] - nums[0] for num in nums[1: -1]: res += abs(num) print(res) çµèƒ½ä¼ è¾“1248. çµèƒ½ä¼ è¾“ 123456789101112131415161718192021222324252627282930t = int(input())for _ in range(t): n = int(input()) nums = [0] + list(map(int, input().split())) for i in range(1, n + 1): nums[i] += nums[i - 1] s0, sn = nums[0], nums[-1] if s0 &gt; sn: s0, sn = sn, s0 nums.sort() s0, sn = nums.index(s0), nums.index(sn) l, r = 0, n res = [0] * (n + 1) st = [0] * (n + 1) for i in range(s0, -1, -2): res[l] = nums[i] st[i] = True l += 1 for i in range(sn, n + 1, 2): res[r] = nums[i] st[i] = True r -= 1 for i in range(n + 1): if not st[i]: res[l] = nums[i] l += 1 ans = 0 for i in range(1, n + 1): ans = max(ans, abs(res[i] - res[i - 1])) print(ans) æ•°è®ºç­‰å·®æ•°åˆ—1246. ç­‰å·®æ•°åˆ— 123456789101112n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else ad = 0for i in range(1, n): d = gcd(nums[i] - nums[0], d)if d: print((nums[-1] - nums[0]) // d + 1)else: print(n) Xçš„å› å­é“¾1295. Xçš„å› å­é“¾ 12345678910111213141516171819202122232425262728293031323334353637N = (1 &lt;&lt; 20) + 10primes, st, minp = [], [False] * N, [0] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) minp[i] = i j = 0 while i * primes[j] &lt;= n and j &lt; len(primes): st[primes[j] * i] = True minp[primes[j] * i] = primes[j] if i % primes[j] == 0: break j += 1get_prime(N - 1)fact, sums = [0] * 30, [0] * Nwhile True: try: x = int(input()) k = total = 0 while x &gt; 1: p = minp[x] fact[k], sums[k] = p, 0 while x % p == 0: x //= p sums[k] += 1 total += 1 k += 1 res = 1 for i in range(1, total + 1): res *= i for i in range(k): for j in range(1, sums[i] + 1): res //= j print(total, res) except: break èªæ˜çš„ç‡•å§¿1296. èªæ˜çš„ç‡•å§¿ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849N = 50000primes, st = [], [False] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) j = 0 while i * primes[j] &lt;= n: st[i * primes[j]] = True if i % primes[j] == 0: break j += 1def is_prime(x): if x &lt; N: return not st[x] i = 0 while primes[i] &lt;= x / primes[i]: if x % primes[i] == 0: return False i += 1 return Truedef dfs(last, prod, s): if s == 1: res.append(prod) return if s - 1 &gt; (0 if last &lt; 0 else primes[last]) and is_prime(s - 1): res.append(prod * (s - 1)) i = last + 1 while primes[i] &lt;= s / primes[i]: p = primes[i] j, t = 1 + p, p while t &lt;= s: if s % j == 0: dfs(i, prod * t, s // j) t *= p j += t i += 1get_prime(N - 1)while True: try: x = int(input()) res = [] dfs(-1, 1, x) print(len(res)) if res: res.sort() print(*res) except: break äº”æŒ‡å±±1299. äº”æŒ‡å±± 123456789101112131415t = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(t): n, d, x, y = map(int, input().split()) gcd, a, b = exgcd(n, d) if (y - x) % gcd: print(&quot;Impossible&quot;) else: b *= (y - x) // gcd print(b % (n // gcd)) æœ€å¤§æ¯”ä¾‹1223. æœ€å¤§æ¯”ä¾‹ 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else adef gcd_sub(a, b): if a &lt; b: a, b = b, a if b == 1: return a return gcd_sub(b, a // b)a, b = [], []for i in range(1, n): if nums[i] != nums[i - 1]: d = gcd(nums[i], nums[0]) a.append(nums[i] // d) b.append(nums[0] // d)up, down = a[0], b[0]for i in range(1, len(a)): up = gcd_sub(up, a[i]) down = gcd_sub(down, b[i])print(f&#x27;&#123;up&#125;/&#123;down&#125;&#x27;) C å¾ªç¯1301. C å¾ªç¯ 1234567891011121314151617def exgcd(a, b): if b == 0: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ywhile True: a, b, c, k = map(int, input().split()) if a == 0 and b == 0 and c == 0 and k == 0: break k = 1 &lt;&lt; k gcd, x, y = exgcd(c, k) if (b - a) % gcd: print(&quot;FOREVER&quot;) else: x *= (b - a) // gcd print(x % (k // gcd)) æ­£åˆ™é—®é¢˜1225. æ­£åˆ™é—®é¢˜ 1234567891011121314151617181920s = input().strip()i = 0def dfs(): global i res = 0 while i &lt; len(s): if s[i] == &#x27;(&#x27;: i += 1 res += dfs() i += 1 elif s[i] == &#x27;|&#x27;: i += 1 res = max(res, dfs()) elif s[i] == &#x27;)&#x27;: break else: i += 1 res += 1 return resprint(dfs()) ç³–æœ1243. ç³–æœ IDA* 12345678910111213141516171819202122232425262728293031323334353637383940414243def lowbit(x): return x &amp; -xdef h(st): t = (1 &lt;&lt; m) - 1 - st res = 0 while t: res += 1 i = lowbit(t) t -= i for row in col[log2[i]]: t &amp;= ~row return resdef dfs(depth, st): if depth == 0 or h(st) &gt; depth: return st == (1 &lt;&lt; m) - 1 t = -1 i = (1 &lt;&lt; m) - 1 - st while i: j = lowbit(i) i -= j if t == -1 or len(col[log2[j]]) &lt; len(col[t]): t = log2[j] for row in col[t]: if dfs(depth - 1, row | st): return True return Falsen, m, k = map(int, input().split())log2 = [0] * (1 &lt;&lt; m + 1)for i in range(m): log2[1 &lt;&lt; i] = icol = [[] for _ in range(m + 1)]for _ in range(n): t = list(map(int, input().split())) tt = 0 for ti in t: tt |= 1 &lt;&lt; (ti - 1) for i in range(m): if (tt &gt;&gt; i) &amp; 1: col[i].append(tt)depth = 0while depth &lt;= m and not dfs(depth, 0): depth += 1print(-1 if depth &gt; m else depth) dp 1234567891011121314151617n, m, k = map(int, input().split())dp = [-1] * ((1 &lt;&lt; m) + 1)val = [0] * nfor i in range(n): t = list(map(int, input().split())) for j in t: val[i] |= 1 &lt;&lt; (j - 1) dp[val[i]] = 1for i in range(n): for j in range(1 &lt;&lt; m): if dp[j] == -1: continue if dp[j | val[i]] == -1: dp[j | val[i]] = dp[j] + dp[val[i]] else: dp[j | val[i]] = min(dp[j | val[i]], dp[j] + dp[val[i]])print(dp[(1 &lt;&lt; m) - 1]) å¤æ‚DPé¸£äººçš„å½±åˆ†èº«1050. é¸£äººçš„å½±åˆ†èº« 1234567891011t = int(input())for _ in range(t): m, n = map(int, input().split()) dp = [[0] * (n + 1) for _ in range(m + 1)] dp[0][0] = 1 for i in range(m + 1): for j in range(1, n + 1): dp[i][j] = dp[i][j - 1] if i &gt;= j: dp[i][j] += dp[i - j][j] print(dp[m][n]) ç³–æœ1047. ç³–æœ 12345678n, k = map(int, input().split())dp = [[float(&#x27;-inf&#x27;)] * (k + 1) for _ in range(n + 1)]dp[0][0] = 0for i in range(1, n + 1): x = int(input()) for j in range(k + 1): dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - x) % k] + x)print(dp[n][0]) å¯†ç è„±è½1222. å¯†ç è„±è½ 12345678910111213s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]for i in range(n): for l in range(n - i): r = l + i if i == 0: dp[l][r] = 1 else: if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] + 2 dp[l][r] = max(dp[l][r], dp[l + 1][r], dp[l][r - 1])print(n - dp[0][n - 1]) ç”Ÿå‘½ä¹‹æ ‘1220. ç”Ÿå‘½ä¹‹æ ‘ 123456789101112131415161718import syssys.setrecursionlimit(100000)n = int(input())w = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]dp = [float(&#x27;-inf&#x27;)] * (n + 1)for _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, fa): dp[u] = w[u] for v in adj_list[u]: if v != fa: dfs(v, u) dp[u] += max(0, dp[v])dfs(1, -1) print(max(dp)) åŒ…å­å‡‘æ•°1226. åŒ…å­å‡‘æ•° 12345678910111213141516171819202122n = int(input())dp = [[0] * 10000 for _ in range(n + 1)]w = [0] + [int(input()) for _ in range(n)]def gcd(a, b): return gcd(b, a % b) if b else ad = w[1]for i in range(2, n + 1): d = gcd(d, w[i])if d == 1: dp[0][0] = 1 for i in range(1, n + 1): for j in range(10000): dp[i][j] = dp[i - 1][j] if j &gt;= w[i]: dp[i][j] |= dp[i][j - w[i]] res = 0 for i in range(10000): if not dp[n][i]: res += 1 print(res)else: print(&quot;INF&quot;) æ‹¬å·é…å¯¹1070. æ‹¬å·é…å¯¹ 12345678910111213141516s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]def check(l, r): if s[l - 1] == &#x27;(&#x27; and s[r - 1] == &#x27;)&#x27;: return True if s[l - 1] == &#x27;[&#x27; and s[r - 1] == &#x27;]&#x27;: return True return Falsefor i in range(n, 0, -1): for j in range(i + 1, n + 1): if check(i, j): dp[i][j] = dp[i + 1][j - 1] + 2 for k in range(i, j): dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j])print(n - dp[1][n]) æ–æ³¢é‚£å¥‘å‰ n é¡¹å’Œ1303. æ–æ³¢é‚£å¥‘å‰ n é¡¹å’Œ 1234567891011121314151617181920212223n, m = map(int, input().split())f1 = [1, 1, 1]a = [[0, 1, 0], [1, 1, 1], [0, 0, 1]]def mul1(b, c): tmp = [0] * 3 for i in range(3): for j in range(3): tmp[i] = (tmp[i] + b[j] * c[j][i]) % m return tmpdef mul2(b, c): tmp = [[0] * 3 for _ in range(3)] for i in range(3): for j in range(3): for k in range(3): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % m return tmpn -= 1while n: if n &amp; 1: f1 = mul1(f1, a) a = mul2(a, a) n &gt;&gt;= 1print(f1[2]) å’éª°å­1217. å’éª°å­ 123456789101112131415161718192021222324252627282930313233n, m = map(int, input().split())MOD = int(1e9) + 7op = [3, 4, 5, 0, 1, 2]f1 = [4, 4, 4, 4, 4, 4]d = [[4] * 6 for _ in range(6)]st = [[False] * 6 for _ in range(6)]for _ in range(m): a, b = map(lambda x: int(x) - 1, input().split()) st[a][b] = st[b][a] = Truefor i in range(6): for j in range(6): if st[j][op[i]]: d[j][i] = 0def mul1(b, c): tmp = [0] * 6 for i in range(6): for j in range(6): tmp[i] = (tmp[i] + b[j] * c[j][i]) % MOD return tmpdef mul2(b, c): tmp = [[0] * 6 for _ in range(6)] for i in range(6): for j in range(6): for k in range(6): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % MOD return tmpn -= 1while n: if n &amp; 1: f1 = mul1(f1, d) d = mul2(d, d) n &gt;&gt;= 1print(sum(f1) % MOD) ç–‘éš¾æ‚é¢˜ä¿®æ”¹æ•°ç»„1242. ä¿®æ”¹æ•°ç»„ 123456789101112131415import syssys.setrecursionlimit(100000)n = int(input())nums = list(map(int, input().split()))p = [i for i in range(1100001)]res = []def find(x): if x != p[x]: p[x] = find(p[x]) return p[x]for num in nums: x = find(num) res.append(x) p[x] = x + 1print(*res) å€æ•°é—®é¢˜1234. å€æ•°é—®é¢˜ 1234567891011121314n, K = map(int, input().split())nums = list(map(int, input().split()))dp = [[float(&#x27;-inf&#x27;)] * K for _ in range(4)]dp[0][0] = 0a = [[] for _ in range(K)]for num in nums: a[num % K].append(num)for i in range(K): tmp = sorted(a[i], reverse = True) for i in range(min(3, len(tmp))): for j in range(3, 0, -1): for k in range(K): dp[j][k] = max(dp[j][k], dp[j - 1][(k - tmp[i]) % K] + tmp[i])print(dp[3][0]) ç»„åˆæ•°é—®é¢˜523. ç»„åˆæ•°é—®é¢˜ 12345678910111213141516171819202122t, k = map(int, input().split())c = [[0] * 2001 for _ in range(2001)]s = [[0] * 2001 for _ in range(2001)]for i in range(2001): for j in range(i + 1): if j == 0: c[i][j] = 1 else: c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % k if c[i][j] == 0: s[i][j] = 1for i in range(2001): for j in range(2001): if i: s[i][j] += s[i - 1][j] if j: s[i][j] += s[i][j - 1] if i and j: s[i][j] -= s[i - 1][j - 1]for _ in range(t): n, m = map(int, input().split()) print(s[n][m]) æ¨¡æ‹Ÿæ•£åˆ—è¡¨840. æ¨¡æ‹Ÿæ•£åˆ—è¡¨ 1234567891011n = int(input())dicts = &#123;&#125;for _ in range(n): op, x = input().split() if op == &#x27;I&#x27;: dicts[x] = dicts.get(x, 0) + 1 elif op == &#x27;Q&#x27;: if dicts.get(x): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)","tags":["ç®—æ³•","Python","è“æ¡¥æ¯"],"categories":["ç®—æ³•"]},{"title":"PAT ä¹™çº§","path":"/2024/01/29/patä¹™çº§/","content":"PAT ä¹™çº§1001 å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³123456789n = int(input())num = 0while n != 1: if n % 2 == 0: n = n // 2 else: n = (3 * n + 1) // 2 num += 1print(num) 1002 å†™å‡ºè¿™ä¸ªæ•°123456789n = input()res = 0for char in n: res += int(char)dicts = [&#x27;ling&#x27;, &#x27;yi&#x27;, &#x27;er&#x27;, &#x27;san&#x27;, &#x27;si&#x27;, &#x27;wu&#x27;, &#x27;liu&#x27;, &#x27;qi&#x27;, &#x27;ba&#x27;, &#x27;jiu&#x27;]ans = []for char in str(res): ans.append(dicts[int(char)])print(&#x27; &#x27;.join(map(str, ans))) 1003 æˆ‘è¦é€šè¿‡ï¼12345678910111213141516171819202122232425262728n = int(input())def check(arg): length = len(arg) idx = cnt1 = cnt2 = cnt3 = 0 while idx &lt; length and arg[idx] == &#x27;A&#x27;: cnt1 += 1 idx += 1 if idx &lt; length and arg[idx] == &#x27;P&#x27;: idx += 1 else: return False while idx &lt; length and arg[idx] == &#x27;A&#x27;: idx += 1 cnt2 += 1 if idx &lt; length and arg[idx] == &#x27;T&#x27;: idx += 1 else: return False while idx &lt; length and arg[idx] == &#x27;A&#x27;: idx += 1 cnt3 += 1 if idx == length and cnt1 * cnt2 == cnt3 and cnt2: return True else: return Falsefor _ in range(n): a = input() print(&#x27;YES&#x27; if check(a) else &#x27;NO&#x27;) 1004 æˆç»©æ’å12345678n = int(input())students = []for i in range(n): name, number, grade = input().split() students.append([name, number, grade])students.sort(key=lambda x: int(x[2]))print(students[-1][0], students[-1][1])print(students[0][0], students[0][1]) 1005 ç»§ç»­(3n+1)çŒœæƒ³12345678910111213141516n = int(input())nums = list(map(int, input().split()))res = nums[:]def check(num): while num != 1: if num % 2 == 0: num = num // 2 else: num = (3 * num + 1) // 2 if num in res: res.remove(num) returnfor num in nums: check(num)res.sort(reverse=True)print(&#x27; &#x27;.join(map(str, res))) 1006 æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•°123n = &#x27;00&#x27; + input()res = &#x27;B&#x27; * int(n[-3]) + &#x27;S&#x27; * int(n[-2]) + &#x27;&#x27;.join([str(i) for i in range(1, int(n[-1]) + 1)])print(res) 1007 ç´ æ•°å¯¹çŒœæƒ³12345678910111213n = int(input())state = [True] * (n + 1)primes = []for i in range(2, n + 1): if state[i]: primes.append(i) for j in range(i * 2, n + 1, i): state[j] = Falseres = 0for i in range(len(primes) - 1): if primes[i + 1] - primes[i] == 2: res += 1print(res) 1008 æ•°ç»„å…ƒç´ å¾ªç¯å³ç§»é—®é¢˜1234n, m = map(int, input().split())nums = list(map(int, input().split()))nums = nums[n - m: ] + nums[: n - m]print(&#x27; &#x27;.join(map(str, nums))) 1009 è¯´åè¯12s = list(input().split())print(&#x27; &#x27;.join(map(str, s[::-1]))) 1010 ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼12345678910nums = list(map(int, input().split()))res = []for i in range(0, len(nums), 2): a = nums[i] * nums[i + 1] b = nums[i + 1] - 1 if a: res.extend((a, b))if not res: res.extend((0, 0))print(&#x27; &#x27;.join(map(str, res))) 1011 A+B å’Œ C1234567t = int(input())for i in range(1, t + 1): a, b, c = map(int, input().split()) if a + b &gt; c: print(f&#x27;Case #&#123;i&#125;: true&#x27;) else: print(f&#x27;Case #&#123;i&#125;: false&#x27;) 1012 æ•°å­—åˆ†ç±»12345678910111213141516171819202122232425262728nums = list(map(int, input().split()))res1 = res2 = len2 = res3 = res4 = len4 = res5 = 0for num in nums[1: ]: if num % 10 == 0: res1 += num elif num % 5 == 1: res2 += (-1) ** (len2 % 2) * num len2 += 1 elif num % 5 == 2: res3 += 1 elif num % 5 == 3: res4 += num len4 += 1 elif num % 5 == 4: res5 = num if num &gt; res5 else res5if not res1: res1 = &#x27;N&#x27;if not len2: res2 = &#x27;N&#x27;if not res3: res3 = &#x27;N&#x27;if len4: res4 = round(res4 / len4, 1)else: res4 = &#x27;N&#x27;if not res5: res5 = &#x27;N&#x27;print(res1, res2, res3, res4, res5) 1013 æ•°ç´ æ•°1234567891011m, n = map(int, input().split())state = [True] * 600000for i in range(2, int(600000**0.5) + 1): if state[i]: for j in range(i * i, 600000, i): state[j] = Falseprimes = [num for num in range(2, 600000) if state[num]]tmps = primes[m - 1: n]ress = [tmps[i:i+10] for i in range(0, len(tmps), 10)]for res in ress: print(&#x27; &#x27;.join(map(str, res))) 1014 ç¦å°”æ‘©æ–¯çš„çº¦ä¼š1234567891011121314151617181920212223s1, s2, s3, s4 = input(), input(), input(), input()len1, len2 = min(len(s1), len(s2)), min(len(s3), len(s4))res = []DAY = &#123;&#x27;A&#x27;: &quot;MON&quot;, &#x27;B&#x27;: &quot;TUE&quot;, &#x27;C&#x27;: &quot;WED&quot;, &#x27;D&#x27;: &quot;THU&quot;, &#x27;E&#x27;: &quot;FRI&quot;, &#x27;F&#x27;: &quot;SAT&quot;, &#x27;G&#x27;: &quot;SUN&quot;&#125;for i in range(len1): if s1[i] == s2[i] and &#x27;A&#x27; &lt;= s1[i] &lt;= &#x27;G&#x27;: res.append(DAY[s1[i]]) breakfor j in range(i + 1, len1): if s1[j] == s2[j]: if &#x27;0&#x27; &lt;= s1[j] &lt;= &#x27;9&#x27;: res.append(&#x27;0&#x27; + s1[j]) break if &#x27;A&#x27; &lt;= s1[j] &lt;= &#x27;N&#x27;: res.append(str(ord(s1[j]) - 55)) breakfor i in range(len2): if s3[i] == s4[i] and (97 &lt;= ord(s3[i]) &lt;= 122 or 65 &lt;= ord(s3[i]) &lt;= 90): if i &lt; 10: res.append(&#x27;0&#x27; + str(i)) else: res.append(str(i))print(f&#x27;&#123;res[0]&#125; &#123;res[1]&#125;:&#123;res[2]&#125;&#x27;) 1015 å¾·æ‰è®ºï¼ˆéƒ¨åˆ†é€šè¿‡ï¼‰123456789101112131415161718192021222324252627from sys import stdininput = lambda: stdin.readline().strip()n, l, h = map(int, input().split())res1, res2, res3, res4 = [], [], [], []for _ in range(n): a, b, c = map(int, input().split()) if b &gt;= h and c &gt;= h: res1.append([a, b, c, b + c]) elif b &gt;= h and c &gt;= l: res2.append([a, b, c, b + c]) elif b &gt;= l and c &gt;= l and b &gt;= c: res3.append([a, b, c, b + c]) elif b &gt;= l and c &gt;= l: res4.append([a, b, c, b + c])print(len(res1) + len(res2) + len(res3) + len(res4))res1.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res2.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res3.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res4.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)for res in res1: print(&#x27; &#x27;.join(map(str, res[: -1])))for res in res2: print(&#x27; &#x27;.join(map(str, res[: -1])))for res in res3: print(&#x27; &#x27;.join(map(str, res[: -1])))for res in res4: print(&#x27; &#x27;.join(map(str, res[: -1]))) 1016 éƒ¨åˆ†A+B1234A, Da, B, Db = input().split()Pa = Da * A.count(Da) if A.count(Da) else &#x27;0&#x27;Pb = Db * B.count(Db) if A.count(Da) else &#x27;0&#x27;print(int(Pa) + int(Pb)) 1017 Aé™¤ä»¥B12a, b = map(int, input().split())print(a // b, a % b) 1018 é”¤å­å‰ªåˆ€å¸ƒ1234567891011121314151617181920212223242526272829303132n = int(input())a = b = c = 0jia, yi = [], []for _ in range(n): x, y = input().split() jia.append(x) yi.append(y) if x == y: c += 1 elif x == &#x27;C&#x27; and y == &#x27;J&#x27; or x == &#x27;J&#x27; and y == &#x27;B&#x27; or x == &#x27;B&#x27; and y == &#x27;C&#x27;: a += 1 jia.append(x) else: b += 1 yi.append(y)print(a, c, b)print(n - a - c, c, n - b - c)b1, c1, j1 = jia.count(&#x27;B&#x27;), jia.count(&#x27;C&#x27;), jia.count(&#x27;J&#x27;)b2, c2, j2 = yi.count(&#x27;B&#x27;), yi.count(&#x27;C&#x27;), yi.count(&#x27;J&#x27;)t1, t2 = max(b1, c1, j1), max(b2, c2, j2)if b1 == t1: print(&#x27;B&#x27;, end=&#x27; &#x27;)elif c1 == t1: print(&#x27;C&#x27;, end=&#x27; &#x27;)else: print(&#x27;J&#x27;, end=&#x27; &#x27;)if b2 == t2: print(&#x27;B&#x27;)elif c2 == t2: print(&#x27;C&#x27;)else: print(&#x27;J&#x27;) 1019 æ•°å­—é»‘æ´12345678910111213n = input()def fun(n): n = map(int, list(str(n).zfill(4))) b = list(map(str, sorted(n))) a = b[::-1] c = &#x27;&#x27;.join(a) d = &#x27;&#x27;.join(b) e = int(c) - int(d) e = str(e).zfill(4) print(f&#x27;&#123;c&#125; - &#123;d&#125; = &#123;e&#125;&#x27;) if e != &#x27;0000&#x27; and e != &#x27;6174&#x27;: fun(e)fun(n) 020 æœˆé¥¼12345678910111213N, D = map(int, input().split())stocks = list(map(float, input().split()))prices = list(map(float, input().split()))profits = [price / stock for stock, price in zip(stocks, prices)]yuebings = sorted(zip(stocks, prices, profits), key=lambda x: x[2], reverse=True)res = 0for stock, price, profit in yuebings: a = min(stock, D) res += a * profit D -= a if not D: breakprint(f&#x27;&#123;res:.2f&#125;&#x27;) 1021 ä¸ªä½æ•°ç»Ÿè®¡12345n = input()nums = &#x27;0123456789&#x27;for num in nums: if n.count(num): print(f&#x27;&#123;num&#125;:&#123;n.count(num)&#125;&#x27;) 1022 Dè¿›åˆ¶çš„A+B12345678910a, b, d = map(int, input().split())c = a + bres = []while c: res.append(c % d) c //= dif res: print(&#x27;&#x27;.join(map(str, res[::-1])))else: print(0) 1023 ç»„ä¸ªæœ€å°æ•°123456789nums = list(map(int, input().split()))res = &#x27;&#x27;for i in range(1, 10): if nums[i]: nums[i] -= 1 res = str(i) breaknums = [str(num) * nums[num] for num in range(10) if nums[num]]print(res + &#x27;&#x27;.join(map(str, nums))) 1024 ç§‘å­¦è®¡æ•°æ³•12345678910111213141516171819202122a = input()res = []if a[0] == &#x27;-&#x27;: res.append(&#x27;-&#x27;)e = a.find(&#x27;E&#x27;)exp = int(a[e+2:])if a[e + 1] == &#x27;+&#x27;: res.append(a[1]) if exp &gt;= e - 3: res.append(a[3: e]) res.append(&#x27;0&#x27; * (exp - e + 3)) else: res.append(a[3: 3 + exp]) res.append(&#x27;.&#x27;) res.append(a[3 + exp: e])elif a[e + 1] == &#x27;-&#x27;: res.append(&#x27;0.&#x27;) if exp &gt; 1: res.append(&#x27;0&#x27; * (exp - 1)) res.append(a[1]) res.append(a[3: e])print(&#x27;&#x27;.join(res)) 1025 åè½¬é“¾è¡¨1234567891011121314start, n, k = map(int, input().split())datas, nexts, lst = [0] * 100001, [0] * 100001, []for _ in range(n): a, b, c = map(int, input().split()) datas[a], nexts[a] = b, cwhile start != -1: lst.append(start) start = nexts[start]cnt = len(lst)for i in range(0, cnt - cnt % k, k): lst[i: i + k] = lst[i: i + k][::-1]for i in range(cnt - 1): print(f&#x27;&#123;lst[i]:05d&#125; &#123;datas[lst[i]]&#125; &#123;lst[i + 1]:05d&#125;&#x27;)print(f&#x27;&#123;lst[-1]:05d&#125; &#123;datas[lst[-1]]&#125; -1&#x27;) 1026 ç¨‹åºè¿è¡Œæ—¶é—´123456789101112c1, c2 = map(int, input().split())t = (c2 - c1 + 50) // 100res = []while t: if t % 60 &lt; 10: res.append(&#x27;0&#x27; + str(t % 60)) else: res.append(str(t % 60)) t //= 60while len(res) &lt; 3: res.append(&#x27;00&#x27;)print(&#x27;:&#x27;.join( res[::-1])) 1027 æ‰“å°æ²™æ¼123456789101112131415n, symbol = input().split()shalous = []shalou = -1for i in range(30): shalou += 2 * (2 * i + 1) shalous.append(shalou)for i in range(30): if int(n) &lt; shalous[i]: breaka = 2 * (i - 1) + 1for j in range(a, 1, -2): print(&#x27; &#x27; * ((a - j) // 2) + symbol * j)for j in range(1, a + 1, 2): print(&#x27; &#x27; * ((a - j) // 2) + symbol * j)print(int(n) - shalous[i - 1]) 1028 äººå£æ™®æŸ¥ï¼ˆéƒ¨åˆ†é€šè¿‡ï¼‰1234567891011121314from sys import stdininput = lambda: stdin.readline().strip()n = int(input())nums = []for _ in range(n): name, birth = input().split() y, m, d = birth.split(&#x27;/&#x27;) if &#x27;18140906&#x27; &lt;= y + m + d &lt;= &#x27;20140906&#x27;: nums.append([name, int(y), int(m), int(d)])nums.sort(key=lambda x: (x[1], x[2], x[3]))if nums: print(len(nums), nums[0][0], nums[-1][0])else: print(0) 1029 æ—§é”®ç›˜1234567891011a, b = input(), input()dicts = &#123;&#125;for char in b: dicts[char] = 1res = []for char in a: if not dicts.get(char, 0): if char.isalpha(): char = char.upper() res.append(char)print(&#x27;&#x27;.join(&#123;&#125;.fromkeys(res).keys())) 1030 å®Œç¾æ•°åˆ—123456789n, p = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, j = 1, 0for i in range(n): while j &lt; n and nums[j] &lt;= nums[i] * p: j += 1 res = max(res, j - i)print(res) 1031 æŸ¥éªŒèº«ä»½è¯1234567891011121314151617181920n = int(input())dicts = [1, 0, &#x27;X&#x27;, 9, 8, 7, 6, 5, 4, 3, 2]weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]def check(id_card): check_num = 0 for i in range(17): if 48 &lt;= ord(id_card[i]) &lt;= 57: check_num += int(id_card[i]) * weights[i] else: return False check_num %= 11 return id_card[-1] == str(dicts[check_num])res = 0for _ in range(n): id_card = input() if not check(id_card): print(id_card) res += 1if not res: print(&#x27;All passed&#x27;) 1032 æŒ–æ˜æœºæŠ€æœ¯å“ªå®¶å¼º123456n = int(input())nums = [-1] + [0] * 100000for _ in range(n): a, b = map(int, input().split()) nums[a] += bprint(nums.index(max(nums)), max(nums)) 1033 æ—§é”®ç›˜æ‰“å­—123456789101112bad, string = list(input()), input()shift = Falsefor i in bad: if i == &#x27;+&#x27;: shift = True if 65 &lt;= ord(i) &lt;= 90: bad.append(i.lower())for i in string: if 65 &lt;= ord(i) &lt;= 90 and shift: continue if i not in bad: print(i, end=&#x27;&#x27;) 1034 æœ‰ç†æ•°å››åˆ™è¿ç®—123456789101112131415161718192021222324252627282930313233343536373839404142import matha, b = input().split()def simplify(a): x, y = map(int, a.split(&#x27;/&#x27;)) return str(x // math.gcd(x, y)) + &#x27;/&#x27; + str(y // math.gcd(x, y))a, b = simplify(a), simplify(b)def calculate(a, b): x1, y1 = map(int, a.split(&#x27;/&#x27;)) x2, y2 = map(int, b.split(&#x27;/&#x27;)) t = str(x1 * y2 + x2 * y1) + &#x27;/&#x27; + str(y1 * y2) res.append(simplify(t)) t = str(x1 * y2 - x2 * y1) + &#x27;/&#x27; + str(y1 * y2) res.append(simplify(t)) t = str(x1 * x2) + &#x27;/&#x27; + str(y1 * y2) res.append(simplify(t)) if not x2: res.append(&#x27;1/0&#x27;) else: if x2 &lt; 0: x2, y2 = -x2, -y2 t = str(x1 * y2) + &#x27;/&#x27; + str(y1 * x2) res.append(simplify(t))res = []calculate(a, b)def simplify2(a): x, y = map(int, a.split(&#x27;/&#x27;)) if not y: return &#x27;Inf&#x27; ans = &#x27;&#x27; t = abs(x) // y if not x % y: ans = str(t) elif t: ans = str(t) + &#x27; &#x27; + str(abs(x - t * y * x // abs(x))) + &#x27;/&#x27; + str(y) else: ans = str(abs(x)) + &#x27;/&#x27; + str(y) return &#x27;(-&#x27; + ans + &#x27;)&#x27; if x &lt; 0 else ansa, b, res = simplify2(a), simplify2(b), [simplify2(i) for i in res]print(f&#x27;&#123;a&#125; + &#123;b&#125; = &#123;res[0]&#125;&#x27;)print(f&#x27;&#123;a&#125; - &#123;b&#125; = &#123;res[1]&#125;&#x27;)print(f&#x27;&#123;a&#125; * &#123;b&#125; = &#123;res[2]&#125;&#x27;)print(f&#x27;&#123;a&#125; / &#123;b&#125; = &#123;res[3]&#125;&#x27;) 1035 æ’å…¥ä¸å½’å¹¶123456789101112131415161718192021222324252627282930313233n = int(input())start = list(map(int, input().split()))mid = list(map(int, input().split()))for i in range(n - 1, -1, -1): if start[i] != mid[i]: breakif sorted(mid[:i + 1]) == mid[:i + 1]: print(&#x27;Insertion Sort&#x27;) a = start[i + 1] while a &gt; start[i]: i += 1 a = start[i + 1] for j in range(i + 1): if a &lt; mid[j]: print(&#x27; &#x27;.join(map(str, (mid[: j] + [a] + mid[j:i + 1] + mid[i+2:])))) breakelse: print(&#x27;Merge Sort&#x27;) i = 1 flag = True while i &lt; n and flag: i *= 2 for j in range(i, n, i): if sorted(mid[j-i: j]) != mid[j-i: j]: flag = False break if i &gt; j: mid.sort() else: for j in range(i, n, i): mid[j-i: j] = sorted(mid[j-i: j]) mid[j:] = sorted(mid[j:]) print(&#x27; &#x27;.join(map(str, mid))) 1036 è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹1234567n, c = input().split()n = int(n)row = int(n / 2 + 0.5) - 2print(c * n)for _ in range(row): print(c + &#x27; &#x27; * (n - 2) + c)print(c * n) 1037 åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’±12345678910111213p, a = input().split()g1, s1, k1 = map(int, p.split(&#x27;.&#x27;))g2, s2, k2 = map(int, a.split(&#x27;.&#x27;))t1 = (g1 * 17 + s1) * 29 + k1t2 = (g2 * 17 + s2) * 29 + k2t3 = abs(t2 - t1)k3 = t3 % 29s3 = t3 // 29 % 17g3 = (t3 // 29 - s3) // 17if t2 &gt;= t1: print(f&#x27;&#123;g3&#125;.&#123;s3&#125;.&#123;k3&#125;&#x27;)else: print(f&#x27;-&#123;g3&#125;.&#123;s3&#125;.&#123;k3&#125;&#x27;) 1038 ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿ12345678910n = int(input())nums = list(map(int, input().split()))checks = list(map(int, input().split()))scores = [0] * 101for num in nums: scores[num] += 1res = []for check in checks[1:]: res.append(scores[check])print(&#x27; &#x27;.join(map(str, res))) 1039 åˆ°åº•ä¹°ä¸ä¹°123456789101112s, t = input(), input()a, dict1 = 0, &#123;&#125;for char in s: dict1[char] = dict1.get(char, 0) + 1for char in t: if dict1.get(char, 0): a += 1 dict1[char] -= 1if a == len(t): print(f&#x27;Yes &#123;len(s) - len(t)&#125;&#x27;)else: print(f&#x27;No &#123;len(t) - a&#125;&#x27;) 1040 æœ‰å‡ ä¸ªPAT123456789101112131415161718192021import bisects = input()p, a, pa, t = [], [], [], []for idx, char in enumerate(s): if char == &#x27;P&#x27;: p.append(idx) elif char == &#x27;A&#x27;: a.append(idx) elif char == &#x27;T&#x27;: t.append(idx)tmp = 0for i in a: x = bisect.bisect(p, i) tmp += x pa.append(tmp)res = 0for i in t: x = bisect.bisect(a, i) if x: res += pa[x-1]print(res % 1000000007) 1041 è€ƒè¯•åº§ä½å·123456789n = int(input())nums = [0] * 10001for _ in range(n): a, b, c = map(int, input().split()) nums[b] = (a, c)m = int(input())inqurie = map(int, input().split())for i in inqurie: print(nums[i][0], nums[i][1]) 1042 å­—ç¬¦ç»Ÿè®¡1234567891011from collections import Counters = input()t = []for char in s: if 65 &lt;= ord(char) &lt;= 90: char = char.lower() if 97 &lt;= ord(char) &lt;= 122: t.append(char)t.sort()t = Counter(t)print(t.most_common(1)[0][0], t.most_common(1)[0][1]) 1043 è¾“å‡ºPATest1234567891011from collections import Counters = input()t = [char for char in s if char in &#x27;PATest&#x27;]counter = Counter(t)res = &#x27;&#x27;for _ in range(counter.most_common(1)[0][1]): for char in &#x27;PATest&#x27;: if counter[char]: counter[char] -= 1 res += charprint(res) 1044 ç«æ˜Ÿæ•°å­—12345678910111213141516171819202122232425n = int(input())units = [&#x27;tret&#x27;, &#x27;jan&#x27;, &#x27;feb&#x27;, &#x27;mar&#x27;, &#x27;apr&#x27;, &#x27;may&#x27;, &#x27;jun&#x27;, &#x27;jly&#x27;, &#x27;aug&#x27;, &#x27;sep&#x27;, &#x27;oct&#x27;, &#x27;nov&#x27;, &#x27;dec&#x27;]tens = [&#x27;tam&#x27;, &#x27;hel&#x27;, &#x27;maa&#x27;, &#x27;huh&#x27;, &#x27;tou&#x27;, &#x27;kes&#x27;, &#x27;hei&#x27;, &#x27;elo&#x27;, &#x27;syy&#x27;, &#x27;lok&#x27;, &#x27;mer&#x27;, &#x27;jou&#x27;]for _ in range(n): a = input() try: a = int(a) except ValueError: if len(a) &gt; 4: x, y = a.split() ten, unit = tens.index(x) + 1, units.index(y) print(ten * 13 + unit) else: if a in units: print(units.index(a)) else: print((tens.index(a) + 1) * 13) else: unit, ten = a % 13, a // 13 if ten &gt; 0 and unit &gt; 0: print(tens[ten - 1], units[unit]) elif ten &gt; 0: print(tens[ten - 1]) else: print(units[unit]) 1045 å¿«é€Ÿæ’åº1234567891011121314151617n = int(input())nums = list(map(int, input().split()))lefts, rights, res = [], [], []left, right = 0, float(&#x27;inf&#x27;)for num in nums: if left &lt; num: left = num lefts.append(left)for num in nums[::-1]: if right &gt; num: right = num rights.append(right)for left, num, right in zip(lefts, nums, rights[::-1]): if left &lt;= num &lt;= right: res.append(num)print(len(res))print(&#x27; &#x27;.join(map(str, res))) 1046 åˆ’æ‹³1234567891011n = int(input())a = b = 0for _ in range(n): x1, x2, y1, y2 = map(int, input().split()) if x2 == y2: continue if x1 + y1 == x2: b += 1 elif x1 + y1 == y2: a += 1print(a, b) 1047 ç¼–ç¨‹å›¢ä½“èµ›12345678n = int(input())nums = [0] * 1001for _ in range(n): num, score = input().split() a, b = map(int, num.split(&#x27;-&#x27;)) nums[a] += int(score)res = max(nums)print(nums.index(res), res) 1048 æ•°å­—åŠ å¯†1234567891011121314a, b = input().split()l = max(len(a), len(b))a = list(map(int, a[::-1])) + [0] * (l - len(a))b = list(map(int, b[::-1])) + [0] * (l - len(b))dicts = [&#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;]res = []for i in range(l): if i % 2 == 0: t = (a[i] + b[i]) % 13 res.append(dicts[t - 10] if t &gt;= 10 else t) else: res.append((b[i] - a[i] + 10) % 10)print(&#x27;&#x27;.join(map(str, res[::-1]))) 1049 æ•°åˆ—çš„ç‰‡æ®µå’Œï¼ˆéƒ¨åˆ†é€šè¿‡ï¼‰12345678n = int(input())nums = list(map(float, input().split()))res, a = 0, 1for num in nums: res += num * a * n n -= 1 a += 1print(f&#x27;&#123;res:.2f&#125;&#x27;) 1050 èºæ—‹çŸ©é˜µ123456789101112131415161718192021222324252627282930313233343536import mathN = int(input())nums = list(map(int, input().split()))nums.sort(reverse=True)m = n = 0for i in range(1, int(math.sqrt(N)) + 1): if N % i == 0: n, m = i, N // ires = [[0] * n for _ in range(m)]u, d, l, r = 0, m, 0, nidx = 0while True: res[u][l:r] = nums[idx: idx+r-l] u += 1 idx += r-l if u == d or l == r: break for i in range(u, d): res[i][r-1] = nums[idx] idx += 1 r -= 1 if u == d or l == r: break res[d-1][l:r] = nums[idx: idx+r-l][::-1] idx += r-l d -= 1 if u == d or l == r: break for i in range(d-1, u-1, -1): res[i][l] = nums[idx] idx += 1 l += 1 if u == d or l == r: breakfor row in res: print(&#x27; &#x27;.join(map(str, row))) 1051 å¤æ•°ä¹˜æ³•12345678910111213141516import mathr1, p1, r2, p2 = map(float, input().split())a1 = r1 * math.cos(p1)b1 = r1 * math.sin(p1)a2 = r2 * math.cos(p2)b2 = r2 * math.sin(p2)a3 = a1*a2-b1*b2 b3 = a1*b2+a2*b1if abs(a3) &lt; 0.005: a3 = 0if abs(b3) &lt; 0.005: print(f&#x27;&#123;a3:.2f&#125;+0.00i&#x27;)elif b3 &gt; 0: print(f&#x27;&#123;a3:.2f&#125;+&#123;b3:.2f&#125;i&#x27;)else: print(f&#x27;&#123;a3:.2f&#125;&#123;b3:.2f&#125;i&#x27;) 1052 å–ä¸ªèŒ1çœ‹ä¸æ‡‚é¢˜ 1053 ä½æˆ¿ç©ºç½®ç‡1234567891011n, e, d = map(float, input().split())maybe_vacant = vacant = 0for _ in range(int(n)): nums = list(map(float, input().split())) t = sum(1 for i in nums[1:] if i &lt; e) if t / nums[0] &gt; 0.5: if nums[0] &gt; d: vacant += 1 else: maybe_vacant += 1print(f&#x27;&#123;maybe_vacant / n * 100:.1f&#125;% &#123;vacant / n * 100:.1f&#125;%&#x27;)","tags":["ç®—æ³•","PAT","Python"],"categories":["ç®—æ³•"]},{"title":"ç®—æ³•åŸºç¡€è¯¾","path":"/2024/01/29/ç®—æ³•åŸºç¡€è¯¾/","content":"ç®—æ³•åŸºç¡€è¯¾åŸºç¡€ç®—æ³•å¿«é€Ÿæ’åº785. å¿«é€Ÿæ’åº 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))def quick_sort(l, r): if l &gt;= r: return i, j = l - 1, r + 1 x = nums[l + r &gt;&gt; 1] while i &lt; j: while True: i += 1 if nums[i] &gt;= x: break while True: j -= 1 if nums[j] &lt;= x: break if i &lt; j: nums[i], nums[j] = nums[j], nums[i] quick_sort(l, j) quick_sort(j + 1, r)quick_sort(0, n - 1)print(*nums) 786. ç¬¬kä¸ªæ•° 12345678910111213141516171819202122232425n, k = map(int, input().split())nums = list(map(int, input().split()))def quick_select(l, r, k): if l &gt;= r: return nums[l] x = nums[(l + r) // 2] i, j = l - 1, j + 1 while i &lt; j: while True: i += 1 if nums[i] &lt;= x: break while True: j -= 1 if nums[j] &gt;= x: break if i &lt; j: nums[i], nums[j] = nums[j], nums[i] sl = j - l + 1 if k &lt;= sl: return quick_select(l, j, k) else: return quick_select(j + 1, r, k - sl) print(quick_select(0, n - 1, k)) å½’å¹¶æ’åº787. å½’å¹¶æ’åº 1234567891011121314151617181920212223n = int(input())nums = [int(x) for x in input().split()]def merge_sort(nums, l, r): if l &gt;= r: return mid = (l + r) // 2 merge_sort(nums, l, mid) merge_sort(nums, mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt;= nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp merge_sort(nums, 0, n - 1)print(&#x27; &#x27;.join(list(map(str, nums)))) 788. é€†åºå¯¹çš„æ•°é‡ 1234567891011121314151617181920212223n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l &gt;= r: return 0 mid = l + r &gt;&gt; 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt;= nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) äºŒåˆ†789. æ•°çš„èŒƒå›´ 123456789101112131415161718192021222324n, q = map(int, input().split())nums = [int(x) for x in input().split()]while q &gt; 0: q -= 1 x = int(input()) l, r = 0, n - 1 while l &lt; r: mid = (l + r) // 2 if nums[mid] &gt;= x: r = mid else: l = mid + 1 if nums[l] != x: print(&#x27;-1 -1&#x27;) continue left = l l, r = 0, n - 1 while l &lt; r: mid = (l + r + 1) // 2 if nums[mid] &lt;= x: l = mid else: r = mid - 1 print(f&#x27;&#123;left&#125; &#123;l&#125;&#x27;) 790. æ•°çš„ä¸‰æ¬¡æ–¹æ ¹ 123456789n = float(input())l, r = -100, 100while abs(l - r) &gt; 1e-8: mid = (l + r) / 2 if mid ** 3 &gt; n: r = mid else: l = midprint(f&#x27;&#123;l:.6f&#125;&#x27;) å‰ç¼€å’Œ795. å‰ç¼€å’Œ 12345678n, m = map(int, input().split())nums = [int(x) for x in input().split()]sums = [0] * (n + 1)for i in range(n): sums[i + 1] = sums[i] + nums[i]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l - 1]) 796. å­çŸ©é˜µçš„å’Œ 12345678910111213n, m, q = map(int, input().split())nums = [[0] * (m + 1) for _ in range(n + 1)]sums = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:]for i in range(1, n + 1): for j in range(1, m + 1): sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1 - 1][y2] - sums[x2][y1 - 1] + sums[x1 - 1][y1 - 1]) å·®åˆ†797. å·®åˆ† 1234567891011121314n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diffs = [0] * (n + 2)def insert(l, r, c): diffs[l] += c diffs[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diffs[i] print(nums[i], end=&#x27; &#x27;) 798. å·®åˆ†çŸ©é˜µ 123456789101112131415161718192021n, m, q = map(int, input().split())nums = [[0] * (m + 2) for _ in range(n + 2)]diffs = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diffs[x1][y1] += c diffs[x1][y2 + 1] -= c diffs[x2 + 1][y1] -= c diffs[x2 + 1][y2 + 1] += cfor i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:] for j in range(1, m + 1): insert(i, j, i, j, tmps[j - 1])for _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diffs[i][j] print(nums[i][j], end=&#x27; &#x27;) print() åŒæŒ‡é’ˆ799. æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ— 1234567891011n = int(input())nums = list(map(int, input().split()))dic = dict.fromkeys(nums, 0)j = res = 0for i in range(n): dic[nums[i]] += 1 while dic[nums[i]] &gt; 1: dic[nums[j]] -= 1 j += 1 res = max(res, i - j + 1)print(res) 800. æ•°ç»„å…ƒç´ çš„ç›®æ ‡å’Œ 12345678910n, m, x = map(int, input().split())a = list(map(int, input().split()))b = list(map(int, input().split()))j = m - 1for i in range(n): while j and a[i] + b[j] &gt; x: j -= 1 if a[i] + b[j] == x: print(i, j) break äºŒè¿›åˆ¶801. äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•° 1234567891011n = int(input())nums = list(map(int, input().split()))def lowbit(x): return x &amp; -xfor num in nums: res = 0 while num: num -= lowbit(num) res += 1 print(res, end=&#x27; &#x27;) ç¦»æ•£åŒ–802. åŒºé—´å’Œ 12345678910111213141516171819202122232425262728293031323334353637n, m = map(int, input().split())# adds = [list(map(int, input().split())) for _ in range(n)]# querys = [list(map(int, input().split())) for _ in range(m)]# indexs = [add[0] for add in adds]# for l, r in querys:# indexs += [l, r]adds, querys, indexs = [], [], []for i in range(n): x, c = map(int, input().split()) adds.append([x, c]) indexs.append(x)for i in range(m): l, r = map(int, input().split()) querys.append([l, r]) indexs.append(l) indexs.append(r)indexs.sort()indexs = list(set(indexs))n = len(indexs)def find(x): l, r = 0, n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if indexs[mid] &gt;= x: r = mid else: l = mid + 1 return l + 1nums = [0] * (n + 1)sums = [0] * (n + 1)for x, c in adds: nums[find(x)] += cfor i in range(1, n + 1): sums[i] = sums[i - 1] + nums[i]for l, r in querys: print(sums[find(r)] - sums[find(l) - 1]) åŒºé—´åˆå¹¶803. åŒºé—´åˆå¹¶ 12345678910111213n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key=lambda x: x[0])st, ed = float(&#x27;-inf&#x27;), float(&#x27;-inf&#x27;)res = 0for l, r in nums: if ed &lt; l: res += 1 st = l ed = r else: ed = max(ed, r)print(res) æ•°æ®ç»“æ„å•é“¾è¡¨826. å•é“¾è¡¨ 1234567891011121314151617181920212223242526272829303132333435363738def insert_head(x): global head, idx e[idx] = x ne[idx] = head head = idx idx += 1 def insert(k, x): global idx e[idx] = x ne[idx] = ne[k] ne[k] = idx idx += 1 def remove(k): ne[k] = ne[ne[k]] N = 100010e, ne = [0] * N, [0] * Nhead, idx = -1, 0n = int(input())for _ in range(n): ops = input().split() if ops[0] == &#x27;H&#x27;: insert_head(int(ops[1])) elif ops[0] == &#x27;I&#x27;: insert(int(ops[1]) - 1, int(ops[2])) else: k = int(ops[1]) if not k: head = ne[head] remove(k - 1)i = headres = []while i != -1: res.append(e[i]) i = ne[i]print(&#x27; &#x27;.join(map(str, res))) åŒé“¾è¡¨827. åŒé“¾è¡¨ 123456789101112131415161718192021222324252627282930313233N = 100010e, l, r = [0] * N, [0] * N, [0] * Nr[0], l[1], idx = 1, 0, 2def insert(k, x): global idx e[idx] = x r[idx] = r[k] l[idx] = k l[r[k]] = idx r[k] = idx idx += 1def remove(k): r[l[k]] = r[k] l[r[k]] = l[k]n = int(input())for _ in range(n): ops = input().split() if ops[0] == &#x27;L&#x27;: insert(0, int(ops[1])) elif ops[0] == &#x27;R&#x27;: insert(l[1], int(ops[1])) elif ops[0] == &#x27;IL&#x27;: insert(l[int(ops[1]) + 1], int(ops[2])) elif ops[0] == &#x27;IR&#x27;: insert(int(ops[1]) + 1, int(ops[2])) else: remove(int(ops[1]) + 1)i = r[0]res = []while i != 1: res.append(e[i]) i = r[i]print(&#x27; &#x27;.join(map(str, res))) æ ˆ828. æ¨¡æ‹Ÿæ ˆ 123456789101112n = int(input())stack = []for _ in range(n): ops = input().split() if ops[0] == &#x27;push&#x27;: stack.append(ops[1]) elif ops[0] == &#x27;pop&#x27;: stack.pop() elif ops[0] == &#x27;query&#x27;: print(stack[-1]) elif ops[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if stack else &#x27;YES&#x27;) 3302. è¡¨è¾¾å¼æ±‚å€¼ 12345678910111213141516171819202122232425262728293031323334353637383940dic = &#123;&#x27;(&#x27;: 0, &#x27;+&#x27;: 1, &#x27;-&#x27;: 1, &#x27;*&#x27;: 2, &#x27;/&#x27;: 2&#125;ops, nums = [], []def new_eval(): b = nums.pop() a = nums.pop() o = ops.pop() if o == &#x27;+&#x27;: nums.append(a + b) elif o == &#x27;-&#x27;: nums.append(a - b) elif o == &#x27;*&#x27;: nums.append(a * b) elif o == &#x27;/&#x27;: nums.append(int(a / b))a = input()n = len(a)i = 0while i &lt; n: c = a[i] if c.isdigit(): j, x = i, 0 while j &lt; n and a[j].isdigit(): x = x * 10 + int(a[j]) j += 1 i = j - 1 nums.append(x) elif c == &#x27;(&#x27;: ops.append(c) elif c == &#x27;)&#x27;: while ops[-1] != &#x27;(&#x27;: new_eval() ops.pop() else: while ops and dic[ops[-1]] &gt;= dic[c]: new_eval() ops.append(c) i += 1while ops: new_eval()print(nums[-1]) é˜Ÿåˆ—829. æ¨¡æ‹Ÿé˜Ÿåˆ— 12345678910111213import collectionsn = int(input())queue = collections.deque()for _ in range(n): ops = input().split() if ops[0] == &#x27;push&#x27;: queue.append(ops[1]) elif ops[0] == &#x27;pop&#x27;: queue.popleft() elif ops[0] == &#x27;query&#x27;: print(queue[0]) elif ops[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if queue else &#x27;YES&#x27;) å•è°ƒæ ˆ830. å•è°ƒæ ˆ 12345678910111213141516n = int(input())nums = list(map(int, input().split()))stack, res = [], []for num in nums: if not stack: stack.append(num) res.append(-1) continue while stack and num &lt;= stack[-1]: stack.pop() if not stack: res.append(-1) else: res.append(stack[-1]) stack.append(num)print(&#x27; &#x27;.join(map(str, res))) å•è°ƒé˜Ÿåˆ—154. æ»‘åŠ¨çª—å£ 1234567891011121314151617181920212223242526n, k = map(int, input().split())nums = list(map(int, input().split()))q = [0] * 1000010hh, tt = 0, -1res1, res2 = [], []for i in range(n): if hh &lt;= tt and i - k + 1 &gt; q[hh]: hh += 1 while hh &lt;= tt and nums[q[tt]] &gt; nums[i]: tt -= 1 tt += 1 q[tt] = i if i &gt;= k - 1: res1.append(nums[q[hh]])hh, tt = 0, -1for i in range(n): if hh &lt;= tt and i - k + 1 &gt; q[hh]: hh += 1 while hh &lt;= tt and nums[q[tt]] &lt; nums[i]: tt -= 1 tt += 1 q[tt] = i if i &gt;= k - 1: res2.append(nums[q[hh]])print(&#x27; &#x27;.join(map(str, res1)))print(&#x27; &#x27;.join(map(str, res2))) KMP831. KMPå­—ç¬¦ä¸² 1234567891011121314151617181920212223n = int(input())p = &#x27; &#x27; + input()m = int(input())s = &#x27; &#x27; + input()ne = [0] * 1000010j = 0for i in range(2, n + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = jj = 0res = []for i in range(1, m + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == n: res.append(i - j) j = ne[j]print(&#x27; &#x27;.join(map(str, res))) Trie835. Trieå­—ç¬¦ä¸²ç»Ÿè®¡ 1234567891011121314151617181920212223242526272829N = 10010tries = [[0] * 26 for _ in range(N)]cnt = [0] * Nidx = 1def insert(string): global idx p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: tries[p][t] = idx idx += 1 p = tries[p][t] cnt[p] += 1def query(string): p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: return 0 p = tries[p][t] return cnt[p]n = int(input())for _ in range(n): op, string = input().split() if op == &#x27;I&#x27;: insert(string) elif op == &#x27;Q&#x27;: print(query(string)) 143. æœ€å¤§å¼‚æˆ–å¯¹ 1234567891011121314151617181920212223242526272829303132N = 100010M = 31 * Ntries = [[0] * 2 for _ in range(M)]n = int(input())nums = list(map(int, input().split()))idx, res = 0, 0def insert(x): global idx p = 0 for i in range(32)[::-1]: u = x &gt;&gt; i &amp; 1 if not tries[p][u]: idx += 1 tries[p][u] = idx p = tries[p][u]def query(x): p, res = 0, 0 for i in range(32)[::-1]: u = x &gt;&gt; i &amp; 1 if tries[p][u^1]: res = res * 2 + u^1 p = tries[p][u^1] else: res = res * 2 + u p = tries[p][u] return resfor num in nums: insert(num) t = query(num) res = max(res, t^num)print(res) å¹¶æŸ¥é›†836. åˆå¹¶é›†åˆ 12345678910111213141516n, m = map(int, input().split())p = [i for i in range(n + 1)]def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): op, a, b = input().split() a, b = int(a), int(b) if op == &#x27;M&#x27;: p[find(a)] = find(b) elif op == &#x27;Q&#x27;: if find(a) == find(b): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) 837. è¿é€šå—ä¸­ç‚¹çš„æ•°é‡ 1234567891011121314151617181920212223n, m = map(int, input().split())p = [i for i in range(n + 1)]size = [1] * (n + 1)def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): ops = input().split() if ops[0] == &#x27;C&#x27;: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): continue size[find(b)] += size[find(a)] p[find(a)] = find(b) elif ops[0] == &#x27;Q1&#x27;: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) elif ops[0] == &#x27;Q2&#x27;: print(size[find(int(ops[1]))]) 240. é£Ÿç‰©é“¾ 1234567891011121314151617181920212223242526272829n, m = map(int, input().split())p, d = [i for i in range(n + 1)], [0] * (n + 1)res = 0def find(x): if p[x] != x: t = find(p[x]) d[x] += d[p[x]] p[x] = t return p[x]for _ in range(m): op, x, y = map(int, input().split()) if x &gt; n or y &gt; n: res += 1 continue px, py = find(x), find(y) diff = (d[x] - d[y]) % 3 if op == 1: if px == py and diff: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] elif op == 2: if px == py and diff != 1: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] + 1print(res) å †838. å †æ’åº 123456789101112131415161718n, m = map(int, input().split())heap = [0] + list(map(int, input().split()))def down(k): t = k if 2 * k &lt;= n and heap[2 * k] &lt; heap[t]: t = 2 * k if 2 * k + 1 &lt;= n and heap[2 * k + 1] &lt; heap[t]: t = 2 * k + 1 if t != k: heap[t], heap[k] = heap[k], heap[t] down(t)for i in range(int(n / 2), -1, -1): down(i)for _ in range(m): print(heap[1], end=&#x27; &#x27;) heap[1] = heap[n] n -= 1 down(1) 839. æ¨¡æ‹Ÿå † 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647N = 100010heap, ph, hp = [0] * N, [0] * N, [0] * Nsize, idx = 0, 0n = int(input())def swap(a, b): ph[hp[a]], ph[hp[b]] = b, a hp[a], hp[b] = hp[b], hp[a] heap[a], heap[b] = heap[b], heap[a]def down(k): t = k if 2 * k &lt;= size and heap[2 * k] &lt; heap[t]: t = 2 * k if 2 * k + 1 &lt;= size and heap[2 * k + 1] &lt; heap[t]: t = 2 * k + 1 if t != k: swap(t, k) down(t)def up(k): while k // 2 and heap[k // 2] &gt; heap[k]: swap(k // 2, k) k //= 2for _ in range(n): ops = input().split() if ops[0] == &#x27;I&#x27;: size += 1 idx += 1 heap[size] = int(ops[1]) ph[idx] = size hp[size] = idx up(size) elif ops[0] == &#x27;PM&#x27;: print(heap[1]) elif ops[0] == &#x27;DM&#x27;: swap(1, size) size -= 1 down(1) elif ops[0] == &#x27;D&#x27;: k = ph[int(ops[1])] swap(k, size) size -= 1 down(k) up(k) elif ops[0] == &#x27;C&#x27;: k, x = ph[int(ops[1])], int(ops[2]) heap[k] = x down(k) up(k) å“ˆå¸Œè¡¨840. æ¨¡æ‹Ÿæ•£åˆ—è¡¨ æ‹‰é“¾æ³• 12345678910111213141516171819202122232425262728N = 100003h, e, ne = [-1] * N, [0] * N, [0] * Nn = int(input())idx = 0def insert(x): global idx k = x % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1def find(x): k = x % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return Falsefor _ in range(n): op, x = input().split() if op == &#x27;I&#x27;: insert(int(x)) elif op == &#x27;Q&#x27;: if find(int(x)): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) å¼€æ”¾å¯»å€æ³• 123456789101112131415161718192021N = 200003null = 0x3f3f3f3fh = [null] * Nn = int(input())def find(x): k = x % N while h[k] != null and h[k] != x: k += 1 if k == N: k = 0 return kfor _ in range(n): op, x = input().split() k = find(int(x)) if op == &#x27;I&#x27;: h[k] = int(x) elif op == &#x27;Q&#x27;: if h[k] == int(x): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) python è‡ªå¸¦ 123456789from collections import defaultdictdic = defaultdict(int)n = int(input())for _ in range(n): op, x = input().split() if op == &#x27;I&#x27;: dic[x] += 1 elif op == &#x27;Q&#x27;: print(&#x27;Yes&#x27; if dic[x] else &#x27;No&#x27;) 841. å­—ç¬¦ä¸²å“ˆå¸Œ 123456789101112131415n, m = map(int, input().split())s = input()Q, P = 1 &lt;&lt; 64, 131h, p = [0] * (n + 1), [1] * (n + 1)def get(l, r): return (h[r] - h[l - 1] * p[r - l + 1]) % Qfor i in range(1, n + 1): h[i] = (h[i - 1] * P + ord(s[i - 1])) % Q p[i] = (p[i - 1] * P) % Qfor _ in range(m): l1, r1, l2, r2 = map(int, input().split()) if get(l1, r1) == get(l2, r2): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) æœç´¢ä¸å›¾è®ºDFS842. æ’åˆ—æ•°å­— dfs åšæ³• 1234567891011121314n = int(input())path = [0] * nst = [False] * (n + 1)def dfs(x): if x == n: print(&#x27; &#x27;.join(map(str, path))) return for i in range(1, n + 1): if not st[i]: path[x] = i st[i] = True dfs(x + 1) st[i] = Falsedfs(0) python permutationæ–¹æ³• 12345import itertoolsn = int(input())nums = [i for i in range(1, n + 1)]for res in itertools.permutations(nums, n): print(&#x27; &#x27;.join(map(str, res))) 843. n-çš‡åé—®é¢˜ å…¨æ’åˆ— 1234567891011121314151617n = int(input())g = [[&#x27;.&#x27; for _ in range(n)] for _ in range(n)]col, dg, udg = [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x): if x == n: for i in range(n): print(&#x27;&#x27;.join(map(str, g[i]))) print() return for y in range(n): if not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = &#x27;Q&#x27; col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x + 1) g[x][y] = &#x27;.&#x27; col[y] = dg[x + y] = udg[n - x + y] = 0dfs(0) åŸå§‹æš´åŠ›æšä¸¾ 123456789101112131415161718192021n = int(input())g = [[&#x27;.&#x27; for _ in range(n)] for _ in range(n)]row, col, dg, udg = [0] * n, [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x, y, s): if y == n: y = 0 x += 1 if x == n: if s == n: for i in range(n): print(&#x27;&#x27;.join(map(str, g[i]))) print() return if not row[x] and not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = &#x27;Q&#x27; row[x] = col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x, y + 1, s + 1) g[x][y] = &#x27;.&#x27; row[x] = col[y] = dg[x + y] = udg[n - x + y] = 0 dfs(x, y + 1, s)dfs(0, 0, 0) BFS844. èµ°è¿·å®« 12345678910111213141516171819202122from collections import dequen, m = map(int, input().split())g = [list(map(int, input().split())) for _ in range(n)]path = [[-1] * m for _ in range(n)]prev = [[0] * m for _ in range(n)]q = deque()q.append((0, 0))path[0][0] = 0while q: a, b = q.popleft() for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): x = a + l y = b + r if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and not g[x][y] and path[x][y] == -1: q.append((x, y)) path[x][y] = path[a][b] + 1 prev[x][y] = (a, b)print(path[-1][-1])x, y = n - 1, m - 1while x &gt; 0 or y &gt; 0: x,y = prev[x][y] print(x,y) 845. å…«æ•°ç  1234567891011121314151617181920212223242526from collections import dequestart = &#x27;&#x27;.join(input().split())queue = deque([start])d = &#123;start: 0&#125;target = &#x27;12345678x&#x27;def swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 &lt; idx2 else(idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:]def bfs(): while queue: t = queue.popleft() distance = d[t] if t == target: return distance idx = t.find(&#x27;x&#x27;) x, y = idx // 3, idx % 3 for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): a, b = x + l, y + r if 0 &lt;= a &lt; 3 and 0 &lt;= b &lt; 3: t = swap(t, a * 3 + b, idx) if t not in d: d[t] = distance + 1 queue.append(t) t = swap(t, a * 3 + b, idx) return -1print(bfs()) æ ‘ä¸å›¾çš„æ·±åº¦ä¼˜å…ˆéå†846. æ ‘çš„é‡å¿ƒ ç”¨é“¾è¡¨ä½œä¸ºé‚»æ¥è¡¨ 12345678910111213141516171819202122232425262728293031n = int(input())h, e, ne = [-1] * (n + 1), [0] * (2 * n), [0] * (2 * n)state = [False] * (n + 1)idx, ans = 0, ndef add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxdef dfs(u): global ans state[u] = True size, res = 1, 0 cur = h[u] while cur != -1: j = e[cur] if not state[j]: s = dfs(j) res = max(res, s) size += s cur = ne[cur] res = max(res, n - size) ans = min(ans, res) return sizefor _ in range(n - 1): a, b = map(int, input().split()) add(a, b) add(b, a)dfs(1)print(ans) ä½¿ç”¨pythonçš„list[list] 12345678910111213141516171819202122n = int(input())adj_list = [[] for _ in range(n + 1)]state = [False] * (n + 1)ans = nfor _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u): global ans state[u] = True size, res = 1, 0 for j in adj_list[u]: if not state[j]: s = dfs(j) res = max(res, s) size += s res = max(res, n - size) ans = min(ans, res) return sizedfs(1)print(ans) æ ‘ä¸å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†847. å›¾ä¸­ç‚¹çš„å±‚æ¬¡ 12345678910111213141516171819202122232425262728293031from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)dist = [-1] * (n + 1)queue = deque([1])dist[1] = 0idx = 0def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b)def bfs(): while queue: node = queue.popleft() d = dist[node] if node == n: return d cur = h[node] while cur != -1: j = e[cur] if dist[j] == -1: queue.append(j) dist[j] = d + 1 cur = ne[cur] return -1print(bfs()) ä½¿ç”¨pythonçš„list[list] 1234567891011121314151617181920from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]d = [0] * (n + 1)queue = deque([1])for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def bfs(): while queue: cur = queue.popleft() distance = d[cur] if cur == n: return distance for j in adj_list[cur]: if not d[j]: d[j] = distance + 1 queue.append(j) return -1print(bfs()) æ‹“æ‰‘æ’åº848. æœ‰å‘å›¾çš„æ‹“æ‰‘åºåˆ— 123456789101112131415161718192021222324252627282930313233343536from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)d = [0] * (n + 1)idx = 0queue = deque()def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b) d[b] += 1def topsort(): for i in range(1, n + 1): if not d[i]: queue.append(i) res = [] while queue: node = queue.popleft() res.append(node) t = h[node] while t != -1: j = e[t] d[j] -= 1 if d[j] == 0: queue.append(j) t = ne[t] if len(res) == n: print(&#x27; &#x27;.join(map(str, res))) else: print(&#x27;-1&#x27;)topsort() ä½¿ç”¨pythonçš„list[list] 123456789101112131415161718192021222324from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]in_degree = [0] * (n + 1)queue = deque()for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) in_degree[b] += 1for i in range(1, n + 1): if not in_degree[i]: queue.append(i)res = []while queue: node = queue.popleft() res.append(node) for j in adj_list[node]: in_degree[j] -= 1 if not in_degree[j]: queue.append(j)if len(res) == n: print(&#x27; &#x27;.join(map(str, res)))else: print(-1) Dijkstra849. Dijkstraæ±‚æœ€çŸ­è·¯ I 12345678910111213141516n, m = map(int, input().split())g = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)]dist = [float(&#x27;inf&#x27;)] * (n + 1)state = [False] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)def dijkstra(): for _ in range(1, n + 1): t = min((j for j in range(1, n + 1) if not state[j]), key=lambda j: dist[j]) state[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], dist[t] + g[t][j]) print(dist[n] if dist[n] != float(&#x27;inf&#x27;) else -1)dijkstra() 850. Dijkstraæ±‚æœ€çŸ­è·¯ II 123456789101112131415161718192021import heapqn, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(&#x27;inf&#x27;)] * (n + 1)dist[1] = 0heap = []heapq.heappush(heap, (0, 1))s = set()for _ in range(m): x, y, z = map(int, input().split()) adj_list[x].append((y, z))while heap: d, node = heapq.heappop(heap) if node in s: continue s.add(node) for neighbor, weight in adj_list[node]: if dist[neighbor] &gt; dist[node] + weight: dist[neighbor] = dist[node] + weight heapq.heappush(heap, (dist[neighbor], neightbor))print(dist[n] if dist[n] != float(&#x27;inf&#x27;) else -1) bellman-ford853. æœ‰è¾¹æ•°é™åˆ¶çš„æœ€çŸ­è·¯ 123456789101112n, m, k = map(int, input().split())e = []dist = [float(&#x27;inf&#x27;)] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) e.append((a, b, c))for _ in range(k): backup = dist.copy() for a, b, w in e: dist[b] = min(dist[b], backup[a] + w)print(dist[n] if dist[n] != float(&#x27;inf&#x27;) else &#x27;impossible&#x27;) spfa851. spfaæ±‚æœ€çŸ­è·¯ 123456789101112131415161718192021from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(&#x27;inf&#x27;)] * (n + 1)state = [False] * (n + 1)queue = deque([1])dist[1] = 0state[1] = Truefor _ in range(m): a, b, w = map(int, input().split()) adj_list[a].append((b, w))while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] &gt; dist[cur] + weight: dist[neighbor] = dist[cur] + weight if not state[neighbor]: queue.append(neighbor) state[neighbor] = Trueprint(dist[n] if dist[n] != float(&#x27;inf&#x27;) else &#x27;impossible&#x27;) 852. spfaåˆ¤æ–­è´Ÿç¯ 123456789101112131415161718192021222324from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist, cnt = [0] * (n + 1), [0] * (n + 1)state = [True] * (n + 1)queue = deque([i for i in range(1, n + 1)])for _ in range(m): a, b, c = map(int, input().split()) adj_list[a].append((b, c))def spfa(): while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] &gt; dist[cur] + weight: dist[neighbor] = dist[cur] + weight cnt[neighbor] = cnt[cur] + 1 if cnt[neighbor] &gt;= n: return True if not state[neighbor]: queue.append(neighbor) state[neighbor] = True return Falseprint(&#x27;Yes&#x27; if spfa() else &#x27;No&#x27;) Floyd854. Floydæ±‚æœ€çŸ­è·¯ 1234567891011121314n, m, q = map(int, input().split())g = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): g[i][i] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = min(g[i][j], g[i][k] + g[k][j])for _ in range(q): a, b = map(int, input().split()) print(g[a][b] if g[a][b] != float(&#x27;inf&#x27;) else &#x27;impossible&#x27;) Prim858. Primç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ 123456789101112131415161718192021n, m = map(int, input().split())g = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)]state = [False] * (n + 1)dist = [float(&#x27;inf&#x27;)] * (n + 1)for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c) g[b][a] = g[a][b]def prim(): res = 0 for i in range(n): t = min((j for j in range(1, n + 1) if not state[j]), key = lambda x: dist[x]) if i and dist[t] == float(&#x27;inf&#x27;): return &#x27;impossible&#x27; if i: res += dist[t] for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) state[t] = True return resprint(prim()) Krustal859. Kruskalç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ 12345678910111213141516171819n, m = map(int, input().split())e = []p = [i for i in range(n + 1)]res, cnt = 0, 0def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m):\ta, b, c = map(int, input().split())\te.append((a, b, c))e.sort(key=lambda x: x[2])for a, b, c in e: a, b = find(a), find(b) if a != b: p[a] = b res += c cnt += 1print(res if cnt == n - 1 else &#x27;impossible&#x27;) æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾860. æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾ dfsä¼šçˆ†æ ˆ 1234567891011121314151617181920212223n, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, c): color[u] = c for neighbor in adj_list[u]: if not color[neighbor]: if not dfs(neighbor, c * -1): return False elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not colort[i]: if not dfs(i, 1): print(&#x27;No&#x27;) breakelse: print(&#x27;Yes&#x27;) bfs 123456789101112131415161718192021222324252627from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def bfs(u): queue = deque() queue.append((u, 1)) while queue: node, c = queue.popleft() color[node] = c for neighbor in adj_list[node]: if not color[neighbor]: queue.append((neighbor, c * -1)) elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not color[i]: if not bfs(i): print(&#x27;No&#x27;) breakelse: print(&#x27;Yes&#x27;) åŒˆç‰™åˆ©ç®—æ³•861. äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é… 1234567891011121314151617181920n1, n2, m = map(int, input().split())n = max(n1, n2)adj_list = [[] for _ in range(n + 1)]match = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def find(u): for neighbor in adj_list[u]: if not state[neighbor]: state[neighbor] = True if not match[neighbor] or find(match[neighbor]): match[neighbor] = u return True return Falseres = 0for i in range(1, n1 + 1): state = [0] * (n + 1) if find(i): res += 1print(res) æ•°å­¦çŸ¥è¯†è´¨æ•°866. è¯•é™¤æ³•åˆ¤å®šè´¨æ•° 12345678910import mathn = int(input())def prime(x): if x &lt; 2: return False for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: return False return Truefor _ in range(n): x = int(input()) print(&#x27;Yes&#x27; if prime(x) else &#x27;No&#x27;) 867. åˆ†è§£è´¨å› æ•° 123456789101112131415import mathn = int(input())def divid(x): for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: s = 0 while x % i == 0: x //= i s += 1 print(i, s) if x &gt; 1: print(x, 1)for _ in range(n): x = int(input()) divid(x) print() 868. ç­›è´¨æ•° çº¿æ€§ç­›æ³•â€“æ¯ä¸ªåˆæ•°åªèƒ½è¢«è‡ªå·±çš„æœ€å°è´¨å› æ•°åˆ é™¤O(n) 12345678910111213n = int(input())state = [True] * (n + 1)res = []for i in range(2, n + 1): if state[i]: res.append(i) j = 0 while res[j] * i &lt;= n: state[res[j] * i] = False if i % res[j] == 0: break j += 1print(len(res)) åŸƒæ°ç­›æ³•O(n lognlogn) 123456789n = int(input())state = [True] * (n + 1)res = 0for i in range(2, n + 1): if state[i]: res += 1 for j in range(2 * i, n + 1, i): state[j] = Falseprint(res) çº¦æ•°869. è¯•é™¤æ³•æ±‚çº¦æ•° 1234567891011121314import mathn = int(input())def divisor(x): res = [] for i in range(1, int(math.sqrt(x) + 1)): if x % i == 0: res.append(i) if i * i != x: res.append(x // i) res.sort() print(&#x27; &#x27;.join(map(str, res)))for _ in range(n): a = int(input()) divisor(a) 870. çº¦æ•°ä¸ªæ•° $N &#x3D; p^{\\alpha1}{1} * p^{\\alpha2}{2} * \\cdots * p^{\\alpha k}_{k}$ çº¦æ•°ä¸ªæ•°$res &#x3D; (a_{1} + 1) (a_{2} + 1) \\cdots (a_{k} + 1)$ 1234567891011121314151617import mathn = int(input())dict = &#123;&#125;def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x &gt; 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for v in dict.values(): res = res * (v + 1) % (1e9 + 7)print(int(res)) 871. çº¦æ•°ä¹‹å’Œ çº¦æ•°ä¹‹å’Œ$res &#x3D; (p^{0}{1} + p^{1}{1} + \\cdots p^{a_{1}}{1}) * (p^{0}{2} + p^{1}{2} + \\cdots p^{a{2}}{2}) * \\cdots *(p^{0}{k} + p^{1}{k} + \\cdots p^{a{k}}_{k})$ 12345678910111213141516171819202122import mathn = int(input())dict = &#123;&#125;MOD = int(1e9 + 7)def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x &gt; 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for p, a in dict.items(): t = 1 while a: t = (t * p + 1) % MOD a -= 1 res = res * t % MODprint(res) 872. æœ€å¤§å…¬çº¦æ•° è¾—è½¬ç›¸é™¤æ³• 123456n = int(input())def gcd(a, b): return gcd(b, a % b) if b else afor _ in range(n): a, b = map(int, input().split()) print(gcd(a, b)) pythonè‡ªå¸¦ 12345import mathn = int(input())for _ in range(n): a, b = map(int, input().split()) print(math.gcd(a, b)) æ¬§æ‹‰å‡½æ•°873. æ¬§æ‹‰å‡½æ•° $\\varphi(1) &#x3D; 1$ å½“nä¸æ˜¯è´¨æ•°ï¼š$\\varphi(n) &#x3D; n * \\sum^{x}{i&#x3D;1}(1 - \\frac{1}{p{k}})$ å½“næ˜¯è´¨æ•°ï¼š$\\varphi(n) &#x3D; n - 1$ 123456789101112131415import mathn = int(input())def euler(x): res = x for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x &gt; 1: res *= (1 - 1 / x) print(int(res))for _ in range(n): x = int(input()) euler(x) 874. ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•° 1234567891011121314151617181920n = int(input())state = [False] * (n + 1)phi = [0] * (n + 1)phi[1] = 1primes = []def euler(x): for i in range(2, n + 1): if not state[i]: primes.append(i) phi[i] = i - 1 j = 0 while primes[j] * i &lt;= n: state[primes[j] * i] = True if i % primes[j] == 0: phi[primes[j] * i] = phi[i] * primes[j] break phi[primes[j] * i] = phi[i] * (primes[j] - 1) j += 1 print(sum(phi))euler(n) å¿«é€Ÿå¹‚875. å¿«é€Ÿå¹‚ è´¹é©¬å°å®šç†$a^{p - 1} \\equiv 1 \\ (mod \\enspace p)$ 123456789n = int(input())for _ in range(n): a, k, p = map(int, input().split()) res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p print(res) 876. å¿«é€Ÿå¹‚æ±‚é€†å…ƒ å½“nä¸ºè´¨æ•°æ—¶ï¼Œbçš„ä¹˜æ³•é€†å…ƒ$x &#x3D; b^{(n - 2)}$ å½“nä¸æ˜¯è´¨æ•°æ—¶ï¼Œä½¿ç”¨æ‹“å±•æ¬§å‡ é‡Œå¾—æ±‚é€†å…ƒ $a * x \\equiv 1 \\ (mod \\ p)$ 1234567891011n = int(input())def quick_mi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resfor _ in range(n): a, p = map(int, input().split()) print(quick_mi(a, p - 2, p) if a % p else &#x27;impossible&#x27;) æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•877. æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³• æ±‚è§£$ax + by &#x3D; gcd(a, b)$ å½“b&#x3D;0æ—¶ $ax+by&#x3D;a$ æ•…è€Œ $x&#x3D;1, y&#x3D;0$ å½“$b eq 0$æ—¶$x &#x3D; y \\prime, \\quad y &#x3D; x \\prime - \\lfloor\\frac{a}{b}\\rfloor * y \\prime$ 12345678910n = int(input())def exgcd(a, b): if not b: return 1, 0 y, x = exgcd(b, a % b) y -= a // b * x return x, yfor _ in range(n): a, b = map(int, input().split()) print(*exgcd(a, b)) 878. çº¿æ€§åŒä½™æ–¹ç¨‹ å½“$gcd(a,m) \\mid b$æœ‰è§£ï¼Œæ±‚å‡ºä»¥ä¸€ç»„è§£ä½¿å¾—$a * x_{0} + m * y_{0} &#x3D; gcd(a,m)$ï¼Œ æ‰€ä»¥$x &#x3D; x_{0} * \\frac{b}{gcd(a,m)} % m$ 1234567891011n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(n): a, b, m = map(int, input().split()) d, x, _ = exgcd(a, m) print(&#x27;impossible&#x27; if b % d else x * b // d % m) ä¸­å›½å‰©ä½™å®šç†$M&#x3D;m_{1} \\cdot m_{2} \\cdot \\cdots \\cdot m_{R}, \\quad M_{i} &#x3D; \\frac{M}{m_{i}}$, $M^{-1}{i}$è¡¨ç¤º$M_i$æ¨¡$m{i}$çš„é€†ï¼Œå³$M_i \\cdot m^{-1}{i} \\equiv 1 \\ (mod \\ m{i})$ $x &#x3D; a_1 \\cdot M_1 \\cdot M^{-1}{1} + a_2 \\cdot M_2 \\cdot M^{-1}{2} + \\cdots + a_k \\cdot M_k \\cdot M^{-1}_{k}$ 204. è¡¨è¾¾æ•´æ•°çš„å¥‡æ€ªæ–¹å¼ æ³¨ $m_1,m_2 \\cdots m_k$ ä¸ä¸¤ä¸¤äº’è´¨ 1234567891011121314151617181920n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ya1, m1 = map(int, input().split())for _ in range(n - 1): a2, m2 = map(int, input().split()) d, k1, _ = exgcd(a1, a2) if (m2 - m1) % d: print(-1) break k1 *= (m2 - m1) // d k1 %= a2 // d m1 += a1 * k1 a1 = a1 * a2 // delse: print(m1 % a1) é«˜æ–¯æ¶ˆå…ƒ883. é«˜æ–¯æ¶ˆå…ƒè§£çº¿æ€§æ–¹ç¨‹ç»„ 1234567891011121314151617181920212223242526272829n = int(input())g = [list(map(float, input().split())) for _ in range(n)]def gauss(): idx, zero = 0, 1e-6 for c in range(n): t = max(range(c, n), key=lambda x: abs(g[x][c])) if abs(g[t][c]) &lt; zero: continue g[idx][c:], g[t][c:] = g[t][c:], g[idx][c:] for i in range(n, c, -1): g[idx][i] /= g[idx][c] for i in range(idx + 1, n): if abs(g[i][c]) &gt; zero: for j in range(n, c - 1, -1): g[i][j] -= g[idx][j] * g[i][c] idx += 1 if idx &lt; n: for i in range(idx, n): if abs(g[i][n]) &gt; zero: print(&#x27;No solution&#x27;) return print(&#x27;Infinite group solutions&#x27;) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] -= g[i][j] * g[j][n] for i in range(n): print(f&#x27;&#123;g[i][n]:.2f&#125;&#x27;)gauss() 884. é«˜æ–¯æ¶ˆå…ƒè§£å¼‚æˆ–çº¿æ€§æ–¹ç¨‹ç»„ 12345678910111213141516171819202122232425262728293031n = int(input())g = [list(map(int, input().split())) for _ in range(n)]def gauss(): idx = 0 for c in range(n): t = idx for i in range(idx, n): if g[i][c]: t = i break if not g[t][c]: continue g[t][c:], g[idx][c:] = g[idx][c:], g[t][c:] for i in range(idx + 1, n): if g[i][c]: for j in range(c, n + 1): g[i][j] ^= g[idx][j] idx += 1 if idx &lt; n: for i in range(idx, n): if g[i][n]: print(&#x27;No solution&#x27;) return print(&#x27;Multiple sets of solutions&#x27;) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] ^= g[i][j] &amp; g[j][n] for i in range(n): print(g[i][n])gauss() æ±‚ç»„åˆæ•°885. æ±‚ç»„åˆæ•° I $C^{b}{a} &#x3D; C^{b - 1}{a - 1} + C^{b}_{a - 1}$ 123456789n = int(input())N, MOD = 2010, int(1e9+7)g = [[1] + [0] * N for _ in range(N)]for i in range(N): for j in range(i + 1): g[i][j] = (g[i - 1][j] + g[i - 1][j - 1]) % MODfor _ in range(n): a, b = map(int, input().split()) print(g[a][b]) 886. æ±‚ç»„åˆæ•° II æ³¨ $\\frac{a}{b} \\enspace mod \\enspace p eq \\frac{a \\enspace mod \\enspace p}{b \\enspace mod \\enspace p}$ å¯ä»¥ç”¨é€†å…ƒè®¡ç®— $\\frac{a}{b} \\enspace mod \\enspace p &#x3D; a \\times b^{-1} \\enspace mod \\enspace p$ $C^{b}_{a} &#x3D; \\frac{a!}{b! * (a - b)!} &#x3D; a! * infact(b!) * infact((a - b)!)$ 1234567891011121314151617n = int(input())N, MOD = 100010, int(1e9 + 7)fact, infact = [1] * N, [1] * Ndef qmi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resfor i in range(1, N): fact[i] = fact[i - 1] * i % MOD infact[i] = infact[i - 1] * qmi(i, MOD - 2, MOD) % MODfor _ in range(n): a, b = map(int, input().split()) print(fact[a] * infact[b] * infact[a - b] % MOD) 887. æ±‚ç»„åˆæ•° III å¢å¡æ–¯å®šç† Lucas $O(logpNplogp)$ $C^{b}{a} \\equiv C^{\\frac{b}{p}}{\\frac{a}{p}} C^{b \\ mod \\ p}_{a \\ mod \\ p} \\ (mod \\ p)$ 1234567891011121314151617181920212223242526n = int(input())def qmi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resdef C(a, b): res = 1 i, j = 1, a while i &lt;= b: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1 return resdef lucas(a, b, p): if a &lt; p and b &lt; p: return C(a, b) else: return C(a % p, b % p) * lucas(a // p, b // p, p) % pfor _ in range(n): a, b, p = map(int, input().split()) print(lucas(a, b, p)) 888. æ±‚ç»„åˆæ•° IV 123import matha, b = map(int, input().split())print(math.factorial(a) // math.factorial(b) // math.factorial(a - b)) 889. æ»¡è¶³æ¡ä»¶çš„01åºåˆ— å¡ç‰¹å…°æ•° $ans &#x3D; C^{n}{2n} - C^{n - 1}{2n} &#x3D; \\frac{C^{n}_{2n}}{n + 1}$ 123456789101112131415161718n = int(input())p = int(1e9 + 7)def qmi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resres = 1i, j = 1, 2 * nwhile i &lt;= n: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1print(res * qmi(n + 1, p - 2, p) % p) ä½¿ç”¨å…¬å¼+pythonç¡¬è§£(å¾ˆæ…¢ï¼‰ 123import mathn = int(input())print(math.factorial(2 * n) // (math.factorial(n) ** 2 * (n + 1)) % int(1e9 + 7)) å®¹æ–¥åŸç†$$\\bigcup_{i&#x3D;1}^{m} S_{i}&#x3D;S_{1}+S_{2}+\\cdots+S_{m}-(S_{1} \\bigcap S_{2}+S_{1} \\bigcap S_{3}+\\ldots+S_{m-1} \\bigcap S_{m})+(S_{1} \\bigcap S_{2} \\bigcap S_{3}+\\ldots+S_{m-2} \\bigcap S_{m-1} \\bigcap S_{m})+\\ldots+(-1)^{m-1}(\\bigcap_{i&#x3D;1}^{m} S)$$ 890. èƒ½è¢«æ•´é™¤çš„æ•° 123456789101112131415n, m = map(int, input().split())p = list(map(int, input().split()))res = 0for i in range(1, 1 &lt;&lt; m): t, s = 1, 0 for j in range(m): if i &gt;&gt; j &amp; 1: if t * p[j] &gt; n: break t *= p[j] s += 1 else: if s &amp; 1: res += n // t else: res -= n // tprint(res) åšå¼ˆè®º891. Nimæ¸¸æˆ mex(S)ä¸ºæ±‚å‡ºä¸å±äºé›†åˆSçš„æœ€å°éè´Ÿæ•´æ•° 123456n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(1, n): res ^= nums[i]print(&#x27;Yes&#x27; if res else &#x27;No&#x27;) 892. å°é˜¶-Nimæ¸¸æˆ 123456n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(2, n, 2): res ^= nums[i]print(&#x27;Yes&#x27; if res else &#x27;No&#x27;) 893. é›†åˆ-Nimæ¸¸æˆ $SG(x)&#x3D;mex({SG(y_{1}),SG(y_{2})Â·Â·Â·Â·SG(y_{k})})$ $SG(G)&#x3D;SG(G_{1})\\oplus SG(G_{2}) \\oplus \\cdots \\oplus SG(G_{m})$ 1234567891011121314151617181920k = int(input())s = list(map(int, input().split()))n = int(input())nums = list(map(int, input().split()))f = [-1] * 10010def sg(x): if f[x] != -1: return f[x] S = &#123;sg(x - i) for i in s if x &gt;= i&#125; i = 0 while i in S: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(&#x27;Yes&#x27; if nim(n, nums) else &#x27;No&#x27;) 894. æ‹†åˆ†-Nimæ¸¸æˆ 123456789101112131415161718192021n = int(input())nums = list(map(int, input().split()))f = [-1] * 101def sg(x): if f[x] != -1: return f[x] s = set() for i in range(x): for j in range(i + 1): s.add(sg(i) ^ sg(j)) i = 0 while i in s: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(&#x27;Yes&#x27; if nim(n, nums) else &#x27;No&#x27;) åŠ¨æ€è§„åˆ’èƒŒåŒ…é—®é¢˜2. 01èƒŒåŒ…é—®é¢˜ äºŒç»´dp 12345678910111213n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j &gt;= v[i]: f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])print(f[n][m]) ä¸€ç»´dp 1234567891011n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 3. å®Œå…¨èƒŒåŒ…é—®é¢˜ äºŒç»´dp 12345678910111213n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j &gt;= v[i]: f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])print(f[n][m]) ä¸€ç»´dp 123456789101112n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): if j &gt;= v[i]: f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 4. å¤šé‡èƒŒåŒ…é—®é¢˜ I 12345678910111213141516n, m = map(int, input().split())v, w, s = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b, c = map(int, input().split()) v[i] = a w[i] = b s[i] = cfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] k = 0 while k &lt;= s[i] and j &gt;= k * v[i]: f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) k += 1print(f[n][m]) 5. å¤šé‡èƒŒåŒ…é—®é¢˜ II 123456789101112131415161718192021n, m = map(int, input().split())N = 20010v, w, f = [0] * (N + 1), [0] * (N + 1), [0] * (N + 1)idx = 1for _ in range(n): a, b, c = map(int, input().split()) k = 1 while k &lt; c: v[idx] = a * k w[idx] = b * k c -= k k *= 2 idx += 1 if c: v[idx] = a * c w[idx] = b * c idx += 1for i in range(1, idx): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 9. åˆ†ç»„èƒŒåŒ…é—®é¢˜ 123456789101112131415n, m = map(int, input().split())N = 101v = [[0] * N for _ in range(N)]w = [[0] * N for _ in range(N)]s, f = [0] * N, [0] * Nfor i in range(1, n + 1): s[i] = int(input()) for j in range(1, s[i] + 1): v[i][j], w[i][j] = map(int, input().split())for i in range(1, n + 1): for j in range(m, 0, -1): for k in range(1, s[i] + 1): if j &gt;= v[i][k]: f[j] = max(f[j], f[j - v[i][k]] + w[i][k])print(f[m]) çº¿æ€§DP898. æ•°å­—ä¸‰è§’å½¢ 1234567891011n = int(input())INF = -1e9a = [[INF] * (n + 1) for _ in range(n + 1)]f = [[INF] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): a[i] = [INF] + list(map(int, input().split()))f[1][1] = a[1][1]for i in range(2, n + 1): for j in range(1, i + 1): f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]print(max(f[n])) 895. æœ€é•¿ä¸Šå‡å­åºåˆ— 12345678n = int(input())a = [0] + list(map(int, input().split()))f = [1] * (n + 1)for i in range(1, n + 1): for j in range(1, i): if a[i] &gt; a[j]: f[i] = max(f[i], f[j] + 1)print(max(f)) 897. æœ€é•¿å…¬å…±å­åºåˆ— 123456789n, m = map(int, input().split())a, b = &#x27; &#x27; + input(), &#x27; &#x27; + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = max(f[i - 1][j], f[i][j - 1]) if a[i] == b[j]: f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)print(f[n][m]) 902. æœ€çŸ­ç¼–è¾‘è·ç¦» 12345678910111213141516n = int(input())a = &#x27; &#x27; + input()m = int(input())b = &#x27; &#x27; + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): f[i][0] = ifor i in range(1, m + 1): f[0][i] = ifor i in range(1, n + 1): for j in range(1, m + 1): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1print(f[n][m]) 899. ç¼–è¾‘è·ç¦» 123456789101112131415161718192021222324252627n, m = map(int, input().split())N = 11a = [[0] * N for _ in range(n + 1)]f = [[0] * N for _ in range(N)]for i in range(n): a[i] = &#x27; &#x27; + input()def distance(a, b): la, lb = len(a), len(b) for i in range(1, la): f[i][0] = i for i in range(1, lb): f[0][i] = i for i in range(1, la): for j in range(1, lb): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1 return f[la - 1][lb - 1]for _ in range(m): b, limit = input().split() b, limit = &#x27; &#x27; + b, int(limit) res = 0 for i in range(n): if distance(a[i], b) &lt;= limit: res += 1 print(res) 896. æœ€é•¿ä¸Šå‡å­åºåˆ— II 123456789101112131415n = int(input())a = list(map(int, input().split()))q = [0] * (n + 1)res = 0for i in range(n): l, r = 0, res while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if q[mid] &lt; a[i]: l = mid else: r = mid - 1 q[r + 1] = a[i] res = max(res, r + 1)print(res) åŒºé—´DP282. çŸ³å­åˆå¹¶ 123456789101112n = int(input())s = [0] + list(map(int, input().split()))f = [[0] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): s[i] += s[i - 1]for length in range(2, n + 1): for i in range(1, n - length + 2): l, r = i, i + length - 1 f[l][r] = float(&#x27;inf&#x27;) for k in range(l, r): f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1])print(f[1][n]) è®¡æ•°ç±»DP900. æ•´æ•°åˆ’åˆ† 12345678n = int(input())MOD = int(1e9 + 7)f = [0] * (n + 1)f[0] = 1for i in range(1, n + 1): for j in range(i, n + 1): f[j] = (f[j] + f[j - i]) % MODprint(f[n]) æ•°ä½ç»Ÿè®¡DP338. è®¡æ•°é—®é¢˜ 12345678910111213141516171819202122232425262728293031323334def power10(x): res = 1 while x: res *= 10 x -= 1 return resdef count(n, x): res = cnt = 0 m = n while m: cnt += 1 m //= 10 for i in range(1, cnt + 1): r = power10(i - 1) l = n // (r * 10) if x: res += l * r else: res += (l - 1) * r d = n // r % 10 if d == x: res += n % r + 1 elif d &gt; x: res += r return reswhile True: a, b = map(int, input().split()) if not a and not b: break if a &gt; b: a, b = b, a for i in range(10): print(count(b, i) - count(a - 1, i), end=&#x27; &#x27;) print() çŠ¶æ€å‹ç¼©DP291. è’™å¾·é‡Œå®‰çš„æ¢¦æƒ³ 1234567891011121314151617181920212223def fun(n, m): f = [[0] * (1 &lt;&lt; 12) for _ in range(12)] st = [False] * (1 &lt;&lt; 12) for i in range(1 &lt;&lt; n): cnt = 0 st[i] = True for j in range(n): if i &gt;&gt; j &amp; 1: if cnt &amp; 1: st[i] = False cnt = 0 else: cnt += 1 if cnt &amp; 1: st[i] = False f[0][0] = 1 for i in range(1, m + 1): for j in range(1 &lt;&lt; n): for k in range(1 &lt;&lt; n): if not (j &amp; k) and st[j | k]: f[i][j] += f[i - 1][k] return f[m][0]while True: a, b = map(int, input().split()) if not a and not b: break print(fun(a, b)) 91. æœ€çŸ­Hamiltonè·¯å¾„ 1234567891011n = int(input())g = [list(map(int, input().split())) for _ in range(n)]f = [[float(&#x27;inf&#x27;)] * n for _ in range(1 &lt;&lt; n)]f[1][0] = 0for i in range(1 &lt;&lt; n): for j in range(n): if i &gt;&gt; j &amp; 1: for k in range(n): if i &gt;&gt; k &amp; 1: f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + g[k][j])print(f[i - (1 &lt;&lt; n)][n - 1]) æ ‘å½¢DP285. æ²¡æœ‰ä¸Šå¸çš„èˆä¼š 123456789101112131415161718192021222324import syssys.setrecursionlimit(3000)n = int(input())f = [[0] * 2 for _ in range(n + 1)]parent = [False] * (n + 1)happy = [0] * (n + 1)adj_list = [[] for _ in range(n + 1)]for i in range(1, n + 1): happy[i] = int(input())for _ in range(n - 1): a, b = map(int, input().split()) parent[a] = True adj_list[b].append(a)root = 1while parent[root]: root += 1def dfs(u): f[u][1] = happy[u] for j in adj_list[u]: dfs(j) f[u][0] += max(f[j][1], f[j][0]) f[u][1] += f[j][0]dfs(root)print(max(f[root][0], f[root][1])) è®°å¿†åŒ–æœç´¢901. æ»‘é›ª 123456789101112131415161718n, m = map(int, input().split())f = [[0] * m for _ in range(n)]g = [list(map(int, input().split())) for _ in range(n)]dircts = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dp(x, y): if f[x][y]: return f[x][y] f[x][y] = 1 for l, r in dircts: a, b = x + l, b + r if 0 &lt;= a &lt; n and 0 &lt;= b &lt; m and g[a][b] &lt; g[x][y]: f[x][y] = max(f[x][y], dp(a, b) + 1) return f[x][y]res = 0for i in range(n): for j in range(m): res = max(res, dp(i, j))print(res) è´ªå¿ƒåŒºé—´é—®é¢˜905. åŒºé—´é€‰ç‚¹ 123456789n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x:x[1])res, end = 0, float(&#x27;-inf&#x27;)for a, b in g: if a &gt; end: res += 1 end = bprint(res) 908. æœ€å¤§ä¸ç›¸äº¤åŒºé—´æ•°é‡ 123456789n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[1])res, end = 0, float(&#x27;-inf&#x27;)for a, b in g: if a &gt; end: res += 1 end = bprint(res) 906. åŒºé—´åˆ†ç»„ 12345678910import heapqn = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()res = []for a, b in g: if res and a &gt; res[0]: heapq.heappop(res) heapq.heappush(res, b)print(len(res)) 907. åŒºé—´è¦†ç›– 12345678910111213141516171819s, t = map(int, input().split())n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()idx = res = 0flag = Falsewhile idx &lt; n: r = float(&#x27;-inf&#x27;) while idx &lt; n and g[idx][0] &lt;= s: r = max(r, g[idx][1]) idx += 1 if r &lt; s: break s = r res += 1 if r &gt;= t: flag = True breakprint(res if flag else &#x27;-1&#x27;) Huffmanæ ‘148. åˆå¹¶æœå­ 12345678910import heapqn = int(input())nums = list(map(int, input().split()))heapq.heapify(nums)res = 0while len(nums) &gt; 1: a, b = heapq.heappop(nums), heapq.heappop(nums) res += a + b heapq.heappush(nums, a + b)print(res) æ’åºä¸ç­‰å¼913. æ’é˜Ÿæ‰“æ°´ 1234567n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for i, num in enumerate(nums): res += num * (n - i - 1)print(res) ç»å¯¹å€¼ä¸ç­‰å¼104. è´§ä»“é€‰å€ 1234567n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for num in nums: res += abs(num - nums[n // 2])print(res) æ¨å…¬å¼125. è€æ‚æŠ€çš„ç‰› 12345678n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[0] + x[1])res, pre_sum = float(&#x27;-inf&#x27;), 0for w, s in g: res = max(res, pre_sum - s) pre_sum += wprint(res) Pythonæ³¨æ„å®¹æ˜“çˆ†æ ˆ12import sys sys.setrecursionlimit(100000) â€‹ pythonè¯­è¨€å¹¶ä¸é€‚åˆé€’å½’ç®—æ³•ï¼Œå› ä¸ºå…¶é€’å½’æ·±åº¦ï¼Œè¯­è¨€è‡ªèº«å°±æœ‰é™åˆ¶ï¼Œå°±ç®—å»é™¤é™åˆ¶ï¼Œå…¶ä¹Ÿä¼šå¼€è¾Ÿå¤§é‡ç©ºé—´ äº¤æ¢strä¸¤ä¸ªå­—ç¬¦çš„ä½ç½®123def swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 &lt; idx2 else (idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:] å¢å¼ºå‡½æ•°è®°å¿†åŠ›123import functools#lru_cacheï¼Œå¯ä»¥ä¸ºå‡½æ•°è‡ªåŠ¨å¢åŠ è®°å¿†åŒ–çš„èƒ½åŠ›ï¼Œåœ¨é€’å½’ç®—æ³•ä¸­éå¸¸å®ç”¨@functools.lru_cache() ç§‘å­¦è®¡æ•°æ³•è¦ç”¨int12# é»˜è®¤çš„ç§‘å­¦è®¡æ•°æ³•æ˜¯å°æ•°è¡¨ç¤ºMOD = int(1e9 + 7) å–æ¨¡%è¿ç®—c++ä¸­ 1234cout&lt;&lt; 7 % 4 &lt;&lt; endl; // 3cout&lt;&lt; -7 % 4 &lt;&lt; endl; // -3cout&lt;&lt; 7 % -4 &lt;&lt; endl; // 3cout&lt;&lt; -7 % -4 &lt;&lt; endl; // -3 pythonä¸­ 1234print(7 % 4) // 3print(-7 % 4) // 1print(7 % -4) // -1print(-7 % -4) // -3 C è¯­è¨€å’Œ Python åœ¨æ¶‰åŠæœ‰è´Ÿæ•°å–ä½™è¿ç®—æ—¶ï¼Œç»“æœå¯èƒ½ä¸åŒçš„æœ¬è´¨åŸå› æ˜¯ï¼šC è¯­è¨€ä¸­æ˜¯å‘0å–æ•´ï¼Œè€Œ Python æ˜¯å‘è´Ÿæ— ç©·å–æ•´ã€‚ è¾“å…¥123from sys import stdininput = lambda: stdin.readline().strip()n, m = map(int, input().split()) å¸¸ç”¨å‡½æ•°123import mathmath.factorial(x)math.gcd(a, b) äºŒåˆ†äºŒåˆ†æ‰¾å·¦è¾¹ç•Œl=mid+1,æ‰¾å³è¾¹ç•Œr=mid-1ï¼Œå¹¶ä¸”mid=l+r+1&gt;&gt;1","tags":["ç®—æ³•","Python","AcWing"],"categories":["ç®—æ³•"]},{"title":"labuladongç®—æ³•å°æŠ„","path":"/2023/05/17/labuladongç®—æ³•å°æŠ„/","content":"ç¬¬é›¶ç«  æ ¸å¿ƒæ¡†æ¶åŒæŒ‡é’ˆ-&gt;å•é“¾è¡¨ åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ LeetCode21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ é“¾è¡¨çš„åˆ†è§£ LeetCode86 åˆ†å‰²é“¾è¡¨ åˆå¹¶kä¸ªæœ‰åºé“¾è¡¨ LeetCode23 åˆå¹¶kä¸ªå‡åºé“¾è¡¨ å¯»æ‰¾å•é“¾è¡¨çš„å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ LeetCode19 åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ å¯»æ‰¾å•é“¾è¡¨çš„ä¸­ç‚¹ LeetCode976 é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦åŒ…å«ç¯å¹¶æ‰¾å‡ºç¯èµ·ç‚¹ åˆ¤æ–­ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦ç›¸äº¤å¹¶æ‰¾å‡ºäº¤ç‚¹ LeetCode160 ç›¸äº¤é“¾è¡¨ åŒæŒ‡é’ˆ-&gt;æ•°ç»„å¿«æ…¢æŒ‡é’ˆ åŸåœ°ä¿®æ”¹æ•°ç»„ LeetCode26 åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ å¯¹æ•°ç»„æŸäº›å…ƒç´ è¿›è¡ŒåŸåœ°åˆ é™¤ LeetCode27 ç§»é™¤å…ƒç´  LeetCode283 ç§»åŠ¨é›¶ å·¦å³æŒ‡é’ˆ äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾æ¡†æ¶ ä¸¤æ•°ä¹‹å’Œ LeetCode167 ä¸¤æ•°ä¹‹å’Œ2 åè½¬æ•°ç»„ LeetCode344 åè½¬å­—ç¬¦ä¸² å›æ–‡ä¸²åˆ¤æ–­ LeetCode5 æœ€é•¿å›æ–‡å­ä¸² äºŒå‰æ ‘(çº²è¦ç¯‡)Tips:å¿«é€Ÿæ’åºå°±æ˜¯äºŒå‰æ ‘çš„å‰åºéå†,å½’å¹¶æ’åºæ˜¯äºŒå‰æ ‘çš„ååºéå† å¿«é€Ÿæ’åºæ¡†æ¶: 1234567def sort(nums, lo, hi)&#123; # å‰åºéå†ä½ç½® # é€šè¿‡äº¤æ¢å…ƒç´ æ„å»ºåˆ†ç•Œç‚¹ p p = partition(nums, lo, hi) sort(nums, lo, p-1) sort(nums, p+1, hi)&#125; å½’å¹¶æ’åºæ¡†æ¶: 123456789def sort(nums, lo, hi)&#123;\tint mid = (lo + hi) / 2\t# æ’åºnums[lo..mid]\tsort(nums, lo, mid)\t# æ’åºnums[mid+1..hi]\tsort(nums, mid+1, hi)\t# åˆå¹¶nums[lo..mid] å’Œ nums[mid+1..hi]\tmerge(nums, lo, mid, hi)&#125; äºŒå‰æ ‘éå†æ¡†æ¶:12345678def traverse(root)&#123;\tif not root: return\t# å‰åºä½ç½®\ttraverse(root.left)\t# ä¸­åºä½ç½®\ttraverse(root.right)\t# ååºä½ç½®&#125; å‰åºä½ç½®çš„ä»£ç åªèƒ½ä»å‡½æ•°å‚æ•°ä¸­è·å–çˆ¶èŠ‚ç‚¹ä¼ é€’æ¥çš„æ•°æ®ï¼Œè€Œååºä½ç½®çš„ä»£ç ä¸ä»…å¯ä»¥è·å–å‚æ•°æ•°æ®ï¼Œè¿˜å¯ä»¥è·å–åˆ°å­æ ‘é€šè¿‡å‡½æ•°è¿”å›å€¼ä¼ é€’å›æ¥çš„æ•°æ® ä¸¤ç§è§£é¢˜æ€è·¯: éå†ä¸€éäºŒå‰æ ‘å¾—å‡ºç­”æ¡ˆ å›æº¯ç®—æ³•æ¡†æ¶ LeetCode104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ åˆ†è§£é—®é¢˜è®¡ç®—å‡ºç­”æ¡ˆ åŠ¨æ€è§„åˆ’æ ¸å¿ƒæ¡†æ¶ ååºä½ç½®çš„ç‰¹æ®Šä¹‹å¤„:â€‹ LeetCode543 äºŒå‰æ ‘çš„ç›´å¾„ å±‚åºéå†:123456789101112131415def levelTraverse(root)&#123;\tif not root: return\tque = deque()\tque.append(root) # ä»ä¸Šåˆ°ä¸‹éå†äºŒå‰æ ‘çš„æ¯ä¸€å±‚\twhile que: # ä»å·¦åˆ°å³éå†æ¯ä¸€å±‚çš„æ¯ä¸ªç»“ç‚¹ for i in range(len(que)): cur = que.popleft() # å°†ä¸‹ä¸€å±‚ç»“ç‚¹æ”¾å…¥é˜Ÿåˆ— if cur.left: que.append(cur.left) if cur.right: que.append(cur.right)&#125; â€‹ BFSç®—æ³•æ¡†æ¶ åŠ¨æ€è§„åˆ’(æ¡†æ¶)åŠ¨æ€è§„åˆ’æ¡†æ¶:1234567891011121314# è‡ªé¡¶å‘ä¸‹é€’å½’çš„åŠ¨æ€è§„åˆ’def dp(çŠ¶æ€1, çŠ¶æ€2, ...):\tfor é€‰æ‹© in æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©: # æ­¤æ—¶çš„çŠ¶æ€å·²ç»å› ä¸ºåšäº†é€‰æ‹©è€Œæ”¹å˜ result = æ±‚æœ€å€¼(result, dp(çŠ¶æ€1, çŠ¶æ€2, ...))\treturn result# è‡ªåº•å‘ä¸Šè¿­ä»£çš„åŠ¨æ€è§„åˆ’# åˆå§‹åŒ– base casedp[0][0][...] = base case# è¿›è¡ŒçŠ¶æ€è½¬ç§»for çŠ¶æ€1 in çŠ¶æ€1çš„æ‰€æœ‰å–å€¼: for çŠ¶æ€2 in çŠ¶æ€2çš„æ‰€æœ‰å–å€¼: for ... dp[çŠ¶æ€1][çŠ¶æ€2][...] = æ±‚æœ€å€¼(é€‰æ‹©1, é€‰æ‹©2...) è§£é¢˜æ€è·¯:æš´åŠ›ç©·ä¸¾,å¸¦å¤‡å¿˜å½•çš„é€’å½’å’Œdpæ•°ç»„çš„è¿­ä»£(å¯é™ç©ºé—´å¤æ‚åº¦ä¸ºO(1)) æ–æ³¢é‚£å¥‘æ•°åˆ— LeetCode509 æ–æ³¢é‚£å¥‘æ•°åˆ— å‡‘é›¶é’± LeetCode322 é›¶é’±å…‘æ¢ æ€»ç»“è®¡ç®—æœºè§£å†³é—®é¢˜å…¶å®æ²¡æœ‰ä»»ä½•å¥‡æŠ€æ·«å·§ï¼Œå®ƒå”¯ä¸€çš„è§£å†³åŠæ³•å°±æ˜¯ç©·ä¸¾ï¼Œ ç©·ä¸¾æ‰€æœ‰å¯èƒ½æ€§ã€‚ç®—æ³•è®¾è®¡æ— éå°±æ˜¯å…ˆæ€è€ƒâ€œå¦‚ä½•ç©·ä¸¾â€ï¼Œç„¶åå†è¿½æ±‚â€œå¦‚ä½•èªæ˜åœ°ç©·ä¸¾â€ã€‚ åˆ—å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå°±æ˜¯åœ¨è§£å†³â€œå¦‚ä½•ç©·ä¸¾â€çš„é—®é¢˜ã€‚ä¹‹æ‰€ä»¥è¯´å®ƒéš¾ï¼Œä¸€æ˜¯å› ä¸ºå¾ˆå¤šç©·ä¸¾éœ€è¦é€’å½’å®ç°ï¼ŒäºŒæ˜¯å› ä¸ºæœ‰çš„é—®é¢˜æœ¬èº«çš„è§£ç©ºé—´å¤æ‚ï¼Œä¸é‚£ä¹ˆå®¹æ˜“ç©·ä¸¾å®Œæ•´ã€‚ å¤‡å¿˜å½•ã€DP table å°±æ˜¯åœ¨è¿½æ±‚â€œå¦‚ä½•èªæ˜åœ°ç©·ä¸¾â€ã€‚ç”¨ç©ºé—´æ¢æ—¶é—´çš„æ€è·¯ï¼Œæ˜¯é™ä½æ—¶é—´å¤æ‚åº¦çš„ä¸äºŒæ³•é—¨ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¯•é—®ï¼Œè¿˜èƒ½ç©å‡ºå•¥èŠ±æ´»ï¼Ÿ å›æº¯ç®—æ³•(æ¡†æ¶)Tips:å›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„ç»†å¾®å·®åˆ«æ˜¯ï¼šå›æº¯ç®—æ³•æ˜¯åœ¨éå†ã€Œæ ‘æã€ï¼ŒDFS ç®—æ³•æ˜¯åœ¨éå†ã€ŒèŠ‚ç‚¹ã€ å›æº¯ç®—æ³•æ¡†æ¶123456789res = []def backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨):\tif æ»¡è¶³ç»“æŸæ¡ä»¶: res.add(è·¯å¾„) return\tfor é€‰æ‹© in é€‰æ‹©åˆ—è¡¨: åšé€‰æ‹© backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨) æ’¤é”€xrz å…¶æ ¸å¿ƒå°±æ˜¯ for å¾ªç¯é‡Œé¢çš„é€’å½’ï¼Œåœ¨é€’å½’è°ƒç”¨ä¹‹å‰ã€Œåšé€‰æ‹©ã€ï¼Œåœ¨é€’å½’è°ƒç”¨ä¹‹åã€Œæ’¤é”€é€‰æ‹©ã€ å…¨æ’åˆ—é—®é¢˜ LeetCode46 å…¨æ’åˆ— å…¨æ’åˆ—è¯¦è§£ Nçš‡åé—®é¢˜ LeetCode51 Nçš‡å æ€»ç»“ æ—¶é—´å¤æ‚åº¦éƒ½ä¸å¯èƒ½ä½äº O(N!)ï¼Œå› ä¸ºç©·ä¸¾æ•´æ£µå†³ç­–æ ‘æ˜¯æ— æ³•é¿å…çš„ã€‚è¿™ä¹Ÿæ˜¯å›æº¯ç®—æ³•çš„ä¸€ä¸ªç‰¹ç‚¹ï¼Œä¸åƒåŠ¨æ€è§„åˆ’å­˜åœ¨é‡å å­é—®é¢˜å¯ä»¥ä¼˜åŒ–ï¼Œå›æº¯ç®—æ³•å°±æ˜¯çº¯æš´åŠ›ç©·ä¸¾ï¼Œå¤æ‚åº¦ä¸€èˆ¬éƒ½å¾ˆé«˜ã€‚ å†™ backtrack å‡½æ•°æ—¶ï¼Œéœ€è¦ç»´æŠ¤èµ°è¿‡çš„ã€Œè·¯å¾„ã€å’Œå½“å‰å¯ä»¥åšçš„ã€Œé€‰æ‹©åˆ—è¡¨ã€ï¼Œå½“è§¦å‘ã€Œç»“æŸæ¡ä»¶ã€æ—¶ï¼Œå°†ã€Œè·¯å¾„ã€è®°å…¥ç»“æœé›†ã€‚ å›æº¯-&gt;æ’åˆ—,ç»„åˆ,å­é›†æ— è®ºæ˜¯æ’åˆ—ã€ç»„åˆè¿˜æ˜¯å­é›†é—®é¢˜ï¼Œç®€å•è¯´æ— éå°±æ˜¯è®©ä½ ä»åºåˆ— nums ä¸­ä»¥ç»™å®šè§„åˆ™å–è‹¥å¹²å…ƒç´ ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§å˜ä½“ï¼š å…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å½¢å¼ã€‚ â€‹ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥åªæœ‰ [7]ã€‚ å…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ å¯ä»¥å­˜åœ¨é‡å¤ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚ â€‹ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,5,2,1,2]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,2,1] å’Œ [5,2]ã€‚ å…ƒç´ æ— é‡å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«ä½¿ç”¨è‹¥å¹²æ¬¡ã€‚ â€‹ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,3] å’Œ [7]ã€‚ â€‹\tä½†æ— è®ºå½¢å¼æ€ä¹ˆå˜åŒ–ï¼Œå…¶æœ¬è´¨å°±æ˜¯ç©·ä¸¾æ‰€æœ‰è§£ï¼Œè€Œè¿™äº›è§£å‘ˆç°æ ‘å½¢ç»“æ„ï¼Œæ‰€ä»¥åˆç†ä½¿ç”¨å›æº¯ç®—æ³•æ¡†æ¶ï¼Œç¨æ”¹ä»£ç æ¡†æ¶å³å¯æŠŠè¿™äº›é—®é¢˜ä¸€ç½‘æ‰“å°½ã€‚ â€‹\tå›æº¯ç®—æ³•æ ¸å¿ƒ å­é›†(å…ƒç´ æ— é‡ä¸å¯å¤é€‰) LeetCode78 å­é›† ç»„åˆ(å…ƒç´ æ— é‡ä¸å¯å¤é€‰) LeetCode77 ç»„åˆ æ’åˆ—(å…ƒç´ æ— é‡ä¸å¯å¤é€‰) LeetCode46 å…¨æ’åˆ— å­é›†&#x2F;ç»„åˆ(å…ƒç´ å¯é‡ä¸å¯å¤é€‰) LeetCode å­é›†2 LeetCode ç»„åˆæ€»å’Œ2 æ’åˆ—(å…ƒç´ å¯é‡ä¸å¯å¤é€‰) å…¨æ’åˆ—2 å­é›†&#x2F;ç»„åˆ(å…ƒç´ æ— é‡å¯å¤é€‰) LeetCode39 ç»„åˆæ€»å’Œ æ’åˆ—(å…ƒç´ æ— é‡å¯å¤é€‰) æ€»ç»“ å…ƒç´ æ— é‡å¤ä¸å¯å¤é€‰ 12345678910111213141516171819202122232425# ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums, start)&#123;\tfor i in range(start, len(nums))&#123; # åšé€‰æ‹© tarck.addLast(nums[i]) # æ³¨æ„å‚æ•° backtrack(nums, i+1) # æ’¤é”€é€‰æ‹© track.removeLast()\t&#125;&#125;# æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums)&#123; for i in range(len(nums))&#123; # å‰ªæé€»è¾‘ if used[i]: continue # åšé€‰æ‹© used[i] = true track.addLast(nums[i]) backtrack(nums) # æ’¤é”€é€‰æ‹© track.removeLast() used[i] = false &#125;&#125; å…ƒç´ å¯é‡ä¸å¯å¤é€‰ 123456789101112131415161718192021222324252627282930313233nums.sort()# ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums, start)&#123; # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶ for i in range(start, len(nums))&#123; # å‰ªæé€»è¾‘,è·³è¿‡ç›¸åŒçš„ç›¸é‚»æ ‘æ if i&gt;start and nums[i]==nums[i-1]: continue # åšé€‰æ‹© track.addLast(nums[i]) # æ³¨æ„å‚æ•° backtrack(nums, i+1) # æ’¤é”€é€‰æ‹© track.removeLast() &#125;&#125;nums.sort()# æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums)&#123; for i in range(len(nums))&#123; # å‰ªæé€»è¾‘ if used[i]:continue # å‰ªæé€»è¾‘,å›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½® if i&gt;0 and nums[i]==nums[i-1] and not used[i-1]: continue # åšé€‰æ‹© used[i] = true track.addLast(nums[i]) backtrack(nums) #æ’¤é”€é€‰æ‹© track.removeLast() used[i] = false &#125;&#125; å…ƒç´ æ— é‡å¯å¤é€‰ 12345678910111213141516171819202122# ç»„åˆ/å­é›†é—®é¢˜å›æº¯æ¡†æ¶def backtrack(nums, start)&#123; # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶\tfor i in range(start, len(nums))&#123; # åšé€‰æ‹© track.addLast(nums[i]) # æ³¨æ„å‚æ•° backtrack(nums, i) # æ’¤é”€é€‰æ‹© track.removeLase()\t&#125;&#125;# æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums)&#123;\tfor i in range(len(nums))&#123; # åšé€‰æ‹© track.addLast(nums[i]) backtrack(nums) # æ’¤é”€é€‰æ‹© track.removeLast() &#125;&#125; BFS(æ¡†æ¶) BFSæ¡†æ¶: å±‚åºéå† äºŒå‰æ ‘çš„æœ€å°é«˜åº¦ LeetCode111 äºŒå‰æ ‘çš„æœ€å°é«˜åº¦ è§£å¼€å¯†ç é”çš„æœ€å°‘æ¬¡æ•° LeetCode752 æ‰“å¼€è½¬ç›˜é” åŒå‘BFSä¼˜åŒ– ä¼ ç»Ÿçš„ BFS æ¡†æ¶å°±æ˜¯ä»èµ·ç‚¹å¼€å§‹å‘å››å‘¨æ‰©æ•£ï¼Œé‡åˆ°ç»ˆç‚¹æ—¶åœæ­¢ï¼›è€ŒåŒå‘ BFS åˆ™æ˜¯ä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶å¼€å§‹æ‰©æ•£ï¼Œå½“ä¸¤è¾¹æœ‰äº¤é›†çš„æ—¶å€™åœæ­¢ã€‚ äºŒåˆ†æœç´¢ å¯»æ‰¾ä¸€ä¸ªæ•°(åŸºæœ¬çš„äºŒåˆ†æœç´¢) LeetCode704 äºŒåˆ†æŸ¥æ‰¾ 1234567891011121314def binarySearch(nums, target)&#123;\tleft, right = 0, len(nums)-1\twhile(left&lt;=right): mid = left+(right-left)//2 if(nums[mid]==target): # ç›´æ¥è¿”å› return mid elif nums[mid]&gt;target: right = mid-1 elif nums[mid]&lt;target: left = mid+1 # ç›´æ¥è¿”å›\treturn -1&#125; å¯»æ‰¾å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢ 1234567891011121314151617181920def left_bound(nums, target)&#123; left, right = 0, len(nums)-1 # æœç´¢åŒºé—´ä¸º[left, right] while left&lt;=right: mid = left + (right-left)//2 if nums[mid]==target: # æ”¶ç¼©å³ä¾§è¾¹ç•Œ right = mid+1 elif nums[mid]&lt;target: # æœç´¢åŒºé—´å˜ä¸º[mid+1, right] left = mid+1 elif nums[mid]&gt;target: # æœç´¢åŒºé—´å˜ä¸º[left, mid-1] right = mid # åˆ¤æ–­targetæ˜¯å¦å­˜åœ¨äºnumsä¸­ # æ­¤æ—¶targetæ¯”æ‰€æœ‰æ•°éƒ½å¤§,è¿”å›-1 if left==len(nums): return -1 # åˆ¤æ–­ä¸€ä¸‹nums[left]æ˜¯ä¸æ˜¯target return nums[left]==target ? left : -1&#125; å¯»æ‰¾å³ä¾§è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾ 123456789101112131415def right_bound(nums, target)&#123; left, right = 0, len(nums)-1 while left&lt;=right: mid = left+(right-left)//2 if nums[mid]&lt;target: left=mid+1 elif nums[mid]&gt;target: right = mid-1 elif nums[mid]==target: # æ”¶ç¼©å·¦è¾¹ç•Œ left = mid+1 # æœ€åæ”¹æˆè¿”å›left-1 if left-1 &lt; 0: return -1 return nums[left-1]==target ? left-1 :-1&#125; æ€»ç»“: â€‹\tLeetCode34 åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½® æœ€åŸºæœ¬çš„äºŒåˆ†æŸ¥æ‰¾ç®—æ³• 1234567å› ä¸ºæˆ‘ä»¬åˆå§‹åŒ– right = nums.length - 1æ‰€ä»¥å†³å®šäº†æˆ‘ä»¬çš„ã€Œæœç´¢åŒºé—´ã€æ˜¯ [left, right]æ‰€ä»¥å†³å®šäº† while (left &lt;= right)åŒæ—¶ä¹Ÿå†³å®šäº† left = mid+1 å’Œ right = mid-1å› ä¸ºæˆ‘ä»¬åªéœ€æ‰¾åˆ°ä¸€ä¸ª target çš„ç´¢å¼•å³å¯æ‰€ä»¥å½“ nums[mid] == target æ—¶å¯ä»¥ç«‹å³è¿”å› å¯»æ‰¾å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾ 12345678å› ä¸ºæˆ‘ä»¬åˆå§‹åŒ– right = nums.lengthæ‰€ä»¥å†³å®šäº†æˆ‘ä»¬çš„ã€Œæœç´¢åŒºé—´ã€æ˜¯ [left, right)æ‰€ä»¥å†³å®šäº† while (left &lt; right)åŒæ—¶ä¹Ÿå†³å®šäº† left = mid + 1 å’Œ right = midå› ä¸ºæˆ‘ä»¬éœ€æ‰¾åˆ° target çš„æœ€å·¦ä¾§ç´¢å¼•æ‰€ä»¥å½“ nums[mid] == target æ—¶ä¸è¦ç«‹å³è¿”å›è€Œè¦æ”¶ç´§å³ä¾§è¾¹ç•Œä»¥é”å®šå·¦ä¾§è¾¹ç•Œ å¯»æ‰¾å³ä¾§è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾ 1234567891011å› ä¸ºæˆ‘ä»¬åˆå§‹åŒ– right = nums.lengthæ‰€ä»¥å†³å®šäº†æˆ‘ä»¬çš„ã€Œæœç´¢åŒºé—´ã€æ˜¯ [left, right)æ‰€ä»¥å†³å®šäº† while (left &lt; right)åŒæ—¶ä¹Ÿå†³å®šäº† left = mid + 1 å’Œ right = midå› ä¸ºæˆ‘ä»¬éœ€æ‰¾åˆ° target çš„æœ€å³ä¾§ç´¢å¼•æ‰€ä»¥å½“ nums[mid] == target æ—¶ä¸è¦ç«‹å³è¿”å›è€Œè¦æ”¶ç´§å·¦ä¾§è¾¹ç•Œä»¥é”å®šå³ä¾§è¾¹ç•Œåˆå› ä¸ºæ”¶ç´§å·¦ä¾§è¾¹ç•Œæ—¶å¿…é¡» left = mid + 1æ‰€ä»¥æœ€åæ— è®ºè¿”å› left è¿˜æ˜¯ rightï¼Œå¿…é¡»å‡ä¸€ æ»‘åŠ¨çª—å£ æ»‘åŠ¨çª—å£æ¡†æ¶ 123456789101112131415161718left, right = 0,0while right&lt;len(s): # cæ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦ window.add(s[right]) # å¢å¤§çª—å£ right += 1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... # debugè¾“å‡ºçš„ä½ç½® printf(&quot;Window:[%d, %d] &quot;, left, right) # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼© while window needs shrink: # dæ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦ char d = s[left] # ç¼©å°çª—å£ left+=1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... æœ€å°è¦†ç›–å­ä¸² LeetCode76 æœ€å°è¦†ç›–å­ä¸² å­—ç¬¦ä¸²æ’åˆ— LeetCode567 å­—ç¬¦ä¸²çš„æ’åˆ— æ‰¾æ‰€æœ‰å­—æ¯å¼‚ä½è¯ LeetCode438 æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯ æœ€é•¿æ— é‡å¤å­ä¸² LeetCode3 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² æ€»ç»“: 1. ä»€ä¹ˆæ—¶å€™åº”è¯¥æ‰©å¤§çª—å£? 1. ä»€ä¹ˆæ—¶å€™åº”è¯¥ç¼©å°çª—å£? 1. ä»€ä¹ˆæ—¶å€™åº”è¯¥æ›´æ–°ç­”æ¡ˆ? ä¹°è‚¡ç¥¨(DP) çŠ¶æ€è½¬ç§»æ–¹ç¨‹ 1234567base caseï¼šdp[-1][...][0] = dp[...][0][0] = 0dp[-1][...][1] = dp[...][0][1] = -infinityçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) base case 12345678910111213dp[-1][...][0] = 0è§£é‡Šï¼šå› ä¸º i æ˜¯ä» 0 å¼€å§‹çš„ï¼Œæ‰€ä»¥ i = -1 æ„å‘³ç€è¿˜æ²¡æœ‰å¼€å§‹ï¼Œè¿™æ—¶å€™çš„åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚dp[-1][...][1] = -infinityè§£é‡Šï¼šè¿˜æ²¡å¼€å§‹çš„æ—¶å€™ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚dp[...][0][0] = 0è§£é‡Šï¼šå› ä¸º k æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥ k = 0 æ„å‘³ç€æ ¹æœ¬ä¸å…è®¸äº¤æ˜“ï¼Œè¿™æ—¶å€™åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚dp[...][0][1] = -infinityè§£é‡Šï¼šä¸å…è®¸äº¤æ˜“çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚ LeetCode121 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº LeetCode122 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº2 LeetCode309 æœ€ä½³ä¹°å–è‚¡ç¥¨å«å†·å†»æœŸ LeetCode714 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹ LeetCode123 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº3 LeetCode188 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº4 æ‰“å®¶åŠ«èˆ(DP) æ‰“å®¶åŠ«èˆ1 LeetCode198 æ‰“å®¶åŠ«èˆ 12345678910111213141516# å¸¦å¤‡å¿˜å½•def rob(nums): n = len(nums) if n==0: return 0\tif n==1: return nums[0]\tdp = [0]*n dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2]+nums[i]) return dp[n-1]# ä¼˜åŒ–ç©ºé—´def rob(nums): prev, curr = 0, 0 for i in nums: prev, curr = curr, max(curr, prev+1) return curr æ‰“å®¶åŠ«èˆ2 LeetCode213 æ‰“å®¶åŠ«èˆ2 æ‰“å®¶åŠ«èˆ3 LeetCode337 æ‰“å®¶åŠ«èˆ3 nSum ä¸¤æ•°ä¹‹å’Œ LeetCode1 ä¸¤æ•°ä¹‹å’Œ 3Sum LeetCode15 ä¸‰æ•°ä¹‹å’Œ 4Sum LeetCode18 å››æ•°ä¹‹å’Œ ç¬¬ä¸€ç«  æ•°æ®ç»“æ„é“¾è¡¨1æ‹‰å®¾-å¡æ™® æ•°ç»„äºŒå‰æ ‘å›¾è®¾è®¡æ•°æ®ç»“æ„","tags":["ç®—æ³•","æ•°æ®ç»“æ„","leetcode","python"],"categories":["ç®—æ³•"]},{"title":"è“æ¡¥æ¯å¤‡èµ›","path":"/2023/04/19/è“æ¡¥æ¯å¤‡èµ›/","content":"è“æ¡¥æ¯æš´åŠ›dfsbfså›æº¯åŠ¨æ€è§„åˆ’èƒŒåŒ…é—®é¢˜æ•°è®ºæœ€å¤§å…¬çº¦æ•°12345def gcd(a, b): if b == 0: reutrn a a, b = b, a % b return gcd(a, b) ä¸­å›½å‰©ä½™å®šç†12345678910111213141516171819202122def exgcd(a, b): if b == 0: return 1, 0 else: x, y = exgcd(b, a % b) return y, (x - a // b * y)def CRT(k, a, r): n = 1; ans = 0 for i in range(1, k + 1): n = n * r[i] for i in range(1, k + 1): m = n // r[i] b, y = exgcd(m, r[i]) # b * m mod r[i] = 1 while b &lt; 0: b += r[i] ans = (ans + a[i] * m * b) % n return (ans % n + n) % nr = [0, 3, 5, 7]a = [0, 2, 3, 2]print(CRT(3, a, r)) ç­›æ³•æ±‚ç´ æ•°12345678def isPrime(n):\tprime = [True] * n for i in range(2, n + 1): if prime[i]: for i in range(i * 2, n + 1, i): prime[i] = False return [i for i in range(2, n) if prime[i]] å›¾è®ºå›¾è®ºåŸºç¡€åŠéå†æ„å»ºå›¾(é‚»æ¥è¡¨) 123456789def buildGraph(numCourses: int, prerequisites: List[List[int]]) -&gt; List[List[int]]: # å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹ graph = [[] for _ in range(numCourses)] for edge in prerequisites: from_, to_ = edge[1], edge[0] # æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹ # å¦‚æœæ˜¯æ— å‘å›¾ï¼Œåˆ™å†åå‘æ·»åŠ ä¸€æ¬¡ graph[from_].append(to_) return graph å›¾çš„éå† 12345678910111213141516# è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹visited = []# è®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„onPath = []def traverse(graph, s): if visited[s]: return # ç»è¿‡èŠ‚ç‚¹ sï¼Œæ ‡è®°ä¸ºå·²éå† visited[s] = True # åšé€‰æ‹©ï¼šæ ‡è®°èŠ‚ç‚¹ s åœ¨è·¯å¾„ä¸Š onPath[s] = True for neighbor in graph.neighbors(s): traverse(graph, neighbor) # æ’¤é”€é€‰æ‹©ï¼šèŠ‚ç‚¹ s ç¦»å¼€è·¯å¾„ onPath[s] = False ç¯æ£€æµ‹åŠæ‹“æ‰‘æ’åºç¯æ£€æµ‹ 12345678910111213141516171819202122def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: graph = self.buildGraph(numCourses, prerequisites) self.visited = [False] * numCourses self.onPath = [False] * numCourses self.hasCycle = False for i in range(numCourses): self.traverse(graph, i) return not self.hasCycledef traverse(self, graph, s): if self.onPath[s]: self.hasCycle = True if self.visited[s] or self.hasCycle: return self.visited[s] = True self.onPath[s] = True for t in graph[s]: self.traverse(graph, t) self.onPath[s] = Falsedef buildGraph(self, numCourses, prerequisites): # ä»£ç è§å‰æ–‡ æ‹“æ‰‘æ’åº 1234567891011121314151617181920212223242526272829303132333435363738def findOrder(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: # è®°å½•ååºéå†ç»“æœ postorder = [] # è®°å½•æ˜¯å¦å­˜åœ¨ç¯ hasCycle = False visited = [False] * numCourses onPath = [False] * numCourses # å»ºå›¾å‡½æ•° def buildGraph(numCourses, prerequisites): # ä»£ç è§å‰æ–‡ pass # å›¾éå†å‡½æ•° def traverse(graph, s): if onPath[s]: # å‘ç°ç¯ hasCycle = True if visited[s] or hasCycle: return # å‰åºéå†ä½ç½® onPath[s] = True visited[s] = True for t in graph[s]: traverse(graph, t) # ååºéå†ä½ç½® postorder.append(s) onPath[s] = False graph = buildGraph(numCourses, prerequisites) # éå†å›¾ for i in range(numCourses): traverse(graph, i) # æœ‰ç¯å›¾æ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº if hasCycle[0]: return [] # é€†ååºéå†ç»“æœå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ return postorder[::-1] äºŒåˆ†å›¾åˆ¤å®š1234567891011121314151617181920212223242526272829303132333435363738394041424344def __init__(self): # è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨ self.ok = True # è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼ŒFalseå’ŒTrueä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰² self.color = [] # è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ self.visited = []# ä¸»å‡½æ•°ï¼Œè¾“å…¥é‚»æ¥è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾def isBipartite(self, graph: List[List[int]]) -&gt; bool: n = len(graph) self.color = [False] * n self.visited = [False] * n # å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾ # æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå† # å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾ for v in range(n): if not self.visited[v]: self.traverse(graph, v) if not self.ok: break return self.ok# DFS éå†æ¡†æ¶def traverse(self, graph: List[List[int]], v: int) -&gt; None: # å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº† if not self.ok: return self.visited[v] = True for w in graph[v]: if not self.visited[w]: # ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡ # é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰² self.color[w] = not self.color[v] # ç»§ç»­éå† w self.traverse(graph, w) else: # ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡ # æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾ if self.color[w] == self.color[v]: # è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾ self.ok = False return Primæœ€å°ç”Ÿæˆæ ‘123456789101112131415161718192021222324252627282930313233343536373839404142import heapqclass Prim: # æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œå­˜å‚¨ã€Œæ¨ªåˆ‡è¾¹ã€çš„ä¼˜å…ˆçº§é˜Ÿåˆ— def __init__(self, graph: List[List[int]]): self.graph = graph self.pq = [] # PriorityQueue&lt;int[]&gt; çš„å®ç° self.inMST = [False] * len(graph) # ç±»ä¼¼ visited æ•°ç»„çš„ä½œç”¨ï¼Œè®°å½•å“ªäº›èŠ‚ç‚¹å·²ç»æˆä¸ºæœ€å°ç”Ÿæˆæ ‘çš„ä¸€éƒ¨åˆ† self.weightSum = 0 # è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡å’Œ self.inMST[0] = True # éšä¾¿ä»ä¸€ä¸ªç‚¹å¼€å§‹åˆ‡åˆ†éƒ½å¯ä»¥ï¼Œæˆ‘ä»¬ä¸å¦¨ä»èŠ‚ç‚¹ 0 å¼€å§‹ self.cut(0) # ä¸æ–­è¿›è¡Œåˆ‡åˆ†ï¼Œå‘æœ€å°ç”Ÿæˆæ ‘ä¸­æ·»åŠ è¾¹ while self.pq: # æŒ‰ç…§è¾¹çš„æƒé‡ä»å°åˆ°å¤§æ’åº edge = heapq.heappop(self.pq) to = edge[1] # è¡¨ç¤ºç›¸é‚»èŠ‚ç‚¹ weight = edge[2] # è¡¨ç¤ºè¿™æ¡è¾¹çš„æƒé‡ if self.inMST[to]: # èŠ‚ç‚¹ to å·²ç»åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼Œè·³è¿‡ã€‚å¦åˆ™è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ continue self.weightSum += weight # å°†è¾¹ edge åŠ å…¥æœ€å°ç”Ÿæˆæ ‘ self.inMST[to] = True self.cut(to) # èŠ‚ç‚¹ to åŠ å…¥åï¼Œè¿›è¡Œæ–°ä¸€è½®åˆ‡åˆ†ï¼Œä¼šäº§ç”Ÿæ›´å¤šæ¨ªåˆ‡è¾¹ # å°† s çš„æ¨ªåˆ‡è¾¹åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ— def cut(self, s): for edge in self.graph[s]: # éå† s çš„é‚»è¾¹ to = edge[1] # ç›¸é‚»çš„èŠ‚ç‚¹ if self.inMST[to]: # ç›¸é‚»æ¥ç‚¹ to å·²ç»åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼Œè·³è¿‡ continue heapq.heappush(self.pq, edge) # åŠ å…¥æ¨ªåˆ‡è¾¹é˜Ÿåˆ— # æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡å’Œ def weightSum(self) -&gt; int: return self.weightSum # åˆ¤æ–­æœ€å°ç”Ÿæˆæ ‘æ˜¯å¦åŒ…å«å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ def allConnected(self) -&gt; bool: for i in range(len(self.inMST)): if not self.inMST[i]: return False return True Dijstraæœ€çŸ­è·¯å¾„12345678910111213141516171819import heapqfrom typing import List# å‡è®¾ graph æ˜¯ä¸€ä¸ªé‚»æ¥çŸ©é˜µï¼Œgraph[i][j] æ˜¯ä»èŠ‚ç‚¹ i åˆ°èŠ‚ç‚¹ j çš„è·ç¦»def dijkstra(start: int, graph: List[List[int]]) -&gt; List[int]: V = len(graph) distTo = [float(&#x27;inf&#x27;)] * V distTo[start] = 0 pq = [(0, start)] # ä½¿ç”¨å…ƒç»„ (distance, node)ï¼Œä»¥ä¾¿æŒ‰ç…§ distance è¿›è¡Œæ’åº while pq: (dist, curNodeID) = heapq.heappop(pq) if dist &gt; distTo[curNodeID]: continue for weight, nextNodeID in graph[curNodeID]: if weight is not None: # å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ‰è¾¹ distToNextNode = distTo[curNodeID] + weight if distTo[nextNodeID] &gt; distToNextNode: distTo[nextNodeID] = distToNextNode heapq.heappush(pq, (distToNextNode, nextNodeID)) return distTo","tags":["ç®—æ³•","Python","è“æ¡¥æ¯"],"categories":["ç®—æ³•"]},{"title":"Hello World","path":"/2023/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["Hexo"],"categories":["Hexo"]},{"title":"å…³äº","path":"/about/index.html","content":"ğŸ”­ Iâ€™m currently studying in CQUPT and will soon go to Zhejiang University ğŸŒ± Iâ€™m good at C++ and Python ğŸ‘¯ Iâ€™m familiar with computer networks, data structures and operating systems ğŸ¤” I understand network structure models such as RNN, LSTM, and Transformer, and have a basic understanding of deep learning. âš¡ Fun fact: mobile and algorithm ğŸ“« How to reach me: Email: &#x31;&#52;&#52;&#x38;&#51;&#55;&#53;&#50;&#x34;&#57;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;","tags":[null],"categories":[null]}]