[{"title":"保研经验贴","path":"/2024/09/29/保研经验贴/","content":"2024年（2025届）四非计算机保研经验贴（浙软，北邮，重大，成电，西电杭，深大）前言今年是对四非地狱级外保难度的一年（以后会更难🤡），大部分学校保研率提升，盛行本校保护，工程硕博计划占用大量名额，很多学校开始优化生源质量，但所幸我的结果也还不错。 个人情况学校：某西南地区四非 专业：软件工程 rk：前五学期排名3&#x2F;360（夏令营根本过不了），六学期综合排名1&#x2F;530（排名出的太晚了，很多好学校已经截止了）。 四六级：4级490，6级没过（夏令营被拒得快奔溃了），预推免450（勉强能用） 竞赛：蓝桥杯国一，软件杯国三，数模省一（大部分老师不看，甚至有老师问蓝桥杯是什么比赛🤡） 科研：🈚，极大的短板 rk≈顶级科研&gt;6级&gt;竞赛 目标：中9或北邮。 最终去向：浙江大学软件学院，人工智能。 夏令营入营情况不是rk1+没过6级，夏令营极其惨淡，真的快崩溃了。 学校 学院 状态 备注 南京大学 智能软件 未入 投着玩 南京大学 软件 未入 双杀 北京邮电大学 计算机 面试寄 面试15min，寄了 浙江大学 软件 优营 预推免入场券 西北工业大学 软件 未入 不懂 中山大学 软件 未入 投着玩 电子科技大学 智能计算 未入 投着玩 山东大学 软件 宣讲营 海营 中国科学技术大学 先研院 未入 发了20封邮件，无果 北京师范大学 人工智能 未入 投着玩 北京理工大学 珠海 未入 投着玩 北京交通大学 计算机 未入 不懂 华南理工大学 软件 未入 不懂 深圳大学 计算机 优营 候补第二批入了 重庆大学 计算机 未入 卡双一流 重庆大学 工程师 未入 双杀 重庆大学 软件 未入 三杀 北京航空航天大学 计算机 未入 投着玩 北京航空航天大学 软件 机试寄 不是acmer 从上面的表可以看到，夏令营十分惨烈，只拿到了深大的offer和浙软预推免的入场券。 北京邮电大学计算机，寄了入了11组，说是从200人里选了40人，最终录取8人。线上15分钟面试，8分钟自我介绍，然后是提问项目，第一次面试，准备不充分，结果就是寄了。 浙软，优营线上，总共入了2700人，我选的是大数据分营，然后里面还要再分团队。我们团队是阅读一篇论文，然后做一个汇报+面试，准备了一个星期，优了。今年出现了卓越营员（只能是985和北邮西电）相当于铁offer，然后是优秀营员（预推免入场券），今年的bar异常的高，对于双非和211基本靠优营才能进预推免。优秀营员占比10%，卓越营员占比3%。 深圳大学，优营唯一一个线下的夏令营，由于是无条件报销800元，入营门槛较高，候补了两轮进去了。首先就是听讲座，第一天晚上模拟机试，第二天晚上正式机试，难度一般数据结构的水平，后面有一点点难，最后70分，第三天下午是面试。面试方式为群面，分到各个团队里，以圆桌会议的方式聊天，最后拿到优营offer（疑似机试不爆零就给）。 不得不说，深大是真的有钱，如果不是四非就好了。 预推免入营情况 学校 学院 状态 备注 浙江大学 软件学院 候补3 最终去向 南京大学 软件学院 未入 投着玩 南京大学 智能软件 未入 投着玩 中南大学 计算机 未入 有点迷 湖南大学 工程硕博 未入 有点迷 湖南大学 信息学院 未入 有点迷 中国科学技术大学 科学岛 未入 有点迷 中国科学技术大学 工程硕博 未入 投着玩 山东大学 计算机 已入,鸽 时间太长和重大冲突了 大连理工大学 计算机 已入,鸽 和浙软冲突了 同济大学 工程硕博 未入 投着玩 西安电子科技大学 卓工 已入,寄 体验了一下 南京航空航天大学 计算机 已入,鸽 和浙软冲突了 电子科技大学 计算机 已入,鸽 浙软候补到了，没去 重庆大学 计算机 候补,鸽 体验了一下 北京邮电大学 计算机 被鸽 被老师鸽了🤡，后有惊喜 可以看到，预推免的时候我推免排名提高，入营情况也稍微好点了。但由于今年大部分学校提升生源质量，预推免仍然艰难。 浙软浙软是我预推免的第一站，也是我的最终去向。 今年bar很高，由于有夏令营的优营，过了初筛，今年双非rk1基本进不去。预推免总共筛了近800人，线下来了540人，生源明显比去年提高了，大概90%都是9爷。 浙软复试分为机试和面试，机试占比15%，第一天晚上开始机试，共4道题，难度以此递增，题目背景均与赤壁相关（考察了简单数学，dfs，dp，二分），难度比去年略大，但是ak人数更多了，我1个半小时ak，排名40+，等到结束时，约130个ak，90分以上的200+。听说往年是按机试给面试成绩，但今年机试没有区分度了（太卷了🤡），而且老师面试的时候好像看不到你的机试成绩。 20号机试，面试排到22号了，时间20分钟，有个计时器。浙软不同的组面试风格很不同。我们组首先来个1分钟英文自我介绍，然后开始用ppt讲5-8分钟。接下来问专业课，我选择了计网，问了两个问题，没听懂（🤡），然后换了数据结构。怎么求树的直径，怎么求图的直径，树的直径和图的直径有什么区别。如何维护数组中的最大值，如何快速求出中位数。用过stl吧，如果需要一个自动排序的集合，可以有重复的元素，应该用什么。multiset插入两次2，erase一次2，结果是什么。sort函数从小到大排序，比较怎么写，如果把&lt;改成&lt;&#x3D;有什么区别。答的稀烂，然后开始问项目，项目里有个把n个模型分配到m个设备，我使用的线性规划，老师说这是一个算法问题，应该用什么算法解决，（完全不懂🤡），然后又问了一些项目的细节。最后问到，夏令营在哪个营，哪个课题组，干了些什么。就这样结束了。 总之面崩了，出来后整个人都不好了，那个主问的老师应该是打acm的，看见我算法不错，直接问到底。。。可我不是acmer啊😭。在外面坐了一会儿，感觉天塌了，然后就去杭州西湖散散心，顺便参加西电杭的复试（本来打算如果稳了的话，就不参加了）。 25号出了结果，排名190+&#x2F;540，候补第三，然后第二天就补到了，一步登天，跨越双非、双一流、211、普通985这些学院歧视链直接来到顶流985水平。 ps：浙软明年就换新校区了，来了很多新导师，生源质量也上来了，以后会越来越好，24入浙软&#x3D;49入党！ 西电杭接上，面完了浙软，感觉大寄，就去杭州面西电杭了，准备拿个保底。 西电杭需要先联系导师，这个老师是我在报完系统后主动找我的，简单聊了一下，方向也还行，然后就选他了。 复试分为笔试和面试，笔试内容为通信，数据结构，计组，计网，密码学。只会写数据结构。 面试先英语自我介绍，然后用英语介绍一个项目。接着就是问项目的一些细节。最后还有思政题，没答上来🤡。 面完感觉比较水，然后过了几天也没消息，我也没去联系老师，典型的学校和学生互鸽🕊️，反正我有浙软offer了，不管他了。 重大计算机重大今年bar很迷，计算机卡rk1，软件卡双一流，而且复试费150元。 26号面试，交了钱都鸽了1&#x2F;3。面试内容：先英语自我介绍，然后口语对话，及其简单，感觉像是小学生对话，问了我的sports。然后专业课问了数组如何查询固定区间的和，使用前缀和。接着问项目，重大的老师是唯一一个问了我数模的项目，问的还比较细。然后问了我报了哪些学校，有什么offer，其实当时我还是0ffer。然后就结束了。 由于知道浙软肯定能补到，所以重大面试也没怎么上心，而且问的也比较水。 第二天告诉我候补，没有名单。928下午打电话说我候补到了，计算机学硕，然后我拒了。 ps：往年点击就送的重大不见了。。。 决战929今年系统又改了，928上午9点填志愿，929上午9点招生单位开始录取，所以今年的鸽子会在928先飞一批，然后929再飞一批。 首先科普一下推免系统 一个学生可以填写三个独立志愿 一个院校可以给学生发放复试、拟录取通知 先接受复试，再接受拟录取 但复试、拟录取，都是有时效性的，比如10分钟内没有接受，招生办可能会收回你的offer 只要你接受了拟录取，你的保研生涯就会结束 9月28日9点~9月29日9点这段时间，学生可以填写志愿 每个志愿填写之后自动上锁，48小时不可以修改（但是院校教务老师，可以帮你解锁你的志愿） 9月29日9点之后院校才可以开始发放复试、拟录取通知 每个志愿是平行的，院校看不到你是第几个填写的这个志愿 但是院校给你发放通知的时候，可以看到你接受了哪些学校的复试 鸽链反应：这是一个非常有趣的现象 原因1： 可以理解为28定律，80%的offer在20%的人中，但也不完全是。 原因2： 比如学生A能在厦大夏令营拿到第1，那么他绝不可能只有厦大这个offer，A很可能在华科拿到offer第20或30，人大拿到offer第60这样，而复旦拿到候补名单第5。 结果A前面参加复旦夏令营的人又同时拿到清北、计算所的offer了，纷纷释放复旦offer，然后A被候补到了，于是A就释放厦大、华科、人大的offer。在前面三个学校的人，又因为A的释放被候补到了。 然后这些被候补到的人，继续往下一层释放offer，比如西电、南航等，最后候补和鸽子就会像树形结构一样疯狂下传。 因为929之前拿的offer都不是铁offer，学生自己也可能被弱com鸽，需要拿强com院校保底。以及可能学生自身也有多个梦校，都会尝试拿offer。 原因3： 这个现象往往出现在招生办开始录取时，毕竟每个人只能去读一个学校，你可能有差一点的学校B的准offer，也有梦校C的候补。 比如差一点学校，要求你1分钟接受拟录取，否则作废。那么你面对的只有四种结果 接受，你没有候补到，一个很棒的结果，你最终去了学校B 接受，你候补到了，你痛失梦校非常遗憾，但好像还能接受，你最终去了学校B 拒绝，你等到了候补，上岸梦校，你最终去了梦校C 拒绝，你没有等到候补，一瞬间没有书读了，成为loser 很多人担心没有书读而接受了拟录取，假设候补到时已经系统已经锁了，只能继续往下滚动候补队列 一些见闻1、好多学校鸽穿了，该！ 2、圣经就是圣经！ 3、一定要海投！ 4、尽量不要鸽老师，要鸽早点鸽，别等到录取那天临时鸽，你自己爽了，下一届学弟学妹遭殃了，更不要集邮！ 5、8月联系了一个北邮老师（15组），还进组打工一段时间，然后中秋节把我鸽了。。。928的时候又跟我说有学硕名额🤡。 6、今年想外保真的挺难的，我们学院去了不少211，甚至还有本校。 7、还有好多名场面，最后几天乐子真多，强烈建议加入绿群 943826679 另外，给还在准备保研的uu们告诫： 首先，铭记住幸存者偏差 其次，选择大于努力 不要盲目自信，不要感动自我式的努力 不要孤注一掷，多一点选项，有时候真的运气&gt;实力 总结三年的长跑终于画上了句号，最后那一段时间都在焦虑，终究还是挺过来了。在四非0科研的情况和今年地狱级的外保形势下，感觉已经是我能找到的最优解了。一个个选择塑造了人生，这次all in 浙软，希望一切都是最好的安排。 最后，愿所有的保研er们，最终都取得心仪的offer，上岸梦校","tags":["保研","计算机"],"categories":["保研"]},{"title":"洛谷题单","path":"/2024/09/19/洛谷题单/","content":"洛谷综合题单试机题 三道试机题目。 P1000 超级玛丽游戏 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot; ******** &quot;; cout&lt;&lt;&quot; ************ &quot;;\tcout&lt;&lt;&quot; ####....#. &quot;; cout&lt;&lt;&quot; #..###.....##.... &quot;; cout&lt;&lt;&quot; ###.......###### ### ### &quot;; cout&lt;&lt;&quot; ........... #...# #...# &quot;; cout&lt;&lt;&quot; ##*####### #.#.# #.#.# &quot;; cout&lt;&lt;&quot; ####*******###### #.#.# #.#.# &quot;; cout&lt;&lt;&quot; ...#***.****.*###.... #...# #...# &quot;; cout&lt;&lt;&quot; ....**********##..... ### ### &quot;; cout&lt;&lt;&quot; ....**** *****.... &quot;; cout&lt;&lt;&quot; #### #### &quot;; cout&lt;&lt;&quot; ###### ###### &quot;; cout&lt;&lt;&quot;############################################################## &quot;; cout&lt;&lt;&quot;#...#......#.##...#......#.##...#......#.##------------------# &quot;; cout&lt;&lt;&quot;###########################################------------------# &quot;; cout&lt;&lt;&quot;#..#....#....##..#....#....##..#....#....##################### &quot;; cout&lt;&lt;&quot;########################################## #----------# &quot;; cout&lt;&lt;&quot;#.....#......##.....#......##.....#......# #----------# &quot;; cout&lt;&lt;&quot;########################################## #----------# &quot;; cout&lt;&lt;&quot;#.#..#....#..##.#..#....#..##.#..#....#..# #----------# &quot;; cout&lt;&lt;&quot;########################################## ############ &quot;; return 0;&#125; P1001 A+B Problem 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b; return 0;&#125; P1008 三连击 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool st[10];string str;void dfs(int x) &#123;\tif (x == 9) &#123; int a = stoi(str.substr(0, 3)); int b = stoi(str.substr(3, 3)); int c = stoi(str.substr(6, 3)); if (a * 2 == b &amp;&amp; a * 3 == c) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; &#125;\t&#125;\tfor (int i = 1; i &lt; 10; i++) &#123; if (!st[i]) &#123; st[i] = true; str.push_back(i + &#x27;0&#x27;); dfs(x + 1); st[i] = false; str.pop_back(); &#125;\t&#125;&#125;int main()&#123;\tdfs(0);\treturn 0;&#125; 入门阶段 本部分内容针对入门 OIer ，主要是语言基础内容。 从零开始 语言基础题。 P1421 小玉买文具 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b;\tcin &gt;&gt; a &gt;&gt; b;\tint c = a * 10 + b;\tcout &lt;&lt; c / 19; return 0;&#125; P1909 买铅笔 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a1, a2, b1, b2, c1, c2, res1, res2, res3, res;\tcin &gt;&gt; n &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2 &gt;&gt; c1 &gt;&gt; c2;\tif (n % a1 == 0) res1 = n / a1 * a2;\telse res1 = (n / a1 + 1) * a2;\tif (n % b1 == 0) res2 = n / b1 * b2;\telse res2 = (n / b1 + 1) * b2;\tif (n % c1 == 0) res3 = n / c1 * c2;\telse res3 = (n / c1 + 1) * c2;\tres = min(res1, min(res2, res3));\tcout &lt;&lt; res; return 0;&#125; P1089 津津的储蓄计划 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123;\tint x, rem = 0; double res; for (int i = 1; i &lt;= 12; i++) &#123; cin &gt;&gt; x; rem = rem + 300 - x; if (rem &lt; 0) &#123; cout &lt;&lt; -i; return 0; &#125; else if (rem &gt;= 100) &#123; res += (rem / 100) * 100; rem %= 100; &#125;\t&#125;\tcout &lt;&lt; res * 1.2 + rem; return 0;&#125; P1085 不高兴的津津 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123;\tint a, b;\tint res = 0, mind = 0;\tfor (int i = 1; i &lt;= 7; i++) &#123; cin &gt;&gt; a &gt;&gt; b; int t = min(0, 8 - a - b); if (mind &gt; t) &#123; res = i; mind = t; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1035 级数求和 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123;\tint k;\tcin &gt;&gt; k;\tdouble t;\tfor (int i = 1; i &lt; 10000000; i++) &#123; t += 1.0 / i; if (t &gt; k) &#123; cout &lt;&lt; i; break; &#125;\t&#125; return 0;&#125; P1980 计数问题 #include &lt;iostream&gt; using namespace std; int main() &#123; int n, x, res = 0; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; i++) &#123; int t = i; while (t &gt; 0) &#123; if (t % 10 == x) res++; t /= 10; &#125; &#125; cout &lt;&lt; res; return 0; &#125; 1234567891011121314151617181920212223242526272829303132- [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)```c++#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1000;string g[N][N];int main() &#123;\tint n, i = 1, j = 1, t = 1, flag = 1;\tcin &gt;&gt; n;\twhile (t &lt; n) &#123; if (flag == 1) &#123; j++; flag = 2; &#125; else if (flag == 2) &#123; i++; j--; if(j == 1) flag = 3; &#125; else if (flag == 3) &#123; i++; flag = 4; &#125; else if (flag == 4) &#123; i--; j++; if (i == 1) flag = 1; &#125; t++;\t&#125;\tcout &lt;&lt; i &lt;&lt; &quot;/&quot; &lt;&lt; j; return 0;&#125; P1307 数字反转 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;\tstring n;\tcin &gt;&gt; n;\tif (n[0] == &#x27;-&#x27;) &#123; cout &lt;&lt; &#x27;-&#x27;; n = n.substr(1);\t&#125; else if (n == &quot;0&quot;) &#123; cout &lt;&lt; 0; return 0;\t&#125;\treverse(n.begin(), n.end());\twhile (n[0] == &#x27;0&#x27;) &#123; n.erase(0, 1);\t&#125;\tcout &lt;&lt; n; return 0;&#125; 优化 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123;\tint n, m = 0;\tcin &gt;&gt; n;\twhile (n) &#123; m = m * 10 + n % 10; n /= 10;\t&#125;\tcout &lt;&lt; m; return 0;&#125; 数组基础 数组可以用于存储大量的信息。 P1046 陶陶摘苹果 1234567891011121314#include &lt;iostream&gt;using namespace std;int nums[11], n, res;int main() &#123; for (int i = 0; i &lt; 10; i++) &#123; cin &gt;&gt; nums[i];\t&#125;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; 10; i++) &#123; if (n + 30 &gt;= nums[i]) res++;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1047 校门外的树 1234567891011121314151617#include &lt;iostream&gt;using namespace std;bool nums[10001];int main() &#123; int n, m, l, r; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r; for (int j = l; j &lt;= r; j++) nums[j] = true;\t&#125;\tint res = 0;\tfor (int i = 0; i &lt;= n; i++) if (!nums[i]) res++;\tcout &lt;&lt; res; return 0;&#125; P1427 小鱼的数字游戏 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; vector&lt;int&gt; nums; int x; while (true) &#123; cin &gt;&gt; x; if (x == 0) break; nums.push_back(x);\t&#125;\treverse(nums.begin(), nums.end());\tfor (auto it: nums) cout &lt;&lt; it &lt;&lt; &quot; &quot;; return 0;&#125; P2141 珠心算测验 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int nums[101];bool st[20001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; st[nums[i]] = true;\t&#125;\tset&lt;int&gt; res;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[i] == nums[j]) continue; if (st[nums[i] + nums[j]]) res.insert(nums[i] + nums[j]); &#125;\t&#125;\tcout &lt;&lt; res.size(); return 0;&#125; P5594 【XR-4】模拟赛 123456789101112131415161718#include &lt;iostream&gt;#include &lt;set&gt; using namespace std;set&lt;int&gt; nums[1001];int main() &#123; int n, m, k, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; nums[x].insert(j); &#125;\t&#125;\tfor (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; nums[i].size() &lt;&lt; &quot; &quot;;\t&#125; return 0;&#125; 字符串基础 字符串是特殊的数组，但它也有很多自身的特点。 P5015 标题统计 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;\tstring s; getline(cin, s); int res = 0;\tfor (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] != &#x27; &#x27; &amp;&amp; s[i] != &#x27; &#x27;) res++;\t&#125; cout &lt;&lt; res; return 0;&#125; P1055 ISBN号码 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123;\tint a, b, c;\tchar d, e;\tscanf(&quot;%d-%d-%d-%c&quot;, &amp;a, &amp;b, &amp;c, &amp;d);\tint t = (a + (b / 100) * 2 + (b % 100 / 10) * 3 + (b % 10) * 4 + (c / 10000) * 5 + (c % 10000 / 1000) * 6 + (c % 1000 / 100) * 7 + (c % 100 / 10) * 8 + (c % 10) * 9 ) % 11;\tif (t == 10) e = &#x27;X&#x27;;\telse e = &#x27;0&#x27; + t;\tif (d == e) cout &lt;&lt; &quot;Right&quot;;\telse cout &lt;&lt; a &lt;&lt; &quot;-&quot; &lt;&lt; b &lt;&lt; &quot;-&quot; &lt;&lt; c &lt;&lt; &quot;-&quot; &lt;&lt; e; return 0;&#125; P1308 统计单词数 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;\tstring p, s;\tcin &gt;&gt; p;\tgetchar();\tfor (int i = 0; i &lt; p.size(); i++) p[i] = tolower(p[i]);\tint id = -1, cnt = 0, j = 0;\tgetline(cin, s);\tfor (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27; &#x27;) continue; int j = i; for (;j &lt; s.size(); j++) &#123; if (s[j] == &#x27; &#x27;) break; s[j] = tolower(s[j]); &#125; if (p == s.substr(i, j - i)) &#123; if (id == -1) id = i; cnt++; &#125; i = j;\t&#125;\tif (id == -1) cout &lt;&lt; id;\telse cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; id; return 0;&#125; P2010 回文日期 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int days[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int main() &#123;\tint date1, date2, res = 0;\tcin &gt;&gt; date1 &gt;&gt; date2;\tfor (int i = 1; i &lt;=12; i++) &#123; for (int j = 1; j &lt;= days[i]; j++) &#123; int t = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10; t = t * 10000 + i * 100 + j; if (t &gt;= date1 &amp;&amp; t &lt;= date2) res++; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1012 拼数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string nums[21];bool cmp(string a, string b) &#123;\treturn a + b &gt; b + a;&#125;int main() &#123;\tint n;\tcin &gt;&gt; n;\tstring a;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i];\t&#125;\tsort(nums, nums + n, cmp);\tfor (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i];\t&#125; return 0;&#125; P5587 打字练习 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt; s, t;int main() &#123;\tstring str;\twhile(getline(cin, str)) &#123; if (str == &quot;EOF&quot;) break; string a; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;&lt;&#x27;) &#123; if (!a.empty()) a.pop_back(); &#125; else a.push_back(str[i]); &#125; s.push_back(a);\t&#125;\twhile(getline(cin, str)) &#123; if (str == &quot;EOF&quot;) break; string a; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;&lt;&#x27;) &#123; if (!a.empty()) a.pop_back(); &#125; else a.push_back(str[i]); &#125; t.push_back(a);\t&#125;\tint time, cnt = 0;\tcin &gt;&gt; time;\tfor (int i = 0; i &lt; t.size(); i++) &#123; for (int j = 0; j &lt; min(s[i].size(), t[i].size()); j++) &#123; if (s[i][j] == t[i][j]) cnt++; &#125;\t&#125;\tcout &lt;&lt; cnt * 60 / time; return 0;&#125; 函数，递归及递推 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。 P1028 数的计算 123456789101112131415#include &lt;iostream&gt;using namespace std;int nums[1001];int main() &#123;\tint n;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i / 2; j++) &#123; nums[i] += nums[j]; &#125; nums[i]++;\t&#125;\tcout &lt;&lt; nums[n]; return 0;&#125; P1036 选数 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[21], n, k, res;bool st[10000001];void dfs(int a, int start, int t) &#123;\tif (a == k) &#123; if (!st[t]) res++; return;\t&#125;\tfor (int i = start; i &lt; n; i++) &#123; dfs(a + 1, i + 1, t + nums[i]);\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; k;\tst[0] = st[1] = true;\tfor (int i = 2; i &lt; 10000001; i++) &#123; if (!st[i]) &#123; for (int j = i + i; j &lt; 10000001; j += i) st[j] = true; &#125;\t&#125;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tdfs(0, 0, 0);\tcout &lt;&lt; res; return 0;&#125; P1464 Function 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;typedef long long LL;LL dp[21][21][21];int main() &#123;\tfor (int i = 0; i &lt; 21; i++) &#123; for (int j = 0; j &lt; 21; j++) &#123; dp[0][i][j] = dp[i][0][j] = dp[i][j][0] = 1; &#125;\t&#125;\tfor (int i = 1; i &lt; 21; i++) &#123; for (int j = 1; j &lt; 21; j++) &#123; for (int k = 1; k &lt; 21; k++) &#123; if (i &lt; j &amp;&amp; j &lt; k) &#123; dp[i][j][k] = dp[i][j][k-1] + dp[i][j-1][k-1] - dp[i][j-1][k]; &#125; else &#123; dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j-1][k-1]; &#125; &#125; &#125;\t&#125;\tLL a, b, c;\twhile (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) &#123; if (a == -1 &amp;&amp; b == -1 &amp;&amp; c == -1) break; if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) printf(&quot;w(%lld, %lld, %lld) = 1 &quot;, a, b, c); else if (a &gt; 20 || b &gt; 20 || c &gt; 20) printf(&quot;w(%lld, %lld, %lld) = %lld &quot;, a, b, c, dp[20][20][20]); else printf(&quot;w(%lld, %lld, %lld) = %lld &quot;, a, b, c, dp[a][b][c]);\t&#125; return 0;&#125; P5534 【XR-3】等差数列 123456789#include &lt;iostream&gt;using namespace std;int main() &#123;\tlong long a, b, c;\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\tlong long res = c * a + c * (c - 1) * (b - a) / 2;\tcout &lt;&lt; res; return 0;&#125; P1192 台阶问题 12345678910111213141516#include &lt;iostream&gt;using namespace std;const int MOD = 100003;int dp[100001];int main() &#123;\tint n, k;\tcin &gt;&gt; n &gt;&gt; k;\tfor (int i = 1; i &lt;= k; i++) dp[i] = 1;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = i - 1; j &gt; max(i - k - 1, 0); j--) &#123; dp[i] = (dp[i] + dp[j]) % MOD; &#125;\t&#125;\tcout &lt;&lt; dp[n]; return 0;&#125; P1025 数的划分 dfs 12345678910111213141516#include &lt;iostream&gt;using namespace std;int n, k, res;void dfs(int cnt, int s, int t) &#123;\tif (cnt == k &amp;&amp; t == n) res++;\tif (cnt == k) return;\tfor (int i = s; t + i*(k - cnt) &lt;= n; i++) &#123; dfs(cnt + 1, i, t + i);\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; k;\tdfs(0, 1, 0);\tcout &lt;&lt; res; return 0;&#125; dp 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int dp[201][7];int main() &#123;\tint n, k;\tcin &gt;&gt; n &gt;&gt; k;\tfor (int i = 1; i &lt;= n; i++) &#123; dp[i][1] = 1;\t&#125;\tfor (int i = 2; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= k; j++) &#123; dp[i][j] += dp[i - 1][j - 1]; if (i &gt; j) dp[i][j] += dp[i - j][j]; &#125;\t&#125;\tcout &lt;&lt; dp[n][k]; return 0;&#125; P4994 终于结束的起点 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int fib[10000001];int main() &#123;\tint m;\tcin &gt;&gt; m;\tfib[0] = 0;\tfib[1] = 1;\tfor (int i = 2; i &lt; 10000001; i++) &#123; fib[i] = (fib[i - 1] + fib[i - 2]) % m;\t&#125;\tint res = 0;\tfor (int i = 1; i &lt; 10000000; i++) &#123; if (fib[i] == 0 &amp;&amp; fib[i + 1] == 1) &#123; res = i; break; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; 基础算法 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。 当然，这里面也有一些难度比较高的题目。 模拟 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。 这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。 P1003 铺地毯 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int gg[100001][4];int main() &#123;\tint n, a, b, g, k, x, y, res = -1;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; g &gt;&gt; k; gg[i][0] = a; gg[i][1] = a + g; gg[i][2] = b; gg[i][3] = b + k;\t&#125;\tcin &gt;&gt; x &gt;&gt; y;\tfor (int i = n; i &gt; 0; i--) &#123; if (x &gt;= gg[i][0] &amp;&amp; x &lt;= gg[i][1] &amp;&amp; y &gt;= gg[i][2] &amp;&amp; y &lt;= gg[i][3]) &#123; res = i; break; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1067 多项式输出 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main() &#123;\tint n, x;\tcin &gt;&gt; n &gt;&gt; x;\tif (n == 0) &#123; cout &lt;&lt; x; return 0;\t&#125;\tif (x &gt; 1) cout &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; n;\telse if (x == 1) cout &lt;&lt; &quot;x^&quot; &lt;&lt; n;\telse if (x == -1) cout &lt;&lt; &quot;-x^&quot; &lt;&lt; n;\telse if (x &lt; -1) cout &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; n;\tfor (int i = n - 1; i &gt; 1; i--) &#123; cin &gt;&gt; x; if (x &gt; 1) cout &lt;&lt; &quot;+&quot; &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; i; else if (x == 1) cout &lt;&lt; &quot;+x^&quot; &lt;&lt; i; else if (x == -1) cout &lt;&lt; &quot;-x^&quot; &lt;&lt; i; else if (x &lt; -1) cout &lt;&lt; x &lt;&lt; &quot;x^&quot; &lt;&lt; i;\t&#125;\tcin &gt;&gt; x;\tif (x &gt; 1) cout &lt;&lt; &quot;+&quot; &lt;&lt; x &lt;&lt; &quot;x&quot;;\telse if (x == 1) cout &lt;&lt; &quot;+x&quot;;\telse if (x == -1) cout &lt;&lt; &quot;-x&quot;;\telse if (x &lt; -1) cout &lt;&lt; x &lt;&lt; &quot;x&quot;;\tcin &gt;&gt; x;\tif (x &gt; 0) cout &lt;&lt; &quot;+&quot; &lt;&lt; x;\telse if (x &lt; 0) cout &lt;&lt; x; return 0;&#125; 优化版 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int n, x; cin &gt;&gt; n; for (int i = n; i &gt;= 0; i--) &#123; cin &gt;&gt; x; if (x) &#123; if (x &gt; 0 &amp;&amp; i != n) cout &lt;&lt; &quot;+&quot;; if (abs(x) &gt; 1 || i == 0) cout &lt;&lt; x; if (x == -1 &amp;&amp; i) cout &lt;&lt; &quot;-&quot;; if (i &gt; 1) cout &lt;&lt; &quot;x^&quot; &lt;&lt; i; if (i == 1) cout &lt;&lt; &quot;x&quot;; &#125; &#125; return 0;&#125; P1328 生活大爆炸版石头剪刀布 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int a[401], b[401];int main() &#123; int n, na, nb; cin &gt;&gt; n &gt;&gt; na &gt;&gt; nb; for (int i = 0; i &lt; na; i++) cin &gt;&gt; a[i];\tfor (int i = 0; i &lt; nb; i++) cin &gt;&gt; b[i];\tfor (int i = na; i &lt; n + na; i += na) &#123; for (int j = 0; j &lt; na; j++) a[i + j] = a[j];\t&#125;\tfor (int i = nb; i &lt; n + nb; i += nb) &#123; for (int j = 0; j &lt; nb; j++) b[i + j] = b[j];\t&#125;\tint resa = 0, resb = 0;\tfor (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i]) continue; if (a[i] == 0 &amp;&amp; b[i] == 2 || a[i] == 0 &amp;&amp; b[i] == 3 || a[i] == 1 &amp;&amp; b[i] == 0 || a[i] == 1 &amp;&amp; b[i] == 3 || a[i] == 2 &amp;&amp; b[i] == 1 || a[i] == 2 &amp;&amp; b[i] == 4 || a[i] == 3 &amp;&amp; b[i] == 2 || a[i] == 3 &amp;&amp; b[i] == 4 || a[i] == 4 &amp;&amp; b[i] == 0 || a[i] == 4 &amp;&amp; b[i] == 1) resa++; else resb++;\t&#125;\tcout &lt;&lt; resa &lt;&lt; &quot; &quot; &lt;&lt; resb &lt;&lt; endl; return 0;&#125; 优化版 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int v[5][5] = &#123;&#123;0, 0, 1, 1, 0&#125;, &#123;1, 0, 0, 1, 0&#125;, &#123;0, 1, 0, 0, 1&#125;, &#123;0, 0, 1, 0, 1&#125;, &#123;1, 1, 0, 0, 0&#125;&#125;;int a[201], b[201];int main() &#123; int n, na, nb, resa = 0, resb = 0; cin &gt;&gt; n &gt;&gt; na &gt;&gt; nb; for (int i = 0; i &lt; na; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; nb; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) &#123; resa += v[a[i % na]][b[i % nb]]; resb += v[b[i % nb]][a[i % na]];\t&#125;\tcout &lt;&lt; resa &lt;&lt; &quot; &quot; &lt;&lt; resb &lt;&lt; endl; return 0;&#125; P1563 玩具谜题 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct node&#123;\tbool flag;\tstring name;&#125; nums[100001];int main() &#123; int n, m, a, s; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i].flag &gt;&gt; nums[i].name;\tint start = 0;\tfor (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; s; if (nums[start].flag ^ a) start = (start + s) % n; else start = (start - s + n) % n;\t&#125;\tcout &lt;&lt; nums[start].name; return 0;&#125; P1042 乒乓球 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;vector&lt;pair&lt;int, int&gt; &gt; res1, res2;int main() &#123;\tstring str;\tint a = 0, b = 0, c = 0, d = 0;\tbool flag = true; while (flag &amp;&amp; getline(cin, str)) &#123; for (auto ch: str) &#123; if (ch == &#x27;W&#x27;) &#123; a++; c++; if (a &gt;= 11 &amp;&amp; a - b &gt;= 2) &#123; res1.push_back(&#123;a, b&#125;); a = 0; b = 0; &#125; if (c &gt;= 21 &amp;&amp; c - d &gt;= 2) &#123; res2.push_back(&#123;c, d&#125;); c = 0; d = 0; &#125; &#125; else if (ch == &#x27;L&#x27;) &#123; b++; d++; if (b &gt;= 11 &amp;&amp; b - a &gt;= 2) &#123; res1.push_back(&#123;a, b&#125;); a = 0; b = 0; &#125; if (d &gt;= 21 &amp;&amp; d - c &gt;= 2) &#123; res2.push_back(&#123;c, d&#125;); c = 0; d = 0; &#125; &#125; else if (ch == &#x27;E&#x27;) &#123; flag = false; break; &#125; &#125;\t&#125;\tif (a || b) res1.push_back(&#123;a, b&#125;);\telse res1.push_back(&#123;0, 0&#125;);\tif (c || d) res2.push_back(&#123;c, d&#125;);\telse res2.push_back(&#123;0, 0&#125;);\tfor (auto it: res1) cout &lt;&lt; it.first &lt;&lt; &quot;:&quot; &lt;&lt; it.second &lt;&lt; endl;\tcout &lt;&lt; endl;\tfor (auto it: res2) cout &lt;&lt; it.first &lt;&lt; &quot;:&quot; &lt;&lt; it.second &lt;&lt; endl; return 0;&#125; P1179 数字统计 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123;\tint l, r, res = 0;\tcin &gt;&gt; l &gt;&gt; r;\tfor (int i = l; i &lt;= r; i++) &#123; int t = i; while (t &gt; 1) &#123; if (t % 10 == 2) res++; t /= 10; &#125;\t&#125; cout &lt;&lt; res; return 0;&#125; P2615 神奇的幻方 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int nums[40][40];int main() &#123;\tint n;\tcin &gt;&gt; n;\tnums[0][n/2] = 1;\tfor (int i = 2; i &lt;= n * n; i++) &#123; bool flag = false; int j = 0, k = 0; for (j = 0; j &lt; n; j++) &#123; for (k = 0; k &lt; n; k++) &#123; if (nums[j][k] == i - 1) &#123; flag = true; break; &#125; &#125; if (flag) break; &#125; if (j == 0 &amp;&amp; k != n-1) nums[n-1][k+1] = i; if (j != 0 &amp;&amp; k == n-1) nums[j-1][0] = i; if (j == 0 &amp;&amp; k == n-1) nums[1][k] = i; if (j != 0 &amp;&amp; k != n-1) &#123; if (nums[j-1][k+1]) nums[j+1][k] = i; else nums[j-1][k+1] = i; &#125;\t&#125;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; nums[i][j]; if (j != n - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125;\t&#125; return 0;&#125; P3952 时间复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool st[101][256], isin[101];int main() &#123;\tint t, n, com;\tstring O, x, y;\tchar op, val;\tcin &gt;&gt; t;\tfor (int i = 0; i &lt; t; i++) &#123; fill(st[0], st[0] + 101 * 256, false); fill(isin, isin + 101, false); bool flag = true, flag2 = true; cin &gt;&gt; n &gt;&gt; O; if (O[2] == &#x27;1&#x27;) com = 0; else com = stoi(O.substr(4)); int cnt = 0, maxn = 0, cur = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; op; if (op == &#x27;F&#x27;) &#123; cnt++; cin &gt;&gt; val &gt;&gt; x &gt;&gt; y; for (int j = 0; j &lt; cnt; j++) &#123; if (st[j][val]) &#123; flag = false; break; &#125; &#125; st[cnt][val] = true; if (x != &quot;n&quot; &amp;&amp; y == &quot;n&quot; ) &#123; bool flag3 = true; cur++; for (int j = 0; j &lt; cnt; j++) &#123; if (isin[j]) &#123; flag3 = false; break; &#125; &#125; if (flag3) maxn = max(maxn, cur); &#125; else if (x == &quot;n&quot; &amp;&amp; y != &quot;n&quot; || x != &quot;n&quot; &amp;&amp; y != &quot;n&quot; &amp;&amp; stoi(x) &gt; stoi(y)) &#123; isin[cnt] = true; &#125; &#125; else if (op == &#x27;E&#x27;) &#123; isin[cnt] = false; for (int i = 0; i &lt; 256; i++) st[cnt][i] = false; cnt--; if (cnt &lt; 0) &#123; flag = false; cnt = 0; &#125; cur--; if (cur &lt; 0) cur = 0; &#125; &#125; if (!flag || cnt != 0) cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; else if (maxn == com) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;\t&#125; return 0;&#125; 排序算法 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。 P1177 【模板】快速排序 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];void quick_sort(int l, int r) &#123;\tif (l &gt;= r) return;\tint i = l - 1, j = r + 1, t = nums[l + r &gt;&gt; 1];\twhile (i &lt; j) &#123; do i++; while (nums[i] &lt; t); do j--; while (nums[j] &gt; t); if (i &lt; j) swap(nums[i], nums[j]);\t&#125;\tquick_sort(l, j);\tquick_sort(j + 1, r);&#125;int main() &#123;\tint n;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tquick_sort(0, n - 1);\tfor (int i = 0; i &lt; n; i++) cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;; return 0;&#125; P1059 明明的随机数 12345678910111213141516#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; nums;int main() &#123;\tint n, x;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; nums.insert(x);\t&#125;\tcout &lt;&lt; nums.size() &lt;&lt; endl;\tfor (auto it: nums) cout &lt;&lt; it &lt;&lt; &quot; &quot;; return 0;&#125; P1068 分数线划定 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tint num, score;&#125; nums[5001];bool cmp(node &amp;a, node &amp;b) &#123;\tif (a.score != b.score) return a.score &gt; b.score;\treturn a.num &lt; b.num;&#125;int main() &#123;\tint n, m;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i].num &gt;&gt; nums[i].score;\tsort(nums, nums + n, cmp);\tint t = m * 1.5;\twhile (t &lt; n) &#123; if (nums[t].score == nums[t-1].score) t++; else break;\t&#125;\tcout &lt;&lt; nums[t - 1].score &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; endl;\tfor (int i = 0; i &lt; t; i++) &#123; cout &lt;&lt; nums[i].num &lt;&lt; &quot; &quot; &lt;&lt; nums[i].score &lt;&lt; endl;\t&#125; return 0;&#125; P1051 谁拿了最多奖学金 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tstring name;\tint score1, score2, paper, money;\tchar ganbu, poor;&#125; nums[101];bool cmp(const node &amp;a, const node &amp;b) &#123;\treturn a.money &gt; b.money;&#125;int main() &#123;\tint n, sum = 0;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; int money = 0; cin &gt;&gt; nums[i].name &gt;&gt; nums[i].score1 &gt;&gt; nums[i].score2 &gt;&gt; nums[i].ganbu &gt;&gt; nums[i].poor &gt;&gt; nums[i].paper; if (nums[i].score1 &gt; 80 &amp;&amp; nums[i].paper &gt;= 1) money += 8000; if (nums[i].score1 &gt; 85 &amp;&amp; nums[i].score2 &gt; 80) money += 4000; if (nums[i].score1 &gt; 90) money += 2000; if (nums[i].score1 &gt; 85 &amp;&amp; nums[i].poor == &#x27;Y&#x27;) money += 1000; if (nums[i].score2 &gt; 80 &amp;&amp; nums[i].ganbu == &#x27;Y&#x27;) money += 850; nums[i].money = money; sum += money;\t&#125;\tstable_sort(nums, nums + n, cmp);\tcout &lt;&lt; nums[0].name &lt;&lt; &quot; &quot; &lt;&lt; nums[0].money &lt;&lt; &quot; &quot; &lt;&lt; sum; return 0;&#125; P1309 瑞士轮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tint num, v, score;&#125; nums[200001], a[100001], b[100001];bool cmp(const node &amp;a, const node &amp;b) &#123;\tif (a.score != b.score) return a.score &gt; b.score;\telse return a.num &lt; b.num;&#125;int n;void merge() &#123;\tint id = 0, i = 0, j = 0;\twhile (i &lt; n &amp;&amp; j &lt; n) &#123; if (a[i].score &gt; b[j].score || a[i].score == b[j].score &amp;&amp; a[i].num &lt; b[j].num) nums[id++] = a[i++]; else nums[id++] = b[j++];\t&#125;\twhile (i &lt; n) nums[id++] = a[i++];\twhile (j &lt; n) nums[id++] = b[j++];&#125;int main() &#123;\tint r, q;\tscanf(&quot;%d %d %d&quot;, &amp;n, &amp;r, &amp;q);\tfor (int i = 0; i &lt; 2 * n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i].score); nums[i].num = i + 1;\t&#125;\tfor (int i = 0; i &lt; 2 * n; i++) scanf(&quot;%d&quot;, &amp;nums[i].v);\tsort(nums, nums + 2 * n, cmp);\tfor (int i = 0; i &lt; r; i++) &#123; int t = 0; for (int j = 0; j &lt; 2 * n; j += 2) &#123; if (nums[j].v &gt; nums[j+1].v) &#123; nums[j].score++; a[t] = nums[j]; b[t++] = nums[j+1]; &#125; else &#123; nums[j+1].score++; a[t] = nums[j+1]; b[t++] = nums[j]; &#125; &#125; merge();\t&#125;\tprintf(&quot;%d&quot;, nums[q - 1].num); return 0;&#125; P1908 逆序对 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[500001];long long res;void merge_sort(int l, int r) &#123;\tif (l &gt;= r) return;\tint mid = l + r &gt;&gt; 1;\tmerge_sort(l, mid);\tmerge_sort(mid + 1, r);\tvector&lt;int&gt; t;\tint i = l, j = mid + 1;\twhile (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (nums[i] &lt;= nums[j]) t.push_back(nums[i++]); else &#123; res += mid - i + 1; t.push_back(nums[j++]); &#125;\t&#125;\twhile (i &lt;= mid) t.push_back(nums[i++]);\twhile (j &lt;= r) t.push_back(nums[j++]);\tfor (int k = l; k &lt;= r; k++) nums[k] = t[k - l];&#125;int main() &#123;\tint n;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i];\t&#125;\tmerge_sort(0, n - 1);\tcout &lt;&lt; res;\treturn 0;&#125; 二分答案 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。 P1024 一元三次方程求解 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;double a, b, c, d, nums[201];double f(double x) &#123;\treturn a * x * x * x + b * x * x + c * x + d;&#125;void check(double l, double r, bool flag) &#123;\twhile (r - l &gt; 1e-6) &#123; double mid = (l + r) / 2; if (flag) &#123; if (f(mid) &gt; 0) r = mid; else l = mid; &#125; else &#123; if (f(mid) &lt; 0) r = mid; else l = mid; &#125;\t&#125;\tprintf(&quot;%.2f &quot;, l);&#125;int main() &#123;\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\tdouble i = -100;\tbool flag = false, flag2 = true;\tif (f(-100) &lt; 0) flag = true;\twhile (i &lt;= 100) &#123; if (flag2) &#123; if (f(i) * f(-100) &lt; 0) &#123; check(i - 0.5, i, flag); flag2 = false; &#125; &#125; else &#123; if (f(i) * f(-100) &gt; 0) &#123; check(i - 0.5, i, !flag); flag2 = true; &#125; &#125; i += 0.5;\t&#125;\treturn 0;&#125; P2678 跳石头 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int l, n, m, nums[50005], res;bool check(int x) &#123;\tint cnt = 0, now = 0;\tfor (int i = 1; i &lt;= n+1; i++) &#123; if (nums[i] - nums[now] &lt; x) cnt++; else now = i;\t&#125;\tif (cnt &gt; m) return false;\treturn true;&#125;int main() &#123;\tcin &gt;&gt; l &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; nums[i];\tnums[n+1] = l;\tint i = 1, j = l;\twhile (i &lt; j) &#123; int mid = i + j + 1 &gt;&gt; 1; if (check(mid)) i = mid; else j = mid - 1;\t&#125;\tcout &lt;&lt; i;\treturn 0;&#125; P1902 刺杀大使 dfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = &#123;-1, 1, 0, 0&#125;, dy[4] = &#123;0, 0, -1, 1&#125;;bool visit[1005][1005], flag;void dfs(int a, int b) &#123;\tif (a == n - 1) &#123; flag = true; return;\t&#125;\tfor (int i = 0; i &lt; 4; i++) &#123; x = a + dx[i], y = b + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !visit[x][y] &amp;&amp; g[x][y] &lt;= mid) &#123; visit[x][y] = true; dfs(x, y); visit[x][y] = false; if (flag) return; &#125;\t&#125;&#125;bool check() &#123;\tflag = false;\tmemset(visit, false, sizeof(visit));\tdfs(0, 0);\treturn flag;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tint l = 1000, r = 0;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); &#125;\t&#125;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check()) r = mid; else l = mid + 1;\t&#125;\tcout &lt;&lt; r;\treturn 0;&#125; bfs 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = &#123;-1, 1, 0, 0&#125;, dy[4] = &#123;0, 0, -1, 1&#125;;bool visit[1005][1005];bool bfs() &#123;\tmemset(visit, false, sizeof(visit));\tqueue&lt;pair&lt;int, int&gt; &gt; q;\tq.push(&#123;0, 0&#125;);\twhile (!q.empty()) &#123; int a = q.front().first, b = q.front().second; q.pop(); for (int i = 0; i &lt; 4; i++) &#123; x = a + dx[i], y = b + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !visit[x][y] &amp;&amp; g[x][y] &lt;= mid) &#123; q.push(&#123;x, y&#125;); visit[x][y] = true; if (x == n - 1) return true; &#125; &#125;\t&#125;\treturn false;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tint l = 1000, r = 0;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); &#125;\t&#125;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (bfs()) r = mid; else l = mid + 1;\t&#125;\tcout &lt;&lt; r;\treturn 0;&#125; P1314 聪明的质监员 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;typedef long long LL;LL s, res = 1e12, t;int n, m, w[200005], v[200005], sums[200005], cnts[200005], q[200005][2], mid;bool check() &#123;\tt = 0;\tfor (int i = 1; i &lt;= n; i++) &#123; if (w[i-1] &gt;= mid) &#123; sums[i] = sums[i-1] + v[i-1]; cnts[i] = cnts[i-1] + 1; &#125; else &#123; sums[i] = sums[i-1]; cnts[i] = cnts[i-1]; &#125;\t&#125;\tfor (int k = 0; k &lt; m; k++) &#123; int l = q[k][0], r = q[k][1]; t += (cnts[r] - cnts[l-1]) * (sums[r] - sums[l-1]);\t&#125;\tres = min(res, abs(t-s));\tif (t &gt; s) return true;\treturn false;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];\tfor (int i = 0; i &lt; m; i++) cin &gt;&gt; q[i][0] &gt;&gt; q[i][1];\tint l = 1, r = 1e6;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check()) l = mid + 1; else r = mid; &#125;\tcout &lt;&lt; res &lt;&lt; endl;\treturn 0;&#125; P1083 借教室 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;long long n, m, w[1000005], d[1000005], s[1000006], t[1000005], diff[1000005], nums[1000005], mid;bool check() &#123;\tfill(diff, diff + 1000005, 0);\tfor (int i = 1; i &lt;= mid; i++) &#123; diff[s[i]] += d[i]; diff[t[i] + 1] -= d[i];\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; nums[i] = nums[i - 1] + diff[i]; if (nums[i] &gt; w[i]) return false;\t&#125; return true;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i];\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; d[i] &gt;&gt; s[i] &gt;&gt; t[i];\tint l = 1, r = n + 1;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check()) l = mid + 1; else r = mid; &#125;\tif (r &gt; n) cout &lt;&lt; 0;\telse cout &lt;&lt; &quot;-1 &quot; &lt;&lt; l &lt;&lt; endl;\treturn 0;&#125; P4343 自动刷题机 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;typedef long long LL;LL n, m, mid, nums[100005];LL check() &#123;\tLL cnt = 0, t = 0;\tfor (int i = 0; i &lt; n; i++) &#123; t += nums[i]; t = max&lt;LL&gt;(0, t); if (t &gt;= mid) &#123; t = 0; cnt++; &#125;\t&#125;\treturn cnt;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tLL l = 1, r = 1e18;\twhile (l &lt; r) &#123; mid = l + r &gt;&gt; 1; if (check() &gt; m) l = mid + 1; else r = mid; &#125;\tmid = l;\tif (check() != m) &#123; cout &lt;&lt; -1; return 0;\t&#125;\tcout &lt;&lt; l &lt;&lt; &quot; &quot;;\tr = 1e18;\twhile (l &lt; r) &#123; mid = l + r + 1&gt;&gt; 1; if (check() &lt; m) r = mid - 1; else l = mid; &#125;\tcout &lt;&lt; r;\treturn 0;&#125; 分治 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。 P1226 快速幂||取余运算 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a, int b, int p) &#123;\tLL res = 1, t = a;\twhile (b) &#123; if (b &amp; 1) res = (res * t) % p; t = (t * t) % p; b &gt;&gt;= 1;\t&#125;\tres %= p;\treturn res;&#125;int main() &#123; LL a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; printf(&quot;%d^%d mod %d=%d&quot;, a, b, p, qmi(a, b, p)); return 0;&#125; P1010 幂次方 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void fun(int x) &#123;\twhile (x &gt;= 1) &#123; int t = 1, cnt = 0; do &#123; t *= 2; cnt++; &#125; while (x &gt;= t); int a = cnt - 1; if (a == 0) cout &lt;&lt; &quot;2(0)&quot;; else if (a == 1) cout &lt;&lt; &quot;2&quot;; else &#123; cout &lt;&lt; &quot;2(&quot;; fun(a); cout &lt;&lt; &quot;)&quot;; &#125; x -= t / 2; if (x != 0) cout &lt;&lt; &quot;+&quot;;\t&#125;&#125;int main() &#123; int n; cin &gt;&gt; n; fun(n); return 0;&#125; P1429 平面最近点对（加强版） 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;vector&lt;vector&lt;LL&gt;&gt; nums;bool cmp(vector&lt;LL&gt; &amp;a, vector&lt;LL&gt; &amp;b) &#123;\treturn a[2] &lt; b[2];&#125;int main() &#123; int n, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums.push_back(&#123;a, b, a + b&#125;);\t&#125;\tsort(nums.begin(), nums.end(), cmp);\tLL res = 1e12;\tfor (int i = 1; i &lt; n; i++) &#123; for (int k = 1; k &lt; 5; k++) &#123; int j = i - k; if (j &lt; 0) break; res = min((nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]), res); &#125;\t&#125;\tprintf(&quot;%.4f&quot;, sqrt(res)); return 0;&#125; P3612 Secret Cow Code 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;int main() &#123; string str; LL n, i; cin &gt;&gt; str &gt;&gt; n; while (n &gt; str.size()) &#123; i = str.size(); while (n &gt; i) i *= 2; i /= 2; n -= (i + 1); if (n == 0) n = i; cout &lt;&lt; n &lt;&lt; endl;\t&#125;\tcout &lt;&lt; str[n - 1]; return 0;&#125; 贪心 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。 P1208 Mixing Milk 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef pair&lt;int, int&gt; PII;PII nums[5005];int main() &#123; int n, m, price, cnt; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; nums[i].first &gt;&gt; nums[i].second;\tsort(nums, nums + m);\tint res = 0, id = 0;\twhile (n &gt; 0) &#123; if (n &gt;= nums[id].second) &#123; res += nums[id].first * nums[id].second; n -= nums[id].second; &#125; else &#123; res += n * nums[id].first; n = 0; &#125; id++;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P4995 跳跳！ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;int nums[305];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tsort(nums, nums + n);\tLL res = 0;\tint l = 0, r = n - 1, cur = 0;\twhile (l &lt; r) &#123; res += (nums[r] - cur) * (nums[r] - cur); cur = nums[r--]; if (l == r) &#123; res += (nums[r] - cur) * (nums[r] - cur);; break; &#125; res += (nums[l] - cur) * (nums[l] - cur); cur = nums[l++]; if (l == r) &#123; res += (nums[l] - cur) * (nums[l] - cur);; break; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1094 纪念品分组 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[30005];int main() &#123; int w, n; cin &gt;&gt; w &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i];\tsort(nums, nums + n);\tint res = 0, l = 0, r = n - 1;\twhile (l &lt;= r) &#123; if (nums[r] + nums[l] &gt; w) &#123; res++; r--; &#125; else &#123; res++; r--; l++; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P1199 三国游戏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123;\tint val, row, col;&#125; nums[250005];bool st[505], you[505];int res;bool cmp(node &amp;a, node &amp;b) &#123;\treturn a.val &lt; b.val;&#125;void dfs(int x) &#123;\tif (nums[x].val &lt; res) return;\tif (you[nums[x].row] &amp;&amp; !st[nums[x].col] || you[nums[x].col] &amp;&amp; !st[nums[x].row]) &#123; res = max(res, nums[x].val); return;\t&#125;\tif (!st[nums[x].row]) &#123; st[nums[x].col] = true; st[nums[x].row] = true; you[nums[x].row] = true; dfs(x - 1); st[nums[x].col] = false; st[nums[x].row] = false; you[nums[x].row] = false;\t&#125;\tif (!st[nums[x].col]) &#123; st[nums[x].row] = true; st[nums[x].col] = true; you[nums[x].col] = true; dfs(x - 1); st[nums[x].row] = false; st[nums[x].col] = false; you[nums[x].col] = false;\t&#125;&#125;int main() &#123; int n, id = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; cin &gt;&gt; nums[id].val; nums[id].row = i; nums[id++].col = j; &#125; &#125; sort(nums, nums + id, cmp); dfs(id - 1); cout &lt;&lt; &quot;1 &quot; &lt;&lt; res; return 0;&#125; P2672 推销员 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum[100005], q[100005], h[100005];struct node &#123;\tint dist, fatigue;&#125; v[100005];bool cmp(node &amp;a, node &amp;b) &#123;\treturn a.fatigue &gt; b.fatigue;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i].dist; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i].fatigue; sort(v + 1, v + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + v[i].fatigue; for (int i = 1; i &lt;= n; i++) q[i] = max(q[i - 1], 2 * v[i].dist); for (int i = n; i &gt;= 1; i--) h[i] = max(h[i + 1], 2 * v[i].dist + v[i].fatigue); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; max(sum[i] + q[i], sum[i - 1] + h[i]) &lt;&lt; endl; return 0;&#125; P1080 国王游戏 没有用高精度（60分） 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;struct node &#123;\tint l, r;\tdouble t;&#125; v[10005];bool cmp(node &amp;a, node &amp;b) &#123;\treturn a.l * a.r &lt; b.l * b.r;&#125;int main() &#123; LL n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v[i].l &gt;&gt; v[i].r; v[i].t = (double)v[i].l / v[i].r;\t&#125; sort(v, v + n, cmp); LL res = 0, cur = a; for (int i = 0; i &lt; n; i++) &#123; res = max(res, (LL)a / v[i].r); a *= v[i].l;\t&#125;\tcout &lt;&lt; res; return 0;&#125; 构造 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。 P5595 歌唱比赛 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string str, res1 = &quot;&quot;, res2 = &quot;&quot;; cin &gt;&gt; str; int cnt = 0; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;Z&#x27;) &#123; for (int j = i + 1; j &lt; str.size(); j++) &#123; if (str[j] != &#x27;Z&#x27;) &#123; cout &lt;&lt; -1; return 0; &#125; &#125; break; &#125;\t&#125;\tfor (int i = str.size() - 1; i &gt;= 0; i--) &#123; if (str[i] == &#x27;Z&#x27;) &#123; res1 += &#x27;0&#x27;; res2 += &#x27;0&#x27;; &#125; else if (str[i] == &#x27;Y&#x27;) &#123; res1 += &#x27;0&#x27;; res2 += &#x27;1&#x27;; &#125; else if (str[i] == &#x27;X&#x27;) &#123; res1 += &#x27;1&#x27;; res2 += &#x27;0&#x27;; &#125;\t&#125;\treverse(res1.begin(), res1.end());\treverse(res2.begin(), res2.end());\tcout &lt;&lt; res1 &lt;&lt; &quot; &quot; &lt;&lt; res2; return 0;&#125; 高精度 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！ P1601 A+B Problem（高精） 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a, b, c; cin &gt;&gt; a &gt;&gt; b; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); if (a.size() &lt; b.size()) swap(a, b); int t = 0, i = 0; for (; i &lt; b.size(); i++) &#123; c += ((a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t) % 10) + &#x27;0&#x27;; t = (a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t) / 10;\t&#125;\tfor (; i &lt; a.size(); i++) &#123; c += ((a[i] - &#x27;0&#x27; + t) % 10) + &#x27;0&#x27;; t = (a[i] - &#x27;0&#x27; + t) / 10;\t&#125;\tif (t) c += &#x27;1&#x27;;\treverse(c.begin(), c.end());\tcout &lt;&lt; c; return 0;&#125; P2142 高精度减法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a, b, c; cin &gt;&gt; a &gt;&gt; b; if (a == b) &#123; cout &lt;&lt; &quot;0&quot;; return 0;\t&#125; if (a.size() &lt; b.size()) &#123; int e = b.size() - a.size(); for (int i = 0; i &lt; e; i++) a = &#x27;0&#x27; + a;\t&#125; else if (a.size() &gt; b.size()) &#123; int e = a.size() - b.size(); for (int i = 0; i &lt; e; i++) b = &#x27;0&#x27; + b;\t&#125; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] + &#x27;0&#x27; &lt; b[i] + &#x27;0&#x27;) &#123; swap(a, b); cout &lt;&lt; &quot;-&quot;; break; &#125; else if (a[i] + &#x27;0&#x27; &gt; b[i] + &#x27;0&#x27;) &#123; break; &#125;\t&#125;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; int d = a[i] - b[i] - t; if (d &lt; 0) &#123; c += ((d + 10) % 10) + &#x27;0&#x27;; t = 1; &#125; else &#123; c += (d % 10) + &#x27;0&#x27;; t = 0; &#125;\t&#125;\treverse(c.begin(), c.end());\twhile (c[0] == &#x27;0&#x27;) c.erase(c.begin());\tcout &lt;&lt; c; return 0;&#125; P1303 A*B Problem 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int c[40005];int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; if (a[0] == &#x27;0&#x27; || b[0] == &#x27;0&#x27;) &#123; cout &lt;&lt; 0; return 0;\t&#125;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i &lt; b.size(); i++) &#123; for (int j = 0; j &lt; a.size(); j++) &#123; c[i+j] += (a[j] - &#x27;0&#x27;) * (b[i] - &#x27;0&#x27;); &#125;\t&#125; for (int i = 0; i &lt; a.size() + b.size() - 1; i++) &#123; c[i] += t; if (c[i] &gt;= 10) &#123; t = c[i] / 10; c[i] %= 10; &#125; else t = 0;\t&#125;\tif (t) &#123; c[a.size() + b.size() - 1] = t; for (int i = a.size() + b.size() - 1; i &gt;= 0; i--) cout &lt;&lt; c[i];\t&#125; else &#123; for (int i = a.size() + b.size() - 2; i &gt;= 0; i--) cout &lt;&lt; c[i];\t&#125; return 0;&#125; P1480 A&#x2F;B Problem 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a, c; int b; cin &gt;&gt; a &gt;&gt; b; long long t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t = t * 10 + a[i] - &#x27;0&#x27;; c += (t / b) + &#x27;0&#x27;; t -= t / b * b;\t&#125; while (c[0] == &#x27;0&#x27;) c.erase(c.begin()); if (c.size()) cout &lt;&lt; c; else cout &lt;&lt; &quot;0&quot;; return 0;&#125; P1009 阶乘之和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string s[51], fac[51];string mul(string a, int b) &#123;\tstring c;\tint t = 0;\treverse(a.begin(), a.end());\tfor (int i = 0; i &lt; a.size(); i++) &#123; int d = (a[i] - &#x27;0&#x27;) * b + t; c += (d % 10) + &#x27;0&#x27;; if (d &gt;= 10) t = d / 10; else t = 0;\t&#125;\tif (t) &#123; string e = to_string(t); reverse(e.begin(), e.end()); c += e;\t&#125;\treverse(c.begin(), c.end());\treturn c;&#125;string add(string a, string b) &#123;\tstring c;\tint t = 0, i = 0;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end());\tfor (; i &lt; a.size(); i++) &#123; int d = a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t; c += (d % 10) + &#x27;0&#x27;; if (d &gt;= 10) t = 1; else t = 0;\t&#125;\tfor (; i &lt; b.size(); i++) &#123; int d = b[i] - &#x27;0&#x27; + t; c += (d % 10) + &#x27;0&#x27;; if (d &gt;= 10) t = 1; else t = 0;\t&#125;\tif (t) c += &#x27;1&#x27;;\treverse(c.begin(), c.end());\treturn c;&#125;int main() &#123; int n; cin &gt;&gt; n; s[1] = fac[1] = &quot;1&quot;; for (int i = 2; i &lt;= n; i++) &#123; fac[i] = mul(fac[i - 1], i); s[i] = add(s[i - 1], fac[i]);\t&#125;\tcout &lt;&lt; s[n]; return 0;&#125; 前缀和 &amp; 差分 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。 P3131 Subsequences Summing to Sevens 暴力（96分） 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef long long LL;LL sums[50005];int main() &#123; int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; sums[i] = sums[i - 1] + x;\t&#125;\tint res = 0;\tfor (int i = 1; i &lt;= n - res; i++) &#123; for (int j = i + res; j &lt;= n; j++) &#123; if ((sums[j] - sums[i - 1]) % 7 == 0) res = j - i + 1; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; 技巧 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int sums[50005], l[7], r[7];int main() &#123; int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; sums[i] = (sums[i - 1] + x) % 7;\t&#125; for (int i = n; i &gt;= 1; i--) l[sums[i]] = i;\tl[0] = 0;\tfor (int i = 1; i &lt;= n; i++) r[sums[i]] = i;\tint res = 0;\tfor (int i = 0; i &lt; 7; i++) res = max(res, r[i] - l[i]);\tcout &lt;&lt; res; return 0;&#125; P1387 最大正方形 dp 12345678910111213141516#include &lt;iostream&gt;using namespace std;int g[105][105], dp[105][105];int main() &#123; int n, m, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; g[i][j]; if (g[i][j] != 0) dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; res = max(res, dp[i][j]); &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; 前缀和+二分 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int g[105][105] = &#123;0&#125;, dp[105][105];int main() &#123; int n, m, x, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; x; g[i][j] = g[i-1][j] + g[i][j-1] - g[i-1][j-1] + x; &#125;\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int l = 0, r = min(n, m); while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (i + mid &gt; n || j + mid &gt; m || g[i + mid][j+mid] - g[i+mid][j] - g[i][j+mid] + g[i][j] &lt; mid * mid) r = mid - 1; else l = mid; &#125; if (g[i+r][j+r] - g[i+r][j] - g[i][j+r] + g[i][j] == r*r) res = max(res, r); &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P3397 地毯 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int g[1005][1005], res[1005][1005];int main() &#123; int n, m, x1, y1, x2, y2; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; g[x1][y1] += 1; g[x2+1][y1] -= 1; g[x1][y2+1] -= 1; g[x2+1][y2+1] += 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; g[i][j] += g[i-1][j] + g[i][j-1] - g[i-1][j-1]; cout &lt;&lt; g[i][j]; if (j &lt; n) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125;\t&#125; return 0;&#125; P2280 激光炸弹 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int g[5005][5005], res;int main() &#123; int n, m, x, y, v; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; g[x+1][y+1] += v;\t&#125;\tfor (int i = 1; i &lt; 5005; i++) &#123; for (int j = 1; j &lt; 5005; j++) g[i][j] += g[i][j - 1] + g[i - 1][j] - g[i - 1][j - 1];\t&#125;\tfor (int i = m; i &lt; 5005; i++) &#123; for (int j = m; j &lt; 5005; j++) res = max(res, g[i][j] - g[i][j - m] - g[i - m][j] + g[i - m][j - m]);\t&#125;\tcout &lt;&lt; res; return 0;&#125; P4552 IncDec Sequence 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef long long LL;int a[100005];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i];\t&#125;\tLL p = 0, q = 0;\tfor (int i = 2; i &lt;= n; i++) &#123; int c = a[i] - a[i - 1]; if (c &gt; 0) p += c; else q -= c;\t&#125;\tLL res1 = max(p, q);\tLL res2 = abs(p - q) + 1;\tcout &lt;&lt; res1 &lt;&lt; &quot; &quot; &lt;&lt; res2; return 0;&#125; 搜索 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。 深度优先搜索 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。 深度优先搜索一般使用栈来实现。 P1219 八皇后 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool col[14], dg[28], udg[28];int n, cnt = 0;vector&lt;int&gt; res;void dfs(int u) &#123;\tif (u == n) &#123; if (cnt &lt; 3) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; cnt++; return;\t&#125;\tfor (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; col[i] = dg[u + i] = udg[n - u + i] = true; if (cnt &lt; 3) res.push_back(i + 1); dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; if (cnt &lt; 3) res.pop_back(); &#125;\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n;\tdfs(0);\tcout &lt;&lt; cnt; return 0;&#125; P1019 单词接龙 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt; #include &lt;map&gt;using namespace std;int n, res;map&lt;string, int&gt; st;string strs[21], str;void dfs(string t) &#123;\tres = max(res, (int)t.size());\tfor (int i = 0; i &lt; n; i++) &#123; if (st[strs[i]] &gt; 0) &#123; int size = min(t.size(), strs[i].size()); for (int k = 1; k &lt; size; k++) &#123; bool flag = true; for (int p = 1; p &lt;= k; p++) &#123; if (t[t.size() - p] != strs[i][k - p]) &#123; flag = false; break; &#125; &#125; if (flag) &#123; st[strs[i]]--; dfs(t + strs[i].substr(k)); st[strs[i]]++; break; &#125; &#125; &#125;\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str; st[str] = 2; strs[i] = str;\t&#125;\tcin &gt;&gt; str;\tfor (int i = 0; i &lt; n; i++) &#123; if (str[0] == strs[i][0]) &#123; st[strs[i]]--; dfs(strs[i]); st[strs[i]]++; &#125;\t&#125;\tcout &lt;&lt; res; return 0;&#125; P5194 USACO05DEC]Scales P5440 【XR-2】奇迹 P1378 油滴扩展 广度优先搜索 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。 广度优先搜索一般使用队列来实现。 P1162 填涂颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef pair&lt;int, int&gt; PII;bool visit[32][32];int g[32][32], n;int dx[5] = &#123;0, 0, 1, -1, 0&#125;;int dy[5] = &#123;1, -1, 0, 0, 0&#125;;vector&lt;PII&gt; res;bool bfs(int x, int y) &#123;\tqueue&lt;PII&gt; q;\tq.push(&#123;x, y&#125;);\tbool flag = true;\twhile (!q.empty()) &#123; auto u = q.front(); q.pop(); x = u.first, y = u.second; res.push_back(&#123;x, y&#125;); for (int i = 0; i &lt; 5; i++) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; !visit[a][b] &amp;&amp; g[a][b] == 0) &#123; if ((a == 1 || a == n || b == 1 || b == n) &amp;&amp; g[a][b] == 0) flag = false; visit[a][b] = true; q.push(&#123;a, b&#125;); &#125; &#125;\t&#125;\treturn flag;&#125;int main() &#123;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; &#125;\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (!visit[i][j] &amp;&amp; g[i][j] == 0) &#123; res.clear(); if (bfs(i, j)) &#123; for (int k = 0; k &lt; res.size(); k++) g[res[k].first][res[k].second] = 2; &#125; &#125; &#125;\t&#125;\tfor (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) cout &lt;&lt; g[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;\t&#125; return 0;&#125; P1443 马的遍历 P3956 棋盘 P1032 字串变换 P1126 机器人搬重物 记忆化搜索 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。 动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。 P1514 引水入城 P1535 游荡的奶牛 [P1434 SHOI2002]滑雪 P3953 逛公园 搜索的剪枝 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。 P1120 小木棍 ［数据加强版］ P1312 Mayan游戏 P1074 靶形数独 动态规划 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。 线性动态规划 线性动态规划，即具有线性阶段划分的动态规划。 P1216 数字三角形 P1020 导弹拦截 P1091 合唱队形 P1095 守望者的逃离 P1541 乌龟棋 P1868 饥饿的奶牛 P2679 子串 P2501 HAOI2006]数字序列 P3336 ZJOI2013]话旧 P3558 POI2013]BAJ-Bytecomputer P4158 SCOI2009]粉刷匠 P5301 GXOI&#x2F;GZOI2019]宝牌一大堆 背包动态规划 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。 P1048 采药 P1060 开心的金明 P1855 榨取kkksc03 P5020 货币系统 P1757 通天之分组背包 P1064 金明的预算方案 P2946 USACO09MAR]Cow Frisbee Team P1156 垃圾陷阱 P5322 BJOI2019]排兵布阵 P5289 十二省联考2019]皮配 区间动态规划 区间动态规划一般以区间作为动态规划的阶段。 P1880 NOI1995]石子合并 P3146 USACO16OPEN]248 P1063 能量项链 P1005 矩阵取数游戏 P4170 CQOI2007]涂色 P4302 SCOI2003]字符串折叠 P2466 SDOI2008]Sue的小球 Part 4.4 树形动态规划 树形动态规划，即在树上进行的动态规划。 因为树的递归性质，树形动态规划一般都是递归求解的。 P1352 没有上司的舞会 P1040 加分二叉树 P1122 最大子树和 P1273 有线电视网 P2014 选课 P2585 ZJOI2006]三色二叉树 P3047 USACO12FEB]Nearby Cows P3698 CQOI2017]小Q的棋盘 P5658 括号树 P2607 ZJOI2008]骑士 P3177 HAOI2015]树上染色 P4395 BOI2003]Gem P4516 JSOI2018]潜入行动 字符串 字符串问题有很多自己的特点。 字符串哈希 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。 P3370 【模板】字符串哈希 P5270 无论怎样神树大人都会删库跑路 P5537 【XR-3】系统设计 Part 5.2 KMP KMP 算法可以用来解决模式串匹配问题。 P3375 【模板】KMP字符串匹配 P4391 BOI2009]Radio Transmission P3435 POI2006]OKR-Periods of Words P4824 USACO15FEB]Censoring (Silver) P2375 NOI2014]动物园 P3426 POI2005]SZA-Template P3193 HNOI2008]GT考试 数学 OI 中的数学知识很多，也有些杂乱。 位运算 将十进制整数转换为二进制后，有很多按位运算的运算符。 如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。 P5657 格雷码 P5514 MtOI2019永夜的报应 P5538 【XR-3】NamidAme P5539 【XR-3】Unknown Mother-Goose P5523 yLOI2019珍珠 整除相关 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。 素数 素数，指的是除 1 和它本身之外没有其他约数的数。 P4718 【模板】Pollard-Rho算法 P1075 质因数分解 P2441 角色属性树 P5535 【XR-3】小道消息 最大公约数 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。 求解两个数的最大公约数，可以采用欧几里得算法解决。 P5435 【模板】快速 GCD P5436 【XR-2】缘分 P1029 最大公约数和最小公倍数问题 P1414 又是毕业季II P2152 SDOI2009]SuperGCD P1072 Hankson 的趣味题 欧拉函数 欧拉函数 表示了小于 的数字中，与 互质的数字个数。 P2158 SDOI2008仪仗队 P2568 GCD P2398 GCD SUM P4139 上帝与集合的正确用法 同余方程 求解同余方程往往可以引出不少话题。 线性同余方程&amp;乘法逆元 线性同余方程是同余方程中最基础的内容。 P4549 【模板】裴蜀定理 P2613 【模板】有理数取余 P3811 【模板】乘法逆元 P5431 【模板】乘法逆元2 P1082 同余方程 P3951 小凯的疑惑 P1516 青蛙的约会 中国剩余定理 中国剩余定理可以快速解一元线性同余方程组。 P4777 【模板】扩展中国剩余定理（EXCRT） P3868 TJOI2009]猜数字 P2480 SDOI2010]古代猪文 P4774 NOI2018]屠龙勇士 P5345 【XR-1】快乐肥宅 高次同余方程 BSGS 算法可以高效计算离散对数。 而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。 P4195 【模板】exBSGS P5491 【模板】二次剩余 P3306 SDOI2013]随机数生成器 P2485 SDOI2011]计算器 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 P2197 【模板】nim游戏 P1288 取数游戏II P1290 欧几里德的游戏 P1247 取火柴游戏 P2252 取石子游戏 概率与期望 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。 P5104 红包发红包 P1850 换教室 P3830 SHOI2012]随机树 P4564 CTSC2018]假面 P2473 SCOI2008]奖励关 P2221 HAOI2012]高速公路 P3239 HNOI2015]亚瑟王 P3750 六省联考2017]分手是祝愿 P4284 SHOI2014]概率充电器 P5249 LnOI2019]加特林轮盘赌 P2081 NOI2012]迷失游乐园 P3343 ZJOI2015]地震后的幻想乡 P3600 随机数生成器 P5326 ZJOI2019]开关 数据结构 灵活地运用数据结构可以高效地查询并处理需要的信息。 链表 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。 P1996 约瑟夫问题 P1160 队列安排 栈 栈，是一种后进先出（FILO）的数据结构。 P1449 后缀表达式 P1739 表达式括号匹配 P1981 表达式求值 P1175 表达式的转换 队列 队列，是一种先进先出（FIFO）的数据结构。 P1540 机器翻译 并查集 并查集常用于处理一些不相交集合的合并和查询问题。 P1111 修复公路 P3958 奶酪 P1525 关押罪犯 P4185 USACO18JAN MooTube G P2024 NOI2001食物链 P1197 JSOI2008星球大战 P1196 NOI2002银河英雄传说 P1955 NOI2015程序自动分析 Part 7.5 二叉堆 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。 P3378 【模板】堆 P1090 合并果子 P1168 中位数 P2085 最小函数值 P2827 蚯蚓 P3045 USACO12FEB Cow Coupons Part 7.6 ST表 ST表可以离线查询区间最值。 P3865 【模板】ST表 P2251 质量检测 P1816 忠诚 P1198 JSOI2008最大数 P2880 USACO07JAN Balanced Lineup P5012 水の数列 P5344 【XR-1】逛森林 P2048 NOI2010 超级钢琴 Part 7.7 树状数组 树状数组是一种简洁高效的树形数据结构。 P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P1908 逆序对 P1966 火柴排队 P3605 USACO17JAN Promotion Counting P1972 SDOI2009 HH的项链 P3586 POI2015 LOG P4054 JSOI2009计数问题 P4113 HEOI2012采花 P3960 列队 线段树 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。 P3372 【模板】线段树 1 P3373 【模板】线段树 2 P5490 【模板】扫描线 P4588 TJOI2018数学计算 P1502 窗口的星星 P2471 SCOI2007降雨量 P2824 HEOI2016&#x2F;TJOI2016排序 P3722 AH2017&#x2F;HNOI2017影魔 P4097 HEOI2013Segment P4198 楼房重建 P4513 小白逛公园 P4556 Vani有约会雨天的尾巴 P5324 BJOI2019删数 P5327 ZJOI2019语言 图论 图论是数学的一个分支，它以图为研究的对象。 图的存储与遍历 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。 P2661 信息传递 P2921 USACO08DEC Trick or Treat on the Farm 最短路问题 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。 P3371 【模板】单源最短路径（弱化版） P4779 【模板】单源最短路径（标准版） P5905 【模板】Johnson 全源最短路 P1144 最短路计数 P1462 通往奥格瑞玛的道路 P1522 Cow Tours P1266 速度限制 P4001 ICPC-Beijing 2006狼抓兔子 P4568 JLOI2011 飞行路线 P3238 HNOI2014 道路堵塞 P5304 GXOI&#x2F;GZOI2019 旅行者 树上问题 作为一种特殊的图，树上的问题具有很多鲜明的特点。 二叉树 二叉树是一种特殊的树，它有很多特殊的性质。 P1087 FBI树 P1030 求先序排列 P1305 新二叉树 P1229 遍历问题 P5018 对称二叉树 P5597 【XR-4】复读 Part 8.3.2 树的直径 树的直径被定义为树上最远的两点间的距离。 计算树的直径，可以通过两遍 DFS 解决。 P2195 HXY造公园 P3629 APIO2010 巡逻 P5536 【XR-3】核心城市 P1099 树网的核 P4408 NOI2003逃学的小孩 公共祖先 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。 求解最近公共祖先，常用的方法是树上倍增或者树链剖分。 P3379 【模板】最近公共祖先（LCA） P3938 斐波那契 P4281 AHOI2008 紧急集合 &#x2F; 聚会 生成树 用 条边将图上的 个点连接起来，形成的树就被称为生成树。 P3366 【模板】最小生成树 [P4180 【模板】严格次小生成树BJWC2010] [P2872 USACO07DEC]Building Roads P1991 无线通讯网 P1967 货车运输 [P4047 JSOI2010]部落划分 拓扑排序 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。 P1113 杂务 P1983 车站分级 P1038 神经网络 差分约束 差分约束要解决的问题是：求出一组 元不等式的一组解，使得所有约束关系都能得到满足。 P5960 【模板】差分约束算法 [P3275 SCOI2011]糖果 [P2294 HNOI2005]狡猾的商人 [P4926 1007]倍杀测量者 P5590 赛车游戏 图的连通性相关 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。 P3387 【模板】缩点 P3388 【模板】割点（割顶） [P2341 HAOI2006]受欢迎的牛 [P2863 USACO06JAN]The Cow Prom [P2746 USACO5.3]Network of Schools [P1407 国家集训队]稳定婚姻 [P2272 ZJOI2007]最大半连通子图 [P3225 HNOI2012]矿场搭建 [P5058 ZJOI2004]嗅探器 [P2515 HAOI2010]软件安装","tags":["算法","C++","洛谷"],"categories":["算法"]},{"title":"力扣Hot100","path":"/2024/09/09/力扣Hot100/","content":"力扣Hot100哈希两数之和1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; st; for (int i = 0; i &lt; nums.size(); i++) &#123; if (st.find(target - nums[i]) != st.end()) &#123; return &#123;i, st[target - nums[i]]&#125;; &#125; else &#123; st[nums[i]] = i; &#125; &#125; return &#123;&#125;; &#125;&#125;; 字母异位词分组12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt; &gt; st; for (int i = 0; i &lt; strs.size(); i++) &#123; string t = strs[i]; sort(strs[i].begin(), strs[i].end()); st[strs[i]].push_back(t); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto it: st) &#123; res.push_back(it.second); &#125; return res; &#125;&#125;; 最长连续序列排序 1234567891011121314151617181920class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &lt; nums.size();) &#123; int t = 1; while (i &lt; nums.size() - 1) &#123; if (nums[i] == nums[i + 1]) i++; else if (nums[i] == nums[i + 1] - 1) &#123; t++; i++; &#125; else break; &#125; if (t == 1) i++; res = max(res, t); &#125; return res; &#125;&#125;; 哈希 12345678910111213141516171819class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; sets; for (auto num: nums) sets.insert(num); int res = 0; for (auto num: sets) &#123; if (!sets.count(num - 1)) &#123; int cur = num, t = 1; while (sets.count(cur + 1)) &#123; cur++; t++; &#125; res = max(res, t); &#125; &#125; return res; &#125;&#125;; 双指针移动零12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = 0, n = nums.size(); while (r &lt; n) &#123; if (nums[r]) &#123; swap(nums[l], nums[r]); l++; &#125; r++; &#125; &#125;&#125;; 盛最多水的容器1234567891011121314class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int l = 0, r = height.size()-1; int res = 0; while (l &lt; r) &#123; int t = min(height[l], height[r]) * (r - l); res = max(res, t); if (height[l] &lt;= height[r]) l++; else r--; &#125; return res; &#125;&#125;; 三数之和暴力 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; st; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size(); i++) st[nums[i]] = i; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (j != i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; if (st[-nums[i] - nums[j]] &gt; i &amp;&amp; st[-nums[i] - nums[j]] &gt; j) res.push_back(&#123;nums[i], nums[j], -nums[i] - nums[j]&#125;); &#125; &#125; return res; &#125;&#125;; 双指针 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i &lt; n - 2; i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] &gt; 0) break; if (nums[i] + nums[n - 2] + nums[n - 1] &lt; 0) continue; int j = i + 1, k = n - 1; while (j &lt; k) &#123; int s = nums[i] + nums[j] + nums[k]; if (s &gt; 0) k--; else if (s &lt; 0) j++; else &#123; res.push_back(&#123;nums[i], nums[j++], nums[k--]&#125;); while(j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; while(j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; &#125; &#125; &#125; return res; &#125;&#125;; 滑动窗口无重复字符的最长子串1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int nums[128]; int i = 0, j = 0, res = 0; while (j &lt; s.size()) &#123; nums[s[j]]++; while (nums[s[j]] &gt; 1) nums[s[i++]]--; res = max(res, j - i + 1); j++; &#125; return res; &#125;&#125;; 找到字符串中所有字母异位词12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int l = 0, r = 0, valid = 0; unordered_map&lt;char, int&gt; need, window; vector&lt;int&gt; res; for (char ch: p) need[ch]++; while (r &lt; s.size()) &#123; char c = s[r++]; if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; while (r - l &gt;= p.size()) &#123; if (valid == need.size()) res.push_back(l); char d = s[l++]; if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; return res; &#125;&#125;; 字串和为 K 的子数组1234567891011121314class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int res = 0, s[20005]; for (int i = 0; i &lt; nums.size(); i++) s[i + 1] = s[i] + nums[i]; unordered_map&lt;int, int&gt; cnt; for (int i = 0; i &lt;= nums.size(); i++) &#123; if (cnt.contains(s[i] - k)) res += cnt[s[i] - k]; cnt[s[i]]++; &#125; return res; &#125;&#125;; 滑动窗口最大值优先队列 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); priority_queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; k; i++) q.push(&#123;nums[i], i&#125;); vector&lt;int&gt; res = &#123;q.top().first&#125;; for (int i = k; i &lt; n; i++) &#123; q.push(&#123;nums[i], i&#125;); while (q.top().second &lt;= i - k) q.pop(); res.push_back(q.top().first); &#125; return res; &#125;&#125;; 单调队列 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); deque&lt;int&gt; q; vector&lt;int&gt; res; int l = 0; for (int i = 0; i &lt; k; i++) &#123; while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back(); q.push_back(i); &#125; res.push_back(nums[q.front()]); for (int i = k; i &lt; n; i++) &#123; while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back(); q.push_back(i); while (q.front() &lt;= i - k) q.pop_front(); res.push_back(nums[q.front()]); &#125; return res; &#125;&#125;; 普通数组最大子数组和动态规划 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int dp[100005], res = -0x3f3f3f3f; dp[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) dp[i] = max(nums[i], dp[i - 1] + nums[i]); for (int i = 0; i &lt; nums.size(); i++) res = max(res, dp[i]); return res; &#125;&#125;; 合并区间123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; intervals.size();) &#123; int t = intervals[i][1]; int j = i + 1; while (j &lt; intervals.size() &amp;&amp; intervals[j][0] &lt;= t) &#123; t = max(t, intervals[j][1]); j++; &#125; res.push_back(&#123;intervals[i][0], t&#125;); i = j; &#125;; return res; &#125;&#125;; 轮转数组12345678910class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int t[100005], size = nums.size(); for (int i = 0; i &lt; size; i++) t[(i + k) % size] = nums[i]; for (int i = 0; i &lt; size; i++) nums[i] = t[i]; &#125;&#125;; 矩阵矩阵置零12345678910111213141516171819class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row[205], col[205], n = matrix.size(), m = matrix[0].size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (matrix[i][j] == 0) &#123; row[i] = 1; col[j] = 1; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (row[i] || col[j]) matrix[i][j] = 0; &#125; &#125; &#125;&#125;; 螺旋矩阵123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = m - 1, u = 0, d = n - 1; vector&lt;int&gt; res; while (true) &#123; for (int i = l; i &lt;= r; i++) res.push_back(matrix[u][i]); u++; if (u &gt; d) break; for (int i = u; i &lt;= d; i++) res.push_back(matrix[i][r]); r--; if (l &gt; r) break; for (int i = r; i &gt;= l; i--) res.push_back(matrix[d][i]); d--; if (u &gt; d) break; for (int i = d; i &gt;= u; i--) res.push_back(matrix[i][l]); l++; if (l &gt; r) break; &#125; return res; &#125;&#125;; 链表二叉树图论回溯二分查找35. 搜索插入位置12345678910111213class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &lt; target) l = mid + 1; else r = mid; &#125; if (l == nums.size() - 1 &amp;&amp; nums[l] &lt; target) return l + 1; else return l; &#125;&#125;; 74. 搜索二维矩阵1234567891011121314151617181920class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (matrix[mid].back() &lt; target) l = mid + 1; else r = mid; &#125; int t = l; l = 0, r = m - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (matrix[t][mid] &lt; target) l = mid + 1; else r = mid; &#125; return matrix[t][l] == target; &#125;&#125;; 34. 在排序数组中查找元素的第一个和最后一个位置1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; if (nums.empty()) &#123; res.push_back(-1); res.push_back(-1); return res; &#125; int n = nums.size(); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &lt; target) l = mid + 1; else r = mid; &#125; if (nums[l] == target) res.push_back(l); else res.push_back(-1); l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (nums[mid] &gt; target) r = mid - 1; else l = mid; &#125; if (nums[r] == target) res.push_back(l); else res.push_back(-1); return res; &#125;&#125;; 33. 搜索旋转排序数组1234567891011121314151617181920212223class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if (target == nums[mid]) return mid; else if (nums[mid] &lt; nums[r]) &#123; if (nums[mid] &lt; target &amp;&amp; nums[r] &gt;= target) l = mid + 1; else r = mid - 1; &#125; else &#123; if (nums[mid] &gt; target &amp;&amp; nums[l] &lt;= target) r = mid - 1; else l = mid + 1; &#125; &#125; return -1; &#125;&#125;; 栈堆贪心算法121. 买卖股票的最佳时机1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int t = prices[0], res = 0; for (int i = 0; i &lt; prices.size(); i++) &#123; t = min(t, prices[i]); res = max(res, prices[i] - t); &#125; return res; &#125;&#125;; 55. 跳跃游戏123456789101112class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int dp[10005] = &#123;0&#125;; dp[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if (dp[i - 1] &lt;= 0) return false; dp[i] = max(dp[i - 1] - 1, nums[i]); &#125; return true; &#125;&#125;; 45. 跳跃游戏 II1234567891011121314class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int res = 0, end = 0, maxa = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; maxa = max(nums[i] + i, maxa); if (i == end) &#123; end = maxa; res++; &#125; &#125; return res; &#125;&#125;; 763. 划分字母区间1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; partitionLabels(string s) &#123; int last[26], n = s.size(); for (int i = 0; i &lt; n; i++) last[s[i] - &#x27;a&#x27;] = i; vector&lt;int&gt; res; int start = 0, end = 0; for (int i = 0; i &lt; n; i++) &#123; end = max(end, last[s[i] - &#x27;a&#x27;]); if (i == end) &#123; res.push_back(end - start + 1); start = end + 1; &#125; &#125; return res; &#125;&#125;; 动态规划70. 爬楼梯1234567891011class Solution &#123;public: int climbStairs(int n) &#123; int dp[50]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; &#125;&#125;; 118. 杨辉三角12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res; int dp[31][31]; dp[1][1] = 1; for (int i = 2; i &lt;= numRows; i++) &#123; for (int j = 1; j &lt;= i; j++) dp[i][j] = dp[i-1][j - 1] + dp[i-1][j]; &#125; for (int i = 1; i &lt;= numRows; i++) &#123; vector&lt;int&gt; t; for (int j = 1; j &lt;= i; j++) t.push_back(dp[i][j]); res.push_back(t); &#125; return res; &#125;&#125;; 198. 打家劫舍1234567891011121314151617class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int dp[105], res; if (nums.size() == 1) res = nums[0]; else if (nums.size() == 2) res = max(nums[0], nums[1]); else &#123; dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); i++) &#123; dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); &#125; res = dp[nums.size() - 1]; &#125; return res; &#125;&#125;; 279. 完全平方数1234567891011121314class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; f(n + 1); for (int i = 1; i &lt;= n; i++) &#123; int minn = INT_MAX; for (int j = 1; j * j &lt;= i; j++) &#123; minn = min(minn, f[i - j * j]); &#125; f[i] = minn + 1; &#125; return f[n]; &#125;&#125;; 322. 零钱兑换123456789101112131415class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int dp[10005]; fill(dp, dp + amount + 1, 10005); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.size(); j++) &#123; if (i - coins[j] &gt;= 0) dp[i] = min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; if (dp[amount] == 10005) return -1; else return dp[amount]; &#125;&#125;; 139. 单词拆分123456789101112131415class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; vector&lt;bool&gt; dp(s.size() + 1); dp[0] = true; for (int i = 1; i &lt;= s.size(); i++) &#123; for (auto &amp; word: wordDict) &#123; int sz = word.size(); if (i - sz &gt;= 0 &amp;&amp; s.substr(i - sz, sz) == word) dp[i] = dp[i] || dp[i - sz]; &#125; &#125; return dp[s.size()]; &#125;&#125;; 多维动态规划62. 不同路径1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; int dp[m][n]; for (int i = 0; i &lt; m; i++) dp[i][0] = 1; for (int i = 0; i &lt; n; i++) dp[0][i] = 1; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; 64. 最小路径和 1234567891011121314class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int dp[205][205], n = grid.size(), m = grid[0].size(); for (int i = 1; i &lt;= m; i++) dp[1][i] = dp[1][i - 1] + grid[0][i - 1]; for (int i = 1; i &lt;= n; i++) dp[i][1] = dp[i - 1][1] + grid[i - 1][0]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= m; j++) &#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; &#125; &#125; return dp[n][m]; &#125;&#125;; 技巧","tags":["算法","LeetCode","C++"],"categories":["算法"]},{"title":"PAT 甲级","path":"/2024/08/30/PAT甲级/","content":"PAT甲级1001 A+B Format12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int c = a + b; if (c &lt; 0) &#123; cout &lt;&lt; &#x27;-&#x27;; c = -c; &#125; if (c &gt;= 1000) &#123; string t = to_string(c); int d = t.size() % 3; if(d) cout &lt;&lt; t.substr(0, d) &lt;&lt; &quot;,&quot;; for (int i = d; i &lt; t.size(); i += 3) &#123; cout &lt;&lt; t.substr(i, 3); if (i + 3 &lt; t.size()) cout &lt;&lt; &quot;,&quot;; &#125; &#125; else cout &lt;&lt; c; return 0;&#125; 柳婼的 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; string s = to_string(a + b); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; s[i]; if (s[i] == &#x27;-&#x27;) continue; if ((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1) cout &lt;&lt; &#x27;,&#x27;; &#125; return 0;&#125; 1002 A+B for Polynomials1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 1001;double nums[N];int main() &#123; int n, a; double b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums[a] = b; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums[a] += b; &#125; int cnt = 0; for (int i = 1000; i &gt;= 0; i--) &#123; if (nums[i]) cnt++; &#125; cout &lt;&lt; cnt; for (int i = 1000; i &gt;= 0; i--) &#123; if (nums[i]) &#123; printf(&quot; %d %.1f&quot;, i, nums[i]); &#125; &#125; return 0;&#125; 1003 Emergency12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 501;const int INF = 0x3f3f3f3f;int vals[N], d[N], num[N], val[N];bool visit[N];vector&lt;PII&gt; g[N];void djkstra(int s, int n) &#123; fill(d, d + N, INF); d[s] = 0; val[s] = vals[s]; num[s] = 1; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; u = j; mind = d[j]; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) &#123; if (d[u] + dis &lt; d[v]) &#123; d[v] = d[u] + dis; num[v] = num[u]; val[v] = val[u] + vals[v]; &#125; else if (d[u] + dis == d[v]) &#123; num[v] = num[v] + num[u]; val[v] = max(val[v], val[u] + vals[v]); &#125; &#125; &#125; &#125;&#125;int main() &#123; int n, m, c1, c2, u, v, w; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; vals[i]; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(&#123;v, w&#125;); g[v].push_back(&#123;u, w&#125;); &#125; djkstra(c1, n); cout &lt;&lt; num[c2] &lt;&lt; &quot; &quot; &lt;&lt; val[c2]; return 0;&#125; 1004 Counting Leavesbfs 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; trees[101];void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; int len = q.size(); int t = 0; while (len--) &#123; u = q.front(); q.pop(); for (int i = 0; i &lt; trees[u].size(); i++) &#123; q.push(trees[u][i]); &#125; if (trees[u].empty()) t++; &#125; cout &lt;&lt; t; if (!q.empty()) cout &lt;&lt; &quot; &quot;; &#125; &#125;int main() &#123; int n, m, id1, k, id2; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id1 &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; id2; trees[id1].push_back(id2); &#125; &#125; bfs(1); return 0;&#125; dfs 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; trees[101];int res[101], maxdepth;void dfs(int u, int depth) &#123; if (trees[u].size() == 0) &#123; res[depth]++; maxdepth = max(maxdepth, depth); &#125; for (int i = 0; i &lt; trees[u].size(); i++) &#123; dfs(trees[u][i], depth + 1); &#125;&#125;int main() &#123; int n, m, id1, k, id2; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id1 &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; id2; trees[id1].push_back(id2); &#125; &#125; dfs(1, 0); for (int i = 0; i &lt;= maxdepth; i++) &#123; cout &lt;&lt; res[i]; if (i &lt; maxdepth) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1005 Spell It Right123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; string words[10] = &#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;&#125;; int res = 0; for (int i = 0; i &lt; str.length(); i++) &#123; res += str[i] - &#x27;0&#x27;; &#125; string res2 = to_string(res); for (int i = 0; i &lt; res2.length(); i++) &#123; cout &lt;&lt; words[res2[i] - &#x27;0&#x27;]; if (i &lt; res2.length() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1006 Sign In and Sign Out123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string name, start, end, res1_name, res1_start = &quot;23:59:59&quot;, res2_name, res2_end = &quot;00:00:00&quot;; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; start &gt;&gt; end; if (start &lt; res1_start) &#123; res1_name = name; res1_start = start; &#125; if (end &gt; res2_end) &#123; res2_name = name; res2_end = end; &#125; &#125; cout &lt;&lt; res1_name &lt;&lt; &quot; &quot; &lt;&lt; res2_name; return 0;&#125; 1007 Maximum Subsequence Sum1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;int nums[10001], dp[10001];int main() &#123; int n; cin &gt;&gt; n; fill(dp, dp + n, -INF); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; dp[0] = nums[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); &#125; int res = -INF, start = 0, end = n - 1, t = 0; for (int i = 0; i &lt; n; i++) &#123; if (res &lt; dp[i]) &#123; res = dp[i]; end = i; &#125; &#125; if (res == 0) start = end; else if (res &gt; 0) &#123; for (int i = end; i &gt;= 0; i--) &#123; if (t &lt; res) &#123; t += nums[i]; start = i; &#125; &#125; &#125; else &#123; res = 0; start = 0; end = n - 1; &#125; cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; nums[start] &lt;&lt; &quot; &quot; &lt;&lt; nums[end]; return 0;&#125; 柳婼的 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int nums[100001];int main() &#123; int n; cin &gt;&gt; n; int left = 0, right = n - 1, res = -1, temp = 0, tempindex = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; temp = temp + nums[i]; if (temp &lt; 0) &#123; temp = 0; tempindex = i + 1; &#125; else if (temp &gt; res) &#123; res = temp; left = tempindex; right = i; &#125; &#125; if (res &lt; 0) res = 0; cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; nums[left] &lt;&lt; &quot; &quot; &lt;&lt; nums[right]; return 0;&#125; 1008 Elevator1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n, pre = 0, now, res = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; now; if (now &gt; pre) res += (now - pre) * 6 + 5; else res += (pre - now) * 4 + 5; pre = now; &#125; cout &lt;&lt; res; return 0;&#125; 1009 Product of Polynomials1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 1001;double nums[N], res[N * N];int main() &#123; int k, a, cnt = 0; double b; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; nums[a] = b; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; for (int j = 0; j &lt; N; j++) &#123; res[a + j] += b * nums[j]; &#125; &#125; for (int i = 0; i &lt; N * N; i++) if (res[i]) cnt++; cout &lt;&lt; cnt; for (int i = N * N - 1; i &gt;= 0; i--) if (res[i]) printf(&quot; %d %.1f&quot;, i, res[i]); return 0;&#125; 1010 Radix12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;LL convert(string s, int k) &#123; LL sum = 0, idx = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; int t = isdigit(s[i]) ? s[i] - &#x27;0&#x27; : s[i] - &#x27;a&#x27; + 10; sum += t * pow(k, idx++); &#125; return sum;&#125;LL find(string s, LL num) &#123; char maxt = *max_element(s.begin(), s.end()); LL low = isdigit(maxt) ? maxt - &#x27;0&#x27; + 1 : maxt - &#x27;a&#x27; + 11; LL high = max(low, num); while (low &lt;= high) &#123; LL mid = low + high &gt;&gt; 1; LL t = convert(s, mid); if (t &lt; 0 | t &gt; num) high = mid - 1; else if (t == num) return mid; else low = mid + 1; &#125; return -1;&#125;int main() &#123; string n1, n2; int tag, radix, res; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; tag &gt;&gt; radix; if (tag == 1) res = find(n2, convert(n1, radix)); else res = find(n1, convert(n2, radix)); if (res == -1) cout &lt;&lt; &quot;Impossible&quot;; else cout &lt;&lt; res; return 0;&#125; 1011 World Cup Betting1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;double fun(double a, double b, double c) &#123; double res = 1; if (b &gt;= a &amp;&amp; b &gt;= c) &#123; cout &lt;&lt; &quot;T &quot;; res *= b; &#125; else if (a &gt;= b &amp;&amp; a &gt;= c) &#123; cout &lt;&lt; &quot;W &quot;; res *= a; &#125; else &#123; cout &lt;&lt; &quot;L &quot;; res *= c; &#125; return res;&#125;int main() &#123; double a, b, c; double res = 1; for (int i = 0; i &lt; 3; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; res *= fun(a * 0.65, b, c); &#125; printf(&quot;%.2f&quot;, 2 * (res - 1)); return 0;&#125; 1012 The Best Rank123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; int num, c, m, e; double a; student(int _num, int _c, int _m, int _e, double _a) &#123; num = _num, c = _c, m = _m, e = _e, a = _a; &#125; student()&#123;&#125;;&#125; nums[2000];bool cmp_a(student a, student b) &#123; return a.a &gt; b.a;&#125;bool cmp_c(student a, student b) &#123; return a.c &gt; b.c;&#125;bool cmp_m(student a, student b) &#123; return a.m &gt; b.m;&#125;bool cmp_e(student a, student b) &#123; return a.e &gt; b.e;&#125;int A[1000000], C[1000000], M[1000000], E[1000000];bool isin[1000000];int main() &#123; int n, m, num, c1, m1, e1; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num &gt;&gt; c1 &gt;&gt; m1 &gt;&gt; e1; double a1 = (c1 + m1 + e1) / 3.0; nums[i] = student(num, c1, m1, e1, a1); isin[num] = true; &#125; int idx = 1; sort(nums, nums + 2000, cmp_a); A[nums[0].num] = idx; for (int i = 1; i &lt; n; i++) &#123; if (nums[i].a == nums[i - 1].a) &#123; A[nums[i].num] = idx; &#125; else &#123; A[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; idx = 1; sort(nums, nums + 2000, cmp_c); C[nums[0].num] = idx; for (int i = 1; i &lt; n; i++) &#123; if (nums[i].c == nums[i - 1].c) &#123; C[nums[i].num] = idx; &#125; else &#123; C[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; idx = 1; sort(nums, nums + 2000, cmp_m); M[nums[0].num] = idx; for (int i = 1; i &lt; n; i++) &#123; if (nums[i].m == nums[i - 1].m) &#123; M[nums[i].num] = idx; &#125; else &#123; M[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; idx = 1; sort(nums, nums + 2000, cmp_e); E[nums[0].num] = idx; for (int i = 0; i &lt; n; i++) &#123; if (nums[i].e == nums[i - 1].e) &#123; E[nums[i].num] = idx; &#125; else &#123; E[nums[i].num] = i + 1; idx = i + 1; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num; if (isin[num]) &#123; int res_rank = n, res_sub; if (res_rank &gt; A[num]) &#123; res_rank = A[num]; res_sub = &#x27;A&#x27;; &#125; if (res_rank &gt; C[num]) &#123; res_rank = C[num]; res_sub = &#x27;C&#x27;; &#125; if (res_rank &gt; M[num]) &#123; res_rank = M[num]; res_sub = &#x27;M&#x27;; &#125; if (res_rank &gt; E[num]) &#123; res_rank = E[num]; res_sub = &#x27;E&#x27;; &#125; printf(&quot;%d %c &quot;, res_rank, res_sub); &#125; else &#123; cout &lt;&lt; &quot;N/A&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 柳婼的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int id, best; int score[4], rank[4];&#125; stu[2001];int hashtable[1000000], flag;bool cmp(node a, node b) &#123; return a.score[flag] &gt; b.score[flag];&#125;int main() &#123; int n, m, id; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].id &gt;&gt; stu[i].score[1] &gt;&gt; stu[i].score[2] &gt;&gt; stu[i].score[3]; stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5; &#125; for (flag = 0; flag &lt;= 3; flag++) &#123; sort(stu, stu + n, cmp); stu[0].rank[flag] = 1; for (int i = 1; i &lt; n; i++) &#123; stu[i].rank[flag] = i + 1; if (stu[i].score[flag] == stu[i - 1].score[flag]) stu[i].rank[flag] = stu[i - 1].rank[flag]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; hashtable[stu[i].id] = i + 1; stu[i].best = 0; int minn = stu[i].rank[0]; for (int j = 1; j &lt;= 3; j++) &#123; if (stu[i].rank[j] &lt; minn) &#123; minn = stu[i].rank[j]; stu[i].best = j; &#125; &#125; &#125; char c[5] = &#123;&quot;ACME&quot;&#125;; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id; if (hashtable[id]) &#123; int best = stu[hashtable[id] - 1].best; printf(&quot;%d %c &quot;, stu[hashtable[id] - 1].rank[best], c[best]); &#125; else &#123; cout &lt;&lt; &quot;N/A &quot;; &#125; &#125; return 0;&#125; 1013 Battle Over Cities并查集 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 1001;int g[N][N], fa[N];int find(int x) &#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;int main() &#123; int n, m, k, u, v, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u][v] = g[v][u] = 1; &#125; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; x; for (int j = 1; j &lt;= n; j++) &#123; fa[j] = j; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int k = j + 1; k &lt;= n; k++) &#123; if (j == x || k == x) continue; if (g[j][k] == 1 &amp;&amp; find(j) != find(k)) &#123; fa[find(j)] = find(k); &#125; &#125; &#125; set&lt;int&gt; res; for (int j = 1; j &lt;= n; j++) &#123; res.insert(find(j)); &#125; cout &lt;&lt; res.size() - 2 &lt;&lt; endl; &#125; return 0;&#125; 柳婼的（dfs） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 1001;int g[N][N], n;bool visit[N];void dfs(int x) &#123; visit[x] = true; for (int i = 1; i &lt;= n; i++) &#123; if (g[i][x] &amp;&amp; !visit[i]) &#123; dfs(i); &#125; &#125;&#125;int main() &#123; int m, k, u, v, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u][v] = g[v][u] = 1; &#125; for (int i = 0; i &lt; k; i++) &#123; fill(visit, visit + N, false); cin &gt;&gt; x; visit[x] = true; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) &#123; dfs(i); cnt++; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl; &#125; return 0;&#125; 1014 Waiting in Line大模拟（queue） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int poptime, endtime; queue&lt;int&gt; q;&#125;;int main() &#123; int n, m, k, q, idx = 1; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q; vector&lt;int&gt; time(k + 1), res(k + 1); for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; time[i]; &#125; vector&lt;node&gt; win(n + 1); vector&lt;bool&gt; sorry(k + 1, false); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (idx &lt;= k) &#123; win[j].q.push(time[idx]); if (win[j].endtime &gt;= 540) sorry[idx] = true; win[j].endtime += time[idx]; if (i == 1) win[j].poptime = win[j].endtime; res[idx] = win[j].endtime; idx++; &#125; &#125; &#125; while (idx &lt;= k) &#123; int tmin = win[1].poptime, twin = 1; for (int i = 2; i &lt;= n; i++) &#123; if (win[i].poptime &lt; tmin) &#123; twin = i; tmin = win[i].poptime; &#125; &#125; win[twin].q.pop(); win[twin].q.push(time[idx]); win[twin].poptime += win[twin].q.front(); if (win[twin].endtime &gt;= 540) sorry[idx] = true; win[twin].endtime += time[idx]; res[idx] = win[twin].endtime; idx++; &#125; for (int i = 1; i &lt;= q; i++) &#123; int query, minute; cin &gt;&gt; query; minute = res[query]; if (sorry[query]) cout &lt;&lt; &quot;Sorry&quot; &lt;&lt; endl; else printf(&quot;%02d:%02d &quot;, (minute + 480) / 60, minute % 60); &#125; return 0;&#125; 1015 Reversible Primes12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;const int N = 100001;bool st[N];int convert1(string s, int k) &#123; int sum = 0, idx = 0; for (int i = s.size() - 1; i &gt;= 0; i--) &#123; sum += (s[i] - &#x27;0&#x27;) * pow(k, idx++); &#125; return sum;&#125;string convert2(int n, int k) &#123; string res; while (n) &#123; res.push_back(n % k + &#x27;0&#x27;); n /= k; &#125; return res;&#125;int main() &#123; for (int i = 2; i &lt; N; i++) &#123; if (!st[i]) &#123; for (int j = i + i; j &lt; N; j += i) &#123; st[j] = true; &#125; &#125; &#125; st[0] = st[1] = true; int a, b; while (cin &gt;&gt; a) &#123; if (a &lt; 0) break; cin &gt;&gt; b; int t = convert1(convert2(a, b), b); if (!st[t] &amp;&amp; !st[a]) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isprime(int n) &#123; if (n &lt;= 1) return false; for (int i = 2; i &lt;= int(sqrt(n * 1.0)); i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int a, b; while (cin &gt;&gt; a) &#123; if (a &lt; 0) break; cin &gt;&gt; b; if (!isprime(a)) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; continue; &#125; int len = 0, arr[100]; do &#123; arr[len++] = a % b; a /= b; &#125; while(a != 0); for (int i = 0; i &lt; len; i++) a = a * b + arr[i]; if (isprime(a)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1016 Phone Bills大模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string time, tag; node (string _time, string _tag) &#123; time = _time, tag = _tag; &#125;&#125;;map&lt;string, vector&lt;node&gt;&gt; mp;bool cmp(node a, node b) &#123; return a.time &lt; b.time;&#125;int price[25] = &#123;0&#125;, n;double count2(string time) &#123; int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = price[hour] * min + price[24] * 60 * day; for (int i = 0; i &lt; hour; i++) &#123; res += price[i] * 60; &#125; return res / 100.0;&#125;int count1(string time) &#123; int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = day * 24 * 60 + hour * 60 + min; return res;&#125;int main() &#123; for (int i = 0; i &lt; 24; i++) &#123; cin &gt;&gt; price[i]; price[24] += price[i]; &#125; cin &gt;&gt; n; string name, time, tag, month; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; time &gt;&gt; tag; month = time.substr(0, 2); mp[name].push_back(node(time.substr(3, 8), tag)); &#125; for (auto i = mp.begin(); i != mp.end(); i++) &#123; vector&lt;node&gt; nodes = i-&gt;second; sort(nodes.begin(), nodes.end(), cmp); double money = 0; int idx = 0, minute; string start, end; vector&lt;string&gt; times; for (int i = 0; i &lt; nodes.size() - 1; i++) &#123; if (nodes[i].tag == &quot;on-line&quot; &amp;&amp; nodes[i + 1].tag == &quot;off-line&quot;) &#123; times.push_back(nodes[i].time); times.push_back(nodes[i + 1].time); &#125; &#125; if (times.size() &gt; 0) &#123; cout &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; month &lt;&lt; endl; for (int i = 0; i &lt; times.size(); i += 2) &#123; string start = times[i], end = times[i + 1]; minute = count1(end) - count1(start); double t = count2(end) - count2(start); money += t; printf(&quot;%s %s %d $%.2f &quot;, start.c_str(), end.c_str(), minute, t); &#125; printf(&quot;Total amount: $%.2f &quot;, money); &#125; &#125; return 0;&#125; 柳婼的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int status, month, time, day, hour, minute;&#125;;bool cmp(node a, node b) &#123; return a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;&#125;int rate[25], n;double count(node a) &#123; double res = rate[a.hour] * a.minute + rate[24] * 60 * a.day; for (int i = 0; i &lt; a.hour; i++) &#123; res += rate[i] * 60; &#125; return res / 100.0;&#125;int main() &#123; for (int i = 0; i &lt; 24; i++) &#123; cin &gt;&gt; rate[i]; rate[24] += rate[i]; &#125; cin &gt;&gt; n; vector&lt;node&gt; data(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; data[i].name; scanf(&quot;%d:%d:%d:%d&quot;, &amp;data[i].month, &amp;data[i].day, &amp;data[i].hour, &amp;data[i].minute); string tmp; cin &gt;&gt; tmp; data[i].status = (tmp == &quot;on-line&quot;) ? 1 : 0; data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute; &#125; sort(data.begin(), data.end(), cmp); map&lt;string, vector&lt;node&gt; &gt; custom; for (int i = 1; i &lt; n; i++) &#123; if (data[i].name == data[i - 1].name &amp;&amp; data[i - 1].status == 1 &amp;&amp; data[i].status == 0) &#123; custom[data[i - 1].name].push_back(data[i - 1]); custom[data[i].name].push_back(data[i]); &#125; &#125; for (auto it: custom) &#123; vector&lt;node&gt; tmp = it.second; printf(&quot;%s %02d &quot;, it.first.c_str(), tmp[0].month); double res = 0; for (int i = 1; i &lt; tmp.size(); i += 2) &#123; double t = count(tmp[i]) - count(tmp[i - 1]); printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2f &quot;, tmp[i - 1].day, tmp[i - 1].hour, tmp[i - 1].minute, tmp[i].day, tmp[i].hour, tmp[i].minute, tmp[i].time - tmp[i - 1].time, t); res += t; &#125; printf(&quot;Total amount: $%.2f &quot;, res); &#125; return 0;&#125; 1017 Queueing at Bank1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int main() &#123; int n, k, p, hour, minute, second, idx = 0, res = 0; cin &gt;&gt; n &gt;&gt; k; vector&lt;PII&gt; nums; vector&lt;int&gt; v(k); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d:%d:%d %d&quot;, &amp;hour, &amp;minute, &amp;second, &amp;p); int t = hour * 3600 + minute * 60 + second; if (t &gt; 61200) continue; nums.push_back(&#123;t, p * 60&#125;); &#125; sort(nums.begin(), nums.end()); n = nums.size(); for (int j = 0; j &lt; min(n, k); j++) &#123; if (nums[idx].first &lt; 28800) &#123; v[j] = 28800; res += 28800 - nums[idx].first; &#125; else &#123; v[j] = nums[idx].first; &#125; v[j] += nums[idx].second; idx++; &#125; while (idx &lt; n) &#123; int tmin = v[0], twin = 0; for (int i = 1; i &lt; k; i++) &#123; if (tmin &gt; v[i]) &#123; tmin = v[i]; twin = i; &#125; &#125; if (v[twin] &gt; nums[idx].first) &#123; res += v[twin] - nums[idx].first; &#125; else &#123; v[twin] = nums[idx].first; &#125; v[twin] += nums[idx].second; idx++; &#125; printf(&quot;%.1f&quot;, res / 60.0 / n); return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10005;struct person &#123; int come, time;&#125; p[maxn];int cmp(person p1, person p2) &#123; return p1.come &lt; p2.come;&#125;int n, k, cnt, total;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; int hh, ss, mm, tt; scanf(&quot;%d:%d:%d %d&quot;, &amp;hh, &amp;mm, &amp;ss, &amp;tt); int sum = hh * 3600 + mm * 60 + ss; if (sum &gt; 61200) continue; p[++cnt].time = tt * 60; p[cnt].come = sum; &#125; sort(p + 1, p + 1 + cnt, cmp); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for (int i = 1; i &lt;= k; i++) q.push(28800); for (int i = 1; i &lt;= cnt; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; if (q.top() &lt;= p[i].come) &#123; q.push(p[i].come + p[i].time); &#125; else &#123; total += q.top() - p[i].come; q.push(q.top() + p[i].time); &#125; q.pop(); &#125; if (!cnt) cout &lt;&lt; &quot;0.0&quot; &lt;&lt; endl; else printf(&quot;%.1f&quot;, total / 60.0 / cnt); return 0;&#125; 1018 Public Bike Managementdijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 501;const int INF = 0x3f3f3f3f;bool visit[N];int d[N], weight[N], n, minNeed = INF, minBack = INF;vector&lt;PII&gt; g[N];vector&lt;int&gt; pre[N], path, tmppath;void dijkstra(int x) &#123; fill(d, d + N, INF); d[x] = 0; for (int i = 0; i &lt;= n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt;= n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; mind = d[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) &#123; if (d[u] + dis &lt; d[v]) &#123; d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[u] + dis == d[v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; tmppath.push_back(v); if (v == 0) &#123; int need = 0, back = 0; for (int i = tmppath.size() - 1; i &gt;= 0; i--) &#123; int idx = tmppath[i]; if (weight[idx] &gt; 0) &#123; back += weight[idx]; &#125; else &#123; if (back &gt; -weight[idx]) &#123; back += weight[idx]; &#125; else &#123; need += (-weight[idx] - back); back = 0; &#125; &#125; &#125; if (need &lt; minNeed) &#123; minNeed = need; minBack = back; path = tmppath; &#125; else if (need == minNeed &amp;&amp; back &lt; minBack) &#123; minBack = back; path = tmppath; &#125; tmppath.pop_back(); return; &#125; for (int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v][i]); tmppath.pop_back();&#125;int main() &#123; int c, s, m, u, v, w; cin &gt;&gt; c &gt;&gt; n &gt;&gt; s &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; weight[i] = weight[i] - c / 2; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(&#123;v, w&#125;); g[v].push_back(&#123;u, w&#125;); &#125; dijkstra(0); dfs(s); cout &lt;&lt; minNeed &lt;&lt; &quot; 0&quot;; for (int i = path.size() - 2; i &gt;= 0; i--) &#123; cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; path[i]; &#125; cout &lt;&lt; &quot; &quot; &lt;&lt; minBack; return 0;&#125; 1019 General Palindromic Number1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; str; while (n) &#123; str.push_back(n % k); n /= k; &#125; vector&lt;int&gt; str2(str.rbegin(), str.rend()); if (str == str2) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; for (int i = 0; i &lt; str2.size(); i++) &#123; cout &lt;&lt; str2[i]; if (i &lt; str2.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1020 Tree Traversals1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 31;int post[N], in[N];struct node &#123; int l, r;&#125; trees[N];int build(int postl, int postr, int inl, int inr) &#123; if (postl &gt; postr) return -1; int root = post[postr], idx; for (int i = inl; i &lt;= inr; i++) &#123; if (root == in[i]) &#123; idx = i; break; &#125; &#125; int cntl = idx - inl; trees[root].l = build(postl, postl + cntl - 1, inl, idx - 1); trees[root].r = build(postl + cntl, postr - 1, idx + 1, inr); return root;&#125;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; u = q.front(); q.pop(); cout &lt;&lt; u; if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); if (!q.empty()) cout &lt;&lt; &quot; &quot;; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; post[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; int root = build(0, n - 1, 0, n - 1); bfs(root); return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int N = 31;int post[N], in[N];map&lt;int, int&gt; level;void pre(int root, int start, int end, int idx) &#123; if (start &gt; end) return; int i = start; while (i &lt; end &amp;&amp; in[i] != post[root]) i++; level[idx] = post[root]; pre(root - 1 - end + i, start, i - 1, 2 * idx + 1); pre(root - 1, i + 1, end, 2 * idx + 2);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; post[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; pre(n - 1, 0, n - 1, 0); for (auto i = level.begin(); i != level.end(); i++) &#123; cout &lt;&lt; i-&gt;second; if (next(i) != level.end()) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1021 Deepest Root123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int n, maxh = 0;vector&lt;int&gt; g[10010], tmp;bool visit[10010];set&lt;int&gt; s;void dfs(int node, int height) &#123; if (maxh &lt; height) &#123; maxh = height; tmp.clear(); tmp.push_back(node); &#125; else if (maxh == height) &#123; tmp.push_back(node); &#125; visit[node] = true; for (int i = 0; i &lt; g[node].size(); i++) &#123; if (!visit[g[node][i]]) &#123; dfs(g[node][i], height + 1); &#125; &#125;&#125;int main() &#123; int n, u, v, cnt = 0, s1 = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) &#123; dfs(i, 1); if (i == 1) &#123; if (!tmp.empty()) s1 = tmp[0]; for (int j = 0; j &lt; tmp.size(); j++) &#123; s.insert(tmp[j]); &#125; &#125; cnt++; &#125; &#125; if (cnt &gt; 1) cout &lt;&lt; &quot;Error: &quot; &lt;&lt; cnt &lt;&lt; &quot; components&quot;; else &#123; tmp.clear(); fill(visit, visit + 10010, false); maxh = 0; dfs(s1, 1); for (int i = 0; i &lt; tmp.size(); i++) s.insert(tmp[i]); for (auto it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; &#125; return 0;&#125; 1022 Digital Library12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct book &#123; string num, title, auther, publisher, year; vector&lt;string&gt; keys;&#125; books[10001];bool cmp(book a, book b) &#123; return a.num &lt; b.num;&#125;int main() &#123; int n, m, q; string key, query; scanf(&quot;%d &quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; getline(cin, books[i].num); getline(cin, books[i].title); getline(cin, books[i].auther); while (cin &gt;&gt; key) &#123; books[i].keys.push_back(key); char c = getchar(); if (c == &#x27; &#x27;) break; &#125; getline(cin, books[i].publisher); getline(cin, books[i].year); &#125; sort(books, books + n, cmp); cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; bool flag = false; scanf(&quot;%d: &quot;, &amp;q); getline(cin, query); cout &lt;&lt; q &lt;&lt; &quot;: &quot; &lt;&lt; query &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; if (q == 1 &amp;&amp; books[i].title == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; else if (q == 2 &amp;&amp; books[i].auther == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; else if (q == 3) &#123; for (int j = 0; j &lt; books[i].keys.size(); j++) &#123; if (query == books[i].keys[j]) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; &#125; &#125; else if (q == 4 &amp;&amp; books[i].publisher == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; else if (q == 5 &amp;&amp; books[i].year == query) &#123; cout &lt;&lt; books[i].num &lt;&lt; endl; flag = true; &#125; &#125; if (!flag) cout &lt;&lt; &quot;Not Found&quot; &lt;&lt; endl; &#125; return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt; &gt; title, author, key, pub, year;void query(map&lt;string, set&lt;int&gt; &gt; &amp;m, string &amp;str) &#123; if(m.find(str) != m.end()) &#123; for(auto it = m[str].begin(); it != m[str].end(); it++) printf(&quot;%07d &quot;, *it); &#125; else cout &lt;&lt; &quot;Not Found &quot;;&#125;int main() &#123; int n, m, id, num; scanf(&quot;%d&quot;, &amp;n); string ttitle, tauthor, tkey, tpub, tyear; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d &quot;, &amp;id); getline(cin, ttitle); title[ttitle].insert(id); getline(cin, tauthor); author[tauthor].insert(id); while(cin &gt;&gt; tkey) &#123; key[tkey].insert(id); char c = getchar(); if(c == &#x27; &#x27;) break; &#125; getline(cin, tpub); pub[tpub].insert(id); getline(cin, tyear); year[tyear].insert(id); &#125; scanf(&quot;%d&quot;, &amp;m); for(int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d: &quot;, &amp;num); string temp; getline(cin, temp); cout &lt;&lt; num &lt;&lt; &quot;: &quot; &lt;&lt; temp &lt;&lt; &quot; &quot;; if(num == 1) query(title, temp); else if(num == 2) query(author, temp); else if(num == 3) query(key, temp); else if(num == 4) query(pub,temp); else if(num ==5) query(year, temp); &#125; return 0;&#125; 1023 Have Fun with Numbers12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int nums[10];int main() &#123; string a, b = &quot;&quot;; cin &gt;&gt; a; int t = 0; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; b += ((a[i] - &#x27;0&#x27;) * 2 + t) % 10 + &#x27;0&#x27;; t = ((a[i] - &#x27;0&#x27;) * 2 + t) / 10; &#125; if (t) b += t + &#x27;0&#x27;; reverse(b.begin(), b.end()); for (int i = 0; i &lt; a.size(); i++) &#123; nums[a[i]]++; &#125; bool flag = true; for (int i = 0; i &lt; b.size(); i++) &#123; nums[b[i]]--; if (nums[b[i]] &lt; 0) &#123; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; cout &lt;&lt; b; return 0;&#125; 1024 Palindromic Number123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string add(string a) &#123; string b(a.rbegin(), a.rend()), c = &quot;&quot;; int t = 0; for (int i = a.size() - 1; i &gt;= 0; i--) &#123; int sum = a[i] - &#x27;0&#x27; + b[i] - &#x27;0&#x27; + t; c += sum % 10 + &#x27;0&#x27;; t = sum / 10; &#125; if (t) c += t + &#x27;0&#x27;; reverse(c.begin(), c.end()); return c;&#125;bool ispal(string a) &#123; string b(a.rbegin(), a.rend()); return a == b;&#125;int main() &#123; string n; int k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; if (ispal(n)) &#123; cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; i; return 0; &#125; n = add(n); &#125; cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; k; return 0;&#125; 1025 PAT Ranking1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node1 &#123; string num; int score, locnum, locrank;&#125;;bool cmp1(node1 &amp;a, node1 &amp;b) &#123; if (a.score == b.score) &#123; return a.num &lt; b.num; &#125; else &#123; return a.score &gt; b.score; &#125;&#125;int main() &#123; int n, k, score; string num; vector&lt;node1&gt; nums; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k; vector&lt;node1&gt; tmp(k); for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; tmp[j].num &gt;&gt; tmp[j].score; tmp[j].locnum = i; &#125; sort(tmp.begin(), tmp.end(), cmp1); tmp[0].locrank = 1; nums.push_back(tmp[0]); for (int j = 1; j &lt; k; j++) &#123; if (tmp[j].score != tmp[j - 1].score) tmp[j].locrank = j + 1; else tmp[j].locrank = tmp[j - 1].locrank; nums.push_back(tmp[j]); &#125; &#125; sort(nums.begin(), nums.end(), cmp1); int rank = 1; cout &lt;&lt; nums.size() &lt;&lt; endl; cout &lt;&lt; nums[0].num &lt;&lt; &quot; &quot; &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; nums[0].locnum &lt;&lt; &quot; &quot; &lt;&lt; nums[0].locrank &lt;&lt; endl; for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[i].score != nums[i - 1].score) rank = i + 1; cout &lt;&lt; nums[i].num &lt;&lt; &quot; &quot; &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; nums[i].locnum &lt;&lt; &quot; &quot; &lt;&lt; nums[i].locrank &lt;&lt; endl; &#125; return 0;&#125; 1026 Table Tennis最恶心的大模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef long long ll;struct table &#123; int endtime, num; bool vip;&#125;;struct play &#123; int arrive, use, start; // 到达时间，使用时间，开始时间 bool served, vip; // 是否服务，vip?&#125;;int cmp1(play a, play b) &#123; return a.arrive &lt; b.arrive; // 先对数据进行排序，按到达的时间升序&#125;int cmp2(play a, play b) &#123; return a.start &lt; b.start; // 最后输出的时候为什么是8:12:00在8:10:00的前面呢？就是因为是按开始使用的时间升序的&#125;vector&lt;play&gt; p;vector&lt;table&gt; t;// 找到personid及之后的，并且到达（arrive）时间不晚于before的，未服务的，且为vip的 person-id. 如果没找到,则返回-1int findvip(int personId, int minendtime) &#123; for (int i = personId; i &lt; p.size() &amp;&amp; p[i].arrive &lt;= minendtime; i++) &#123; if (!p[i].served &amp;&amp; p[i].vip) return i; &#125; return -1;&#125;// 更新以personId的玩家对，和tableId的桌子的信息// 1、将该玩家对的开始时间赋值为到达时间和可用桌子结束时间中的较大值// 2、将该玩家对的服务状态赋值为以服务过// 3、将桌子的结束时间信息更新为该玩家对的开始时间加该玩家的使用时间// 4、将该桌子服务的玩家数量加一void update(int personid, int tableid) &#123; p[personid].start = max(p[personid].arrive, t[tableid].endtime); p[personid].served = 1; t[tableid].endtime = p[personid].start + p[personid].use; t[tableid].num++;&#125;int main() &#123; int n, m, k, vipnum; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int h, m, s, use, vip, arrive; scanf(&quot;%d:%d:%d %d %d&quot;, &amp;h, &amp;m, &amp;s, &amp;use, &amp;vip); arrive = h * 3600 + m * 60 + s; use = use &gt; 120 ? 7200 : use * 60; p.push_back(&#123;arrive, use, 0, 0, vip &gt; 0&#125;); &#125; sort(p.begin(), p.end(), cmp1); scanf(&quot;%d %d&quot;, &amp;k, &amp;m); for (int i = 0; i &lt; k; i++) t.push_back(&#123;28800, 0, 0&#125;); for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;vipnum); t[vipnum - 1].vip = 1; &#125; for (int i = 0; i &lt; p.size();) &#123; // 找到最先空闲的桌子,如果多个桌子同时空闲，则返回桌子号最小的那个 int minendtime = INF, minendid; for (int j = 0; j &lt; k; j++) &#123; if (minendtime &gt; t[j].endtime) &#123; minendtime = t[j].endtime; minendid = j; &#125; &#125; // 如果最先空闲的桌子空闲的太晚了，或者当前序列中的第一位玩家对达到的时间太晚了，就退出循环 if (minendtime &gt;= 75600 || p[i].arrive &gt;= 75600) break; // 声明新的变量，personId为经过调整选择后最终的开始使用桌子的玩家对索引，tableId为为经过调整选择后最终的开始被使用的桌子 int personid = i, tableid = minendid; // 如果当前的最早空闲且号最小的桌子空闲时，存在玩家对已经在等待了 if (minendtime &gt;= p[i].arrive) &#123; // 并且当前的最早空闲且号最小的桌子是vip，寻找是vip的且未服务过的，玩家对到达时间不晚于minEndTime的玩家对索引 if (t[tableid].vip) &#123; int vipid = findvip(personid, minendtime); personid = vipid != -1 ? vipid : personid; &#125; else if (p[i].vip) &#123; // 虽然当前的最早空闲且号最小的桌子不是vip，但是还可能存在同时空闲，桌号更大的桌子是vip for (int j = 0; j &lt; k; j++) &#123; if (t[j].vip &amp;&amp; t[j].endtime &lt;= p[personid].arrive) &#123; tableid = j; break; &#125; &#125; &#125; // 如果当前的桌子非vip，且当前的序列的第一个玩家对非vip，顺序选择即可，换句话说，personId和tableId无需调整 &#125; else &#123; /* 如果当前的最早空闲的桌子空闲时，没有玩家在等待序列中，即当一个玩家到达时，应该是至少有一个桌子是空闲的 我们总是希望选择空闲中的桌子中桌子号最小的，如果到达了一个vip玩家对，并且存在空闲的vip桌子，我们选择空闲中的vip桌中号最小的 在这里，我们不管是否是vip，先得到空闲中的桌子中桌子号最小的，如果当前到达的玩家对未vip，并且存在空闲的vip桌子， 我们用空闲中的vip桌中号最小的那个桌子覆盖之前得到的tableId */ for (int j = 0; j &lt; k; j++) &#123; if (t[j].endtime &lt;= p[personid].arrive) &#123; tableid = j; break; &#125; &#125; if (p[personid].vip) &#123; for (int j = 0; j &lt; k; j++) &#123; // 尝试寻找空闲的vip桌子并调整tableId，顺序找到即退出得到的就是号码最小的 if (t[j].vip &amp;&amp; t[j].endtime &lt;= p[personid].arrive) &#123; tableid = j; break; &#125; &#125; &#125; &#125; update(personid, tableid); while (i &lt; p.size() &amp;&amp; p[i].served) i++; &#125; sort(p.begin(), p.end(), cmp2); for (int i = 0; i &lt; p.size(); i++) &#123; if (p[i].served) &#123; int wait = p[i].start - p[i].arrive; printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d &quot;, p[i].arrive / 3600, p[i].arrive % 3600 / 60, p[i].arrive % 60, p[i].start / 3600, p[i].start % 3600 / 60, p[i].start % 60, (int)(1.0 * wait / 60 + 0.5)); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; if (i != 0) printf(&quot; &quot;); printf(&quot;%d&quot;, t[i].num); &#125; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int n, m, k, H, M, S, t, table, vtable, cnt, now, nowt, T[100000], V[100000], num[10001], AnsI[10001], AnsO[10001], vip[10001];map&lt;int, int&gt; Table;queue&lt;int&gt; Wait, vWait;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d:%d:%d&quot;, &amp;H, &amp;M, &amp;S); t = H * 3600 + M * 60 + S; scanf(&quot;%d %d&quot;, &amp;T[t], &amp;V[t]); T[t] = min(T[t], 120) * 60; &#125; scanf(&quot;%d %d&quot;, &amp;m, &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;t); vip[t] = 1; &#125; for (int Time = 28800; Time &lt; 75600; Time++, table = vtable = now = 0) &#123; if (T[Time] &amp;&amp; V[Time]) vWait.push(Time); else if (T[Time]) Wait.push(Time); for (int i = 1; i &lt;= m; i++) &#123; if (Table[i] &gt; 0) Table[i]--; if (Table[i] == 0 &amp;&amp; vip[i] &amp;&amp; vtable == 0) vtable = i; if (Table [i] == 0 &amp;&amp; table == 0) table = i; &#125; if (!vWait.empty() &amp;&amp; (table || vtable)) &#123; now = vWait.front(); nowt = vtable; if (vtable != 0) vWait.pop(); else &#123; nowt = table; if (!Wait.empty() &amp;&amp; Wait.front() &lt; vWait.front()) &#123; now = Wait.front(); Wait.pop(); &#125; else vWait.pop(); &#125; &#125; else if (!Wait.empty() &amp;&amp; (table || vtable)) &#123; if (table != 0) nowt = table; else nowt = vtable; now = Wait.front(); Wait.pop(); &#125; if (now == 0) continue; Table[nowt] = T[now]; AnsI[cnt] = now; AnsO[cnt++] = Time; num[nowt]++; &#125; for (int i = 0; i &lt; cnt; i++) printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d &quot;, AnsI[i] / 3600, AnsI[i] % 3600 / 60, AnsI[i] % 60, AnsO[i] / 3600, AnsO[i] % 3600 / 60, AnsO[i] % 60, (AnsO[i] - AnsI[i] + 30) / 60); for (int i = 1; i &lt;= m; i++) &#123; if (i != 1) printf(&quot; &quot;); printf(&quot;%d&quot;, num[i]); &#125; return 0;&#125; 1027 Colors in Mars123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string convert(int n) &#123; string res = &quot;&quot;; while (n) &#123; if (n % 13 &gt; 9) res += n % 13 + &#x27;A&#x27; - 10; else res += n % 13 + &#x27;0&#x27;; n /= 13; &#125; while (res.size() &lt; 2) res += &#x27;0&#x27;; reverse(res.begin(), res.end()); return res;&#125;int main() &#123; int red, green, blue; cin &gt;&gt; red &gt;&gt; green &gt;&gt; blue; cout &lt;&lt; &quot;#&quot; &lt;&lt; convert(red) &lt;&lt; convert(green) &lt;&lt; convert(blue); return 0;&#125; 柳婼的 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; char c[14] = &#123;&quot;0123456789ABC&quot;&#125;; cout &lt;&lt; &quot;#&quot;; for (int i = 0; i &lt; 3; i++) &#123; int num; cin &gt;&gt; num; cout &lt;&lt; c[num / 13] &lt;&lt; c[num % 13]; &#125; return 0;&#125; 1028 List Sorting1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct node &#123; string num, name; int score;&#125; nums[100001];bool cmp1 (node a, node b) &#123; return a.num &lt; b.num;&#125;bool cmp2 (node a, node b) &#123; if (a.name == b.name) return a.num &lt; b.num; else return a.name &lt; b.name;&#125;bool cmp3 (node a, node b) &#123; if (a.score == b.score) return a.num &lt; b.num; else return a.score &lt; b.score;&#125;int main() &#123; int n, c, score; string num, name; cin &gt;&gt; n &gt;&gt; c; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].num &gt;&gt; nums[i].name &gt;&gt; nums[i].score; &#125; if (c == 1) &#123; sort(nums, nums + n, cmp1); &#125; else if (c == 2) &#123; sort(nums, nums + n, cmp2); &#125; else if (c == 3) &#123; sort(nums, nums + n, cmp3); &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i].num &lt;&lt; &quot; &quot; &lt;&lt; nums[i].name &lt;&lt; &quot; &quot; &lt;&lt; nums[i].score &lt;&lt; endl; &#125;&#125; 1029 Median12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;vector&lt;LL&gt; nums;int main() &#123; LL n, x; scanf(&quot;%lld&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot; %lld&quot;, &amp;x); nums.push_back(x); &#125; scanf(&quot;%lld&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot; %lld&quot;, &amp;x); nums.push_back(x); &#125; sort(nums.begin(), nums.end()); cout &lt;&lt; nums[(nums.size() - 1) / 2]; return 0;&#125; 柳婼的 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 200005;int n, m, a1[N], a2[N];int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a1[i]); &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d&quot;, &amp;a2[i]); &#125; int target = (n + m + 1) / 2; int i = 1, j = 1, cnt = 0, res; while (i &lt;= n &amp;&amp; j &lt;= m) &#123; res = a1[i] &lt;= a2[j] ? a1[i++] : a2[j++]; if (++cnt == target) break; &#125; if (i &lt;= n &amp;&amp; cnt &lt; target) res = a1[i + target - cnt - 1]; else if (j &lt;= m &amp;&amp; cnt &lt; target) res = a2[j + target - cnt - 1]; cout &lt;&lt; res; return 0;&#125; 1030 Travel Plandijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node &#123; int v, dis; node (int _v, int _dis) &#123; v = _v, dis = _dis; &#125;&#125;;vector&lt;node&gt; g[N];vector&lt;int&gt; pre[N];int n, s, d[N], cost[N][N], mincost = INF;bool visit[N];void dijkstra(int s) &#123; fill(d, d + N, INF); d[s] = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; u = j; mind = d[j]; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].v; int dis = g[u][j].dis; if (!visit[v]) &#123; if (d[u] + dis &lt; d[v]) &#123; d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); &#125; else if (d[u] + dis == d[v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; tmp, res;void dfs(int t) &#123; tmp.push_back(t); if (s == t) &#123; int minc = 0; for (int i = 0; i &lt; tmp.size() - 1; i++) &#123; int id = tmp[i], nexti = tmp[i + 1]; minc += cost[id][nexti]; &#125; if (minc &lt; mincost) &#123; mincost = minc; res = tmp; &#125; tmp.pop_back(); return; &#125; for (int i = 0; i &lt; pre[t].size(); i++) &#123; dfs(pre[t][i]); &#125; tmp.pop_back();&#125;int main() &#123; int m, t, u, v, w, c; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c; cost[u][v] = cost[v][u] = c; g[u].push_back(node(v, w)); g[v].push_back(node(u, w)); &#125; dijkstra(s); dfs(t); for (int i = res.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; d[t] &lt;&lt; &quot; &quot; &lt;&lt; mincost; return 0;&#125; 1031 Hello World for U123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int len = str.size() + 2; int n = len / 3; int n2 = len - n * 3 + n - 2; for (int i = 0; i &lt; n - 1; i++) &#123; cout &lt;&lt; str[i]; for (int j = 0; j &lt; n2; j++) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; str[str.size() - 1 - i] &lt;&lt; endl; &#125; for (int i = n - 1; i &lt; n + n2 + 1; i++) &#123; cout &lt;&lt; str[i]; &#125; return 0;&#125; 1032 Sharing12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;const int N = 100001;struct node &#123; int next; char data; bool flag;&#125; nodes[N];int main() &#123; int s1, s2, n, add, next; char data; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; data &gt;&gt; next; nodes[add] = &#123;next, data, false&#125;; &#125; for (int i = s1; i != -1; i = nodes[i].next) &#123; nodes[i].flag = true; &#125; for (int i = s2; i != -1; i = nodes[i].next) &#123; if (nodes[i].flag) &#123; printf(&quot;%05d&quot;, i); return 0; &#125; &#125; cout &lt;&lt; -1; return 0;&#125; 1033 To Fill or Not to Fill错误答案（没有考虑到油箱上限） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;double, double&gt; PII;vector&lt;PII&gt; sites;int main() &#123; double c_max, d_max, d_avg, n,price, dis; cin &gt;&gt; c_max &gt;&gt; d_max &gt;&gt; d_avg &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; price &gt;&gt; dis; if (dis &gt;= d_max) continue; sites.push_back(&#123;dis, price&#125;); &#125; sort(sites.begin(), sites.end()); int cur_site = 0; double res = 0, cur_dis = 0, diff = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q; if (sites[0].first != 0) &#123; cout &lt;&lt; &quot;The maximum travel distance = 0.00&quot;; return 0; &#125; while (cur_dis &lt; d_max &amp;&amp; cur_site &lt; sites.size()) &#123; if (cur_site == sites.size() - 1) diff = d_max - cur_dis; else diff = sites[cur_site + 1].first - cur_dis; q.push(&#123;sites[cur_site++].second, c_max&#125;); while (!q.empty()) &#123; PII t = q.top(); q.pop(); if (d_avg * t.second &lt;= diff) &#123; res += t.first * t.second; diff -= d_avg * t.second; cur_dis += d_avg * t.second; &#125; else &#123; res += diff * t.first / d_avg; cur_dis += diff; q.push(&#123;t.first, t.second - diff / d_avg&#125;); diff = 0; break; &#125; &#125; if (diff &gt; 0) break; &#125; if (cur_dis == d_max) printf(&quot;%.2f&quot;, res); else printf(&quot;The maximum travel distance = %.2f&quot;, cur_dis); return 0;&#125; 柳婼的（贪心） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef pair&lt;double, double&gt; PII;int main() &#123; double c_max, d_max, d_avg, n; cin &gt;&gt; c_max &gt;&gt; d_max &gt;&gt; d_avg &gt;&gt; n; vector&lt;PII&gt; sta(n + 1); sta[0] = &#123;d_max, 0&#125;; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; sta[i].second &gt;&gt; sta[i].first; &#125; sort(sta.begin(), sta.end()); double cur_dis = 0, max_dis = 0, cur_price = 0, total_price = 0, left_dis = 0; if (sta[0].first != 0) &#123; cout &lt;&lt; &quot;The maximum travel distance = 0.00&quot;; return 0; &#125; else &#123; cur_price = sta[0].second; &#125; while (cur_dis &lt; d_max) &#123; max_dis = cur_dis + c_max * d_avg; double min_price_dis = 0, min_price = INF; int flag = 0; for (int i = 1; i &lt;= n &amp;&amp; sta[i].first &lt;= max_dis; i++) &#123; if (sta[i].first &lt;= cur_dis) continue; if (sta[i].second &lt;= cur_price) &#123; total_price += (sta[i].first - cur_dis - left_dis) * cur_price / d_avg; left_dis = 0; cur_price = sta[i].second; cur_dis = sta[i].first; flag = 1; break; &#125; if (sta[i].second &lt; min_price) &#123; min_price = sta[i].second; min_price_dis = sta[i].first; &#125; &#125; if (flag == 0 &amp;&amp; min_price != INF) &#123; total_price += (cur_price * (c_max - left_dis / d_avg)); left_dis = c_max * d_avg - (min_price_dis - cur_dis); cur_price = min_price; cur_dis = min_price_dis; &#125; if (flag == 0 &amp;&amp; min_price == INF) &#123; cur_dis += c_max * d_avg; printf(&quot;The maximum travel distance = %.2f&quot;, cur_dis); return 0; &#125; &#125; printf(&quot;%.2f&quot;, total_price); return 0;&#125; 1034 Head of a Gang并查集（写复杂了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;string, int&gt; PII;const int N = 20000;int fa[N], sum[N], maxs[N];int find(int x) &#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;int convert1(string x) &#123; return (x[0] - &#x27;A&#x27;) * 26 * 26 + (x[1] - &#x27;A&#x27;) * 26 + x[2] - &#x27;A&#x27;;&#125;string convert2(int x) &#123; string res = &quot;&quot;; res += x / (26 * 26) + &#x27;A&#x27;; res += x % (26 * 26) / 26 + &#x27;A&#x27;; res += x % 26 + &#x27;A&#x27;; return res;&#125;set&lt;int&gt; nums;struct node &#123; int a, b, time;&#125;;vector&lt;node&gt; relations;int main() &#123; int n, k, time; cin &gt;&gt; n &gt;&gt; k; string a, b; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; time; nums.insert(convert1(a)); nums.insert(convert1(b)); relations.push_back(&#123;convert1(a), convert1(b), time&#125;); &#125; for (auto i = nums.begin(); i != nums.end(); i++) &#123; fa[*i] = *i; &#125; for (int i = 0; i &lt; relations.size(); i++) &#123; int a = relations[i].a, b = relations[i].b, time = relations[i].time; if (fa[a] != fa[b]) &#123; sum[find(b)] = max(sum[find(a)], sum[find(b)]); fa[find(a)] = find(b); &#125; sum[find(b)] += time; maxs[a] += time; maxs[b] += time; &#125; set&lt;int&gt; bangs; for (auto i = nums.begin(); i != nums.end(); i++) &#123; if (sum[find(*i)] &gt; k) bangs.insert(find(*i)); &#125; vector&lt;PII&gt; res; for (auto i = bangs.begin(); i != bangs.end(); i++) &#123; set&lt;int&gt; tmp; int m = 0, r; for (int j = 0; j &lt; relations.size(); j++) &#123; if (find(*i) == find(relations[j].a)) &#123; tmp.insert(relations[j].a); tmp.insert(relations[j].b); if (m &lt; maxs[relations[j].a]) &#123; m = maxs[relations[j].a]; r = relations[j].a; &#125; if (m &lt; maxs[relations[j].b]) &#123; m = maxs[relations[j].b]; r = relations[j].b; &#125; &#125; &#125; if (tmp.size() &gt; 2) res.push_back(&#123;convert2(r), tmp.size()&#125;); &#125; cout &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot; &quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; return 0;&#125; 柳婼的（dfs） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, int&gt; stringToInt;map&lt;int, string&gt; intToString;map&lt;string, int&gt; res;int id = 1, k;int stoifun(string s) &#123; if (stringToInt[s] == 0) &#123; stringToInt[s] = id; intToString[id] = s; return id++; &#125; else &#123; return stringToInt[s]; &#125;&#125;int g[2010][2010], weight[2010];bool vis[2010];void dfs(int u, int &amp;head, int &amp;numMember, int &amp;totalweight) &#123; vis[u] = true; numMember++; if (weight[u] &gt; weight[head]) head = u; for (int v = 1; v &lt; id; v++) &#123; if (g[u][v] &gt; 0) &#123; totalweight += g[u][v]; g[u][v] = g[v][u] = 0; if (!vis[v]) dfs(v, head, numMember, totalweight); &#125; &#125;&#125;void dfsTrave() &#123; for (int i = 1; i &lt; id; i++) &#123; if (!vis[i]) &#123; int head = i, numMember = 0, totalweight = 0; dfs(i, head, numMember, totalweight); if (numMember &gt; 2 &amp;&amp; totalweight &gt; k) res[intToString[head]] = numMember; &#125; &#125;&#125;int main() &#123; int n, w; cin &gt;&gt; n &gt;&gt; k; string s1, s2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w; int id1 = stoifun(s1); int id2 = stoifun(s2); weight[id1] += w; weight[id2] += w; g[id1][id2] += w; g[id2][id1] += w; &#125; dfsTrave(); cout &lt;&lt; res.size() &lt;&lt; endl; for (auto it = res.begin(); it != res.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt; second &lt;&lt; endl; &#125; return 0;&#125; 1035 Password123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;string convert(string a) &#123; string b = &quot;&quot;; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] == &#x27;1&#x27;) b += &#x27;@&#x27;; else if (a[i] == &#x27;0&#x27;) b += &#x27;%&#x27;; else if (a[i] == &#x27;l&#x27;) b += &#x27;L&#x27;; else if (a[i] == &#x27;O&#x27;) b += &#x27;o&#x27;; else b += a[i]; &#125; return b;&#125;int main() &#123; int n; cin &gt;&gt; n; string name, password; vector&lt;pair&lt;string, string&gt; &gt; res; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; password; if (password != convert(password)) &#123; res.push_back(&#123;name, convert(password)&#125;); &#125; &#125; if (res.size() &gt; 1) &#123; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot; &quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; &#125; else if (n == 1) &#123; cout &lt;&lt; &quot;There is 1 account and no account is modified&quot;; &#125; else &#123; cout &lt;&lt; &quot;There are &quot; &lt;&lt; n &lt;&lt; &quot; accounts and no account is modified&quot;; &#125; return 0;&#125; 1036 Boys vs Girls1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name, id; int grade;&#125;;bool cmp(node a, node b) &#123; return a.grade &lt; b.grade;&#125;vector&lt;node&gt; males, famales;int main() &#123; int n; cin &gt;&gt; n; string name, gender, id; int grade; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; gender &gt;&gt; id &gt;&gt; grade; if (gender == &quot;M&quot;) &#123; males.push_back(&#123;name, id, grade&#125;); &#125; else &#123; famales.push_back(&#123;name, id, grade&#125;); &#125; &#125; bool flag = false; int diff; sort(males.begin(), males.end(), cmp); sort(famales.begin(), famales.end(), cmp); if (famales.size() &gt; 0) &#123; cout &lt;&lt; famales[famales.size() - 1].name &lt;&lt; &quot; &quot; &lt;&lt; famales[famales.size() - 1].id &lt;&lt; endl; diff = famales[famales.size() - 1].grade; &#125; else &#123; cout &lt;&lt; &quot;Absent&quot; &lt;&lt; endl; flag = true; &#125; if (males.size() &gt; 0) &#123; cout &lt;&lt; males[0].name &lt;&lt; &quot; &quot; &lt;&lt; males[0].id &lt;&lt; endl; diff += -males[0].grade; &#125; else &#123; cout &lt;&lt; &quot;Absent&quot; &lt;&lt; endl; flag = true; &#125; if (flag) cout &lt;&lt; &quot;NA&quot;; else cout &lt;&lt; diff; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); string female, male; int femalescore = -1, malescore = 101; for(int i = 0; i &lt; n; i++) &#123; string name, sex, num; int score; cin &gt;&gt; name &gt;&gt; sex &gt;&gt; num; scanf(&quot;%d&quot;, &amp;score); if(sex == &quot;F&quot;) &#123; if(femalescore &lt; score) &#123; femalescore = score; female = name + &quot; &quot; + num; &#125; &#125; else if(malescore &gt; score) &#123; malescore = score; male = name + &quot; &quot; + num; &#125; &#125; if(femalescore != -1) cout &lt;&lt; female &lt;&lt; endl; else printf(&quot;Absent &quot;); if(malescore != 101) cout &lt;&lt; male &lt;&lt; endl; else printf(&quot;Absent &quot;); if(femalescore != -1 &amp;&amp; malescore != 101) printf(&quot;%d&quot;, femalescore - malescore); else printf(&quot;NA&quot;); return 0;&#125; 1037 Magic Coupon123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;int a[N], b[N];int main() &#123; int n, m; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; b[i]; &#125; sort(a, a + n); sort(b, b + m); int al = 0, bl = 0, ar = n - 1, br = m - 1, res = 0; while(al &lt; n &amp;&amp; bl &lt; n &amp;&amp; a[al] &lt; 0 &amp;&amp; b[bl] &lt; 0) &#123; res += a[al++] * b[bl++]; &#125; while (ar &gt;= 0 &amp;&amp; br &gt;= 0 &amp;&amp; a[ar] &gt; 0 &amp;&amp; b[br] &gt; 0) &#123; res += a[ar--] * b[br--]; &#125; cout &lt;&lt; res; return 0;&#125; 1038 Recover the Smallest Number12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125;typedef long long LL;int main() &#123; int n; string x; cin &gt;&gt; n; vector&lt;string&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums.begin(), nums.end(), cmp); bool flag = true, first = true; for (int i = 0; i &lt; (LL)nums.size(); i++) &#123; if (first) &#123; int j = 0; for (; j &lt; (LL)nums[i].size(); j++) &#123; if (nums[i][j] != &#x27;0&#x27;) break; &#125; if (j &lt; (LL)nums[i].size()) first = false; for (; j &lt; (LL)nums[i].size(); j++) &#123; cout &lt;&lt; nums[i][j]; flag = false; &#125; &#125; else &#123; cout &lt;&lt; nums[i]; &#125; &#125; if (flag) cout &lt;&lt; 0; return 0;&#125; 柳婼的 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125;string str[10010];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; str[i]; sort(str, str + n, cmp); string s; for (int i = 0; i &lt; n; i++) s += str[i]; while (s.size() != 0 &amp;&amp; s[0] == &#x27;0&#x27;) s.erase(s.begin()); if (s.size() == 0) cout &lt;&lt; 0; cout &lt;&lt; s; return 0;&#125; 1039 Course List for Student1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, vector&lt;int&gt; &gt; students;int main() &#123; int n, k, courseId, m; string name; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; courseId &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; name; students[name].push_back(courseId); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; students[name].size(); sort(students[name].begin(), students[name].end()); for (int j = 0; j &lt; students[name].size(); j++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; students[name][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int getid(char *name) &#123; int id = 0; for(int i = 0; i &lt; 3; i++) id = 26 * id + (name[i] - &#x27;A&#x27;); id = id * 10 + (name[3] - &#x27;0&#x27;); return id;&#125;const int maxn = 26 * 26 * 26 * 10 + 10;vector&lt;int&gt; v[maxn];int main() &#123; int n, k, no, num, id = 0; char name[5]; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt; k; i++) &#123; scanf(&quot;%d %d&quot;, &amp;no, &amp;num); for(int j = 0; j &lt; num; j++) &#123; scanf(&quot;%s&quot;, name); id = getid(name); v[id].push_back(no); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, name); id = getid(name); sort(v[id].begin(), v[id].end()); printf(&quot;%s %lu&quot;, name, v[id].size()); for(int j = 0; j &lt; v[id].size(); j++) printf(&quot; %d&quot;, v[id][j]); printf(&quot; &quot;); &#125; return 0;&#125; 1040 Longest Symmetric String12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1005;bool dp[N][N];int main() &#123; string str; getline(cin, str); int n = str.size(), res = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i][i] = true; if (i &lt; n - 1 &amp;&amp; str[i] == str[i + 1]) &#123; dp[i][i + 1] = true; res = 2; &#125; &#125; for (int len = 3; len &lt;= n; len++) &#123; for (int l = 0; l &lt; n - len + 1; l++) &#123; int r = l + len - 1; if (str[l] == str[r] &amp;&amp; dp[l + 1][r - 1]) &#123; dp[l][r] = true; res = len; &#125; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1041 Be Unique1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int N = 100005;int nums[N], cnt[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; cnt[nums[i]] ++; &#125; for (int i = 0; i &lt; n; i++) &#123; if (cnt[nums[i]] == 1) &#123; cout &lt;&lt; nums[i]; return 0; &#125; &#125; cout &lt;&lt; &quot;None&quot;; return 0;&#125; 1042 Shuffling Machine123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string nums[55] = &#123;&quot; &quot;,&quot;S1&quot;,&quot;S2&quot;,&quot;S3&quot;,&quot;S4&quot;,&quot;S5&quot;,&quot;S6&quot;,&quot;S7&quot;,&quot;S8&quot;,&quot;S9&quot;,&quot;S10&quot;,&quot;S11&quot;,&quot;S12&quot;,&quot;S13&quot;,&quot;H1&quot;,&quot;H2&quot;,&quot;H3&quot;,&quot;H4&quot;,&quot;H5&quot;,&quot;H6&quot;,&quot;H7&quot;,&quot;H8&quot;,&quot;H9&quot;,&quot;H10&quot;,&quot;H11&quot;,&quot;H12&quot;,&quot;H13&quot;,&quot;C1&quot;,&quot;C2&quot;,&quot;C3&quot;,&quot;C4&quot;,&quot;C5&quot;,&quot;C6&quot;,&quot;C7&quot;,&quot;C8&quot;,&quot;C9&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;,&quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;,&quot;D4&quot;,&quot;D5&quot;,&quot;D6&quot;,&quot;D7&quot;,&quot;D8&quot;,&quot;D9&quot;,&quot;D10&quot;,&quot;D11&quot;,&quot;D12&quot;,&quot;D13&quot;,&quot;J1&quot;, &quot;J2&quot;&#125;;int shuff[55];int main () &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt; 55; i++) &#123; cin &gt;&gt; shuff[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; string tmps[55]; for (int j = 1; j &lt; 55; j++) &#123; tmps[shuff[j]] = nums[j]; &#125; copy(begin(tmps), end(tmps), begin(nums)); &#125; for (int i = 1; i &lt; 55; i++) &#123; cout &lt;&lt; nums[i]; if (i &lt; 54) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 柳婼的 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main () &#123; int cnt; cin &gt;&gt; cnt; int start[55], end[55], scan[55]; for (int i = 1; i &lt; 55; i++) &#123; cin &gt;&gt; scan[i]; end[i] = i; &#125; for (int i = 0; i &lt; cnt; i++) &#123; for (int j = 1; j &lt; 55; j++) start[j] = end[j]; for (int k = 1; k &lt; 55; k++) end[scan[k]] = start[k]; &#125; char c[6] = &#123;&quot;SHCDJ&quot;&#125;; for (int i = 1; i &lt; 55; i++) &#123; end[i] = end[i] - 1; cout &lt;&lt; c[end[i] / 13] &lt;&lt; end[i] % 13 + 1; if (i != 54) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1043 Is It a Binary Search Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool isMirror;vector&lt;int&gt; pre, post;void getpost(int root, int tail) &#123; if (root&gt; tail) return; int i = root + 1, j = tail; if (!isMirror) &#123; while (i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) i++; while (j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) j--; &#125; else &#123; while (i &lt;= tail &amp;&amp; pre[root] &lt;= pre[i]) i++; while (j &gt; root &amp;&amp; pre[root] &gt; pre[j]) j--; &#125; if (i - j != 1) return; getpost(root + 1, j); getpost(i, tail); post.push_back(pre[root]);&#125;int main() &#123; int n; cin &gt;&gt; n; pre.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; &#125; getpost(0, n - 1); if (post.size() != n) &#123; isMirror = true; post.clear(); getpost(0, n - 1); &#125; if (post.size() == n) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; post[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; &#125; else &#123; cout &lt;&lt; &quot;NO&quot;; &#125; return 0;&#125; 1044 Shopping in Mars滑动窗口 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int N = 100005;vector&lt;pair&lt;int, int&gt; &gt; res;int nums[N];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int tmp = 0, maxn = 0x3f3f3f3f; int l = 0, r = 0; while (r &lt; n) &#123; tmp += nums[r]; if (tmp &gt;= m &amp;&amp; tmp &lt; maxn) maxn = tmp; if (tmp == maxn) res.push_back(&#123;l + 1, r + 1&#125;); while (l &lt; r &amp;&amp; tmp &gt;= m) &#123; if (maxn &gt; tmp) &#123; maxn = tmp; res.clear(); if (tmp == maxn) res.push_back(&#123;l + 1, r + 1&#125;); &#125; tmp -= nums[l++]; if (tmp == maxn) res.push_back(&#123;l + 1, r + 1&#125;); &#125; r++; &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot;-&quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; return 0;&#125; 柳婼的（二分） 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; sum, res;int n, m;void search(int i, int &amp;j, int &amp;tmp) &#123; int l = i, r = n; while (l &lt; r) &#123; int mid = (l + r) / 2; if (sum[mid] - sum[i - 1] &gt;= m) r = mid; else l = mid + 1; &#125; j = r; tmp = sum[j] - sum[i - 1];&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; sum.resize(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; sum[i]; sum[i] += sum[i - 1]; &#125; int minres = sum[n]; for (int i = 1; i &lt;= n; i++) &#123; int j, tmpsum; search(i, j, tmpsum); if (tmpsum &gt; minres) continue; if (tmpsum &gt;= m) &#123; if (tmpsum &lt; minres) &#123; res.clear(); minres = tmpsum; &#125; res.push_back(i); res.push_back(j); &#125; &#125; for (int i = 0; i &lt; res.size(); i += 2) cout &lt;&lt; res[i] &lt;&lt; &quot;-&quot; &lt;&lt; res[i + 1] &lt;&lt; endl; return 0;&#125; 1045 Favorite Color Stripe动态规划 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[10001], b[201], a[10001];int main() &#123; int n, m, x, l, num = 0, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x; b[x] = i; &#125; cin &gt;&gt; l; for (int i = 0; i &lt; l; i++) &#123; cin &gt;&gt; x; if (b[x] &gt;= 1) a[num++] = b[x]; &#125; for (int i = 0; i &lt; num; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (a[i] &gt;= a[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; res = max(dp[i], res); &#125; cout &lt;&lt; res; return 0;&#125; 1046 Shortest Distance前缀和 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200001;int nums[N], sums[N];int main() &#123; int n, m, a, b; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; nums[i]; nums[i + n] = nums[i]; sums[i] = sums[i - 1] + nums[i]; &#125; for (int i = n + 1; i &lt; n + n; i++) &#123; sums[i] = sums[i - 1] + nums[i]; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &gt; b) swap(a, b); cout &lt;&lt; min(sums[b - 1] - sums[a - 1], sums[a + n - 1] - sums[b - 1]) &lt;&lt; endl; &#125; return 0;&#125; 1047 Student List for Course1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt; course[2501];int main() &#123; int n, k, c, x; string name; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; c; for (int j = 0; j &lt; c; j++) &#123; cin &gt;&gt; x; course[x].push_back(name); &#125; &#125; for (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; course[i].size() &lt;&lt; endl; sort(course[i].begin(), course[i].end()); for (int j = 0; j &lt; course[i].size(); j++) &#123; printf(&quot;%s &quot;, course[i][j].c_str()); &#125; &#125; return 0;&#125; 1048 Find Coins双指针 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int nums[N];int main() &#123; int n, m, cnt = 0, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (x &lt; m) nums[cnt++] = x; &#125; sort(nums, nums + cnt); int l = 0, r = cnt - 1, tmp = nums[l] + nums[r]; while (l &lt; r) &#123; if (tmp == m) &#123; cout &lt;&lt; nums[l] &lt;&lt; &quot; &quot; &lt;&lt; nums[r]; return 0; &#125; else if (tmp &gt; m) &#123; r--; &#125; else &#123; l++; &#125; tmp = nums[l] + nums[r]; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125; 柳婼的 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int nums[1001];int main() &#123; int n, m, cnt = 0, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; nums[x] ++; &#125; for (int i = 0; i &lt; 1001; i++) &#123; if (nums[i]) &#123; nums[i]--; if (m &gt; i &amp;&amp; nums[m - i]) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; m - i; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125; 1049 Counting Ones暴力（超时） 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int a = i; while (a) &#123; if (a % 10 == 1) cnt++; a /= 10; &#125; &#125; cout &lt;&lt; cnt; return 0;&#125; 柳婼的 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, left = 0, right = 0, a = 1, now = 1, res = 0; cin &gt;&gt; n; while (n / a) &#123; left = n / (a * 10), now = n / a % 10, right = n % a; if (now == 0) res += left * a; else if (now == 1) res += left * a + right + 1; else res += (left + 1) * a; a = a * 10; &#125; cout &lt;&lt; res; return 0;&#125; 1050 String Subtraction1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;string s1, s2;bool nums[129];int main() &#123; getline(cin, s1); getline(cin, s2); for (auto i: s2) &#123; nums[i] = true; &#125; for (auto i: s1) &#123; if (!nums[i]) cout &lt;&lt; i; &#125; return 0;&#125; 1051 Pop Sequence123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; int m, n, k, x; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; int cnt = 1; stack&lt;int&gt; st; bool flag = true; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; x; while (x &gt;= cnt &amp;&amp; st.size() &lt; m &amp;&amp; cnt &lt;= n) &#123; st.push(cnt); cnt++; &#125; if (st.top() != x) &#123; flag = false; while (j++ &lt; n - 1) cin &gt;&gt; x; break; &#125; st.pop(); &#125; cout &lt;&lt; (flag ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; &#125; return 0;&#125; 1052 Linked List Sorting1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct node &#123; int add, key, next;&#125;;bool cmp(PII a, PII b) &#123; return a.second &lt; b.second;&#125;const int INF = 0x3f3f3f3f;const int N = 100001;node nums[N];vector&lt;PII&gt; nums2;int main() &#123; int n, head, add, key, nex; cin &gt;&gt; n &gt;&gt; head; if (head == -1) &#123; cout &lt;&lt; &quot;0 -1&quot;; return 0; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; key &gt;&gt; nex; nums[add] = &#123;add, key, nex&#125;; &#125; while (head != -1) &#123; nums2.push_back(&#123;head, nums[head].key&#125;); head = nums[head].next; &#125; sort(nums2.begin(), nums2.end(), cmp); printf(&quot;%d %05d &quot;, nums2.size(), nums2[0].first); for (int i = 0; i &lt; nums2.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, nums2[i].first, nums2[i].second, nums2[i + 1].first); &#125; printf(&quot;%05d %d -1 &quot;, nums2[nums2.size() - 1].first, nums2[nums2.size() - 1].second); return 0;&#125; 1053 Path of Equal Weight1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;int weight[N], sum, s;vector&lt;int&gt; trees[N], tmp;vector&lt;vector&lt;int&gt; &gt; res;bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123; for (int i = 0; ; i++) &#123; if (a[i] != b[i]) return a[i] &gt; b[i]; &#125;&#125;void dfs(int x) &#123; if (sum == s &amp;&amp; trees[x].empty()) &#123; res.push_back(tmp); return; &#125; if (sum &gt; s) return; for (int i = 0; i &lt; trees[x].size(); i++) &#123; sum += weight[trees[x][i]]; tmp.push_back(weight[trees[x][i]]); dfs(trees[x][i]); sum -= weight[trees[x][i]]; tmp.pop_back(); &#125;&#125;int main() &#123; int n, m, cur, k, child; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; s -= weight[0]; tmp.push_back(weight[0]); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; cur &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; trees[cur].push_back(child); &#125; &#125; dfs(0); sort(res.begin(), res.end(), cmp); for (int i = 0; i &lt; res.size(); i++) &#123; for (int j = 0; j &lt; res[i].size(); j++) &#123; printf(&quot;%d&quot;, res[i][j]); if (j &lt; res[i].size() - 1) printf(&quot; &quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125; 1054 The Dominant Color12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;map&lt;int, int&gt; nums;vector&lt;pair&lt;int, int&gt; &gt; res;bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.second &gt; b.second;&#125;int main() &#123; int m, n, x; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; nums[x]++; &#125; &#125; for (auto it: nums) &#123; res.push_back(it); &#125; sort(res.begin(), res.end(), cmp); cout &lt;&lt; res[0].first; return 0;&#125; 柳婼的 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; nums;int main() &#123; int m, n, x; cin &gt;&gt; m &gt;&gt; n; int half = m * n / 2; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; nums[x]++; if (nums[x] &gt; half) &#123; cout &lt;&lt; x; return 0; &#125; &#125; &#125; return 0;&#125; 1055 The World’s Richest123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int age, worth;&#125;;bool cmp(node a, node b) &#123; if (a.worth != b.worth) return a.worth &gt; b.worth; else if (a.age != b.age) return a.age &lt; b.age; else return a.name &lt; b.name;&#125;vector&lt;node&gt; nums[201];int main() &#123; int n, k, age, worth, m, start, end; cin &gt;&gt; n &gt;&gt; k; string name; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; age &gt;&gt; worth; nums[age].push_back(&#123;name, age, worth&#125;); &#125; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; m &gt;&gt; start &gt;&gt; end; if (start &lt; 1) start = 1; if (end &gt; 200) end = 200; vector&lt;node&gt; tmp; for (int j = start; j &lt;= end; j++) &#123; for (auto it: nums[j]) &#123; tmp.push_back(&#123;it.name, it.age, it.worth&#125;); &#125; &#125; sort(tmp.begin(), tmp.end(), cmp); printf(&quot;Case #%d: &quot;, i); for (int j = 0; j &lt; min((int)tmp.size(), m); j++) &#123; printf(&quot;%s %d %d &quot;, tmp[j].name.c_str(), tmp[j].age, tmp[j].worth); &#125; if (tmp.empty()) printf(&quot;None&quot;); &#125; return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int age, worth;&#125; nums[100001];bool cmp(node a, node b) &#123; if (a.worth != b.worth) return a.worth &gt; b.worth; else if (a.age != b.age) return a.age &lt; b.age; else return a.name &lt; b.name;&#125;int main() &#123; int n, k, age, worth, m, start, end; cin &gt;&gt; n &gt;&gt; k; string name; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].name &gt;&gt; nums[i].age &gt;&gt; nums[i].worth; &#125; sort(nums, nums + n, cmp); for (int i = 1; i &lt;= k; i++) &#123; printf(&quot;Case #%d: &quot;, i); cin &gt;&gt; m &gt;&gt; start &gt;&gt; end; int cnt = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[j].age &gt;= start &amp;&amp; nums[j].age &lt;= end) &#123; printf(&quot;%s %d %d &quot;, nums[j].name.c_str(), nums[j].age, nums[j].worth); cnt++; &#125; if (cnt == m) break; &#125; if (cnt == 0) printf(&quot;None&quot;); &#125; return 0;&#125; 1056 Mice and Rice1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int weight[10001], ranks[10001];vector&lt;int&gt; tmp, res[300];int main() &#123; int np, ng, x; cin &gt;&gt; np &gt;&gt; ng; for (int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; weight[i]; &#125; for (int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; x; tmp.push_back(x); &#125; int depth = 0, d = np / ng + 1; while (d--) &#123; for (int i = 0; i &lt; tmp.size(); i += ng) &#123; int ma = 0, idx = 0; for (int j = i; j &lt; min(ng + i, (int)tmp.size()); j++) &#123; if (weight[tmp[j]] &gt; ma) &#123; ma = weight[tmp[j]]; idx = tmp[j]; &#125; &#125; res[depth + 1].push_back(idx); for (int j = i; j &lt; min(ng + i, (int)tmp.size()); j++) &#123; if (tmp[j] != idx) res[depth].push_back(tmp[j]); &#125; &#125; tmp.clear(); tmp = res[depth + 1]; res[depth + 1].clear(); depth++; &#125; int rank = 1; ranks[tmp[0]] = rank++; for (int i = depth - 1; i &gt;= 0; i--) &#123; for (auto it: res[i]) &#123; ranks[it] = rank; &#125; rank += res[i].size(); &#125; for (int i = 0; i &lt; np; i++) &#123; cout &lt;&lt; ranks[i]; if (i &lt; np - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1057 Stack暴力（超时） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;stack&lt;int&gt; st;vector&lt;int&gt; tmp;int main() &#123; int n, x; string op; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; op; if (op == &quot;Pop&quot;) &#123; if (st.empty()) cout &lt;&lt; &quot;Invalid&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; st.top() &lt;&lt; endl; tmp.erase(find(tmp.begin(), tmp.end(), st.top())); st.pop(); &#125; &#125; else if (op == &quot;Push&quot;) &#123; cin &gt;&gt; x; st.push(x); tmp.push_back(x); &#125; else if (op == &quot;PeekMedian&quot;) &#123; if (st.empty()) cout &lt;&lt; &quot;Invalid&quot; &lt;&lt; endl; else &#123; sort(tmp.begin(), tmp.end()); if (tmp.size() % 2) cout &lt;&lt; tmp[(tmp.size() - 1) / 2] &lt;&lt; endl; else cout &lt;&lt; tmp[tmp.size() / 2 - 1] &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 柳婼的（树状数组） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define lowbit(i) ((i) &amp; (-i))const int N = 100010;int c[N];stack&lt;int&gt; s;void update(int x, int v) &#123; for (int i = x; i &lt; N; i += lowbit(i)) c[i] += v;&#125;int getsum(int x) &#123; int sum = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) sum += c[i]; return sum;&#125;void PeekMedian() &#123; int left = 1, right = N, mid, k = (s.size() + 1) / 2; while (left &lt; right) &#123; mid = (left + right) / 2; if (getsum(mid) &gt;= k) right = mid; else left = mid + 1; &#125; printf(&quot;%d &quot;, left);&#125;int main() &#123; int n, tmp; scanf(&quot;%d&quot;, &amp;n); char str[15]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, str); if (str[1] == &#x27;u&#x27;) &#123; scanf(&quot;%d&quot;, &amp;tmp); s.push(tmp); update(tmp, 1); &#125; else if (str[1] == &#x27;o&#x27;) &#123; if (!s.empty()) &#123; update(s.top(), -1); printf(&quot;%d &quot;, s.top()); s.pop(); &#125; else &#123; printf(&quot;Invalid &quot;); &#125; &#125; else &#123; if (!s.empty()) PeekMedian(); else printf(&quot;Invalid &quot;); &#125; &#125; return 0;&#125; 1058 A+B in Hogwarts - PAT (Advanced Level) Practice (pintia.cn)123456789101112#include &lt;iostream&gt;int main() &#123; int a1, a2, a3, b1, b2, b3, c1, c2, c3, t; scanf(&quot;%d.%d.%d %d.%d.%d&quot;, &amp;a1, &amp;a2, &amp;a3, &amp;b1, &amp;b2, &amp;b3); c3 = (a3 + b3) % 29; t = (a3 + b3) / 29; c2 = (a2 + b2 + t) % 17; t = (a2 + b2 + t) / 17; c1 = a1 + b1 + t; printf(&quot;%d.%d.%d&quot;, c1, c2, c3); return 0;&#125; 1059 Prime Factors123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;int main() &#123; LL n; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; &quot;=&quot;; if (n == 1) cout &lt;&lt; 1; for (LL i = 2; i &lt;= sqrt(n); i++) &#123; int cnt = 0; if (n % i == 0) &#123; while (n % i == 0) &#123; cnt++; n /= i; &#125; &#125; if (cnt &gt; 1) cout &lt;&lt; i &lt;&lt; &quot;^&quot; &lt;&lt; cnt; else if (cnt == 1) cout &lt;&lt; i; if (cnt != 0 &amp;&amp; n &gt; 1) cout &lt;&lt; &quot;*&quot;; &#125; if (n &gt; 1) cout &lt;&lt; n; return 0;&#125; 1060 Are They Equal1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string convert(string str, int n) &#123; int idx = 0, len = str.size(), k = 0; string t; while (idx &lt; len &amp;&amp; str[idx] == &#x27;0&#x27;) idx++; if (str[idx] == &#x27;.&#x27;) &#123; idx++; while (idx &lt; len &amp;&amp; str[idx] == &#x27;0&#x27;) &#123; idx++; k--; &#125; bool flag = false; while (t.size() &lt; n &amp;&amp; idx &lt; len) &#123; t.push_back(str[idx++]); flag = true; &#125; while (t.size() &lt; n) t.push_back(&#x27;0&#x27;); if (!flag) k = 0; &#125; else &#123; for (int j = idx; str[j] != &#x27;.&#x27; &amp;&amp; j &lt; len; j++) k++; while (str[idx] != &#x27;.&#x27; &amp;&amp; t.size() &lt; n &amp;&amp; idx &lt; len) t.push_back(str[idx++]); if (t.size() &lt; n) idx++; while (idx &lt; len &amp;&amp; t.size() &lt; n) t.push_back(str[idx++]); while (t.size() &lt; n) t.push_back(&#x27;0&#x27;); &#125; return &quot;0.&quot; + t + &quot;*10^&quot; + to_string(k);&#125;int main() &#123; int n; string a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; a = convert(a, n); b = convert(b, n); if (a == b) cout &lt;&lt; &quot;YES &quot; &lt;&lt; a; else cout &lt;&lt; &quot;NO &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b; return 0;&#125; 1061 Dating12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int sa = a.size(), sb = b.size(), sc = c.size(), sd = d.size(); int week, hour, minute, cnt = 0; string weeks[7] = &#123;&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;&#125;; bool is_first = true; for (int i = 0; i &lt; min(sa, sb); i++) &#123; if (a[i] == b[i] &amp;&amp; a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;G&#x27; &amp;&amp; is_first) &#123; week = a[i] - &#x27;A&#x27;; is_first = false; continue; &#125; if (!is_first &amp;&amp; a[i] == b[i] &amp;&amp; ((a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;N&#x27;) || isdigit(a[i]))) &#123; if (a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;N&#x27;) &#123; hour = a[i] - &#x27;A&#x27; + 10; &#125; else if (isdigit(a[i])) &#123; hour = a[i] - &#x27;0&#x27;; &#125; break; &#125; &#125; for (int i = 0; i &lt; min(sc, sd); i++) &#123; if (c[i] == d[i] &amp;&amp; isalpha(c[i])) &#123; minute = i; break; &#125; &#125; printf(&quot;%s %02d:%02d&quot;, weeks[week].c_str(), hour, minute); return 0;&#125; 1062 Talent and Virtue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int num, virtue, talent, sum;&#125;;bool cmp(node a, node b) &#123; if (a.sum != b.sum) return a.sum &gt; b.sum; else if (a.virtue != b.virtue) return a.virtue &gt; b.virtue; else if (a.talent != b.talent) return a.talent &gt; b.talent; else return a.num &lt; b.num;&#125;vector&lt;node&gt; sage, nobleman, fool, small;int main() &#123; int n, l, h, num, virtue, talent; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num &gt;&gt; virtue &gt;&gt; talent; int sum = virtue + talent; if (virtue &gt;= h &amp;&amp; talent &gt;= h) &#123; sage.push_back(&#123;num, virtue, talent, sum&#125;); &#125; else if (virtue &gt;= h &amp;&amp; talent &gt;= l) &#123; nobleman.push_back(&#123;num, virtue, talent, sum&#125;); &#125; else if (virtue &gt;= talent &amp;&amp; talent &gt;= l) &#123; fool.push_back(&#123;num, virtue, talent, sum&#125;); &#125; else if (virtue &gt;= l &amp;&amp; talent &gt;= l) &#123; small.push_back(&#123;num, virtue, talent, sum&#125;); &#125; &#125; sort(sage.begin(), sage.end(), cmp); sort(nobleman.begin(), nobleman.end(), cmp); sort(fool.begin(), fool.end(), cmp); sort(small.begin(), small.end(), cmp); cout &lt;&lt; sage.size() + nobleman.size() + fool.size() + small.size()&lt;&lt; endl; for (auto it: sage) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; for (auto it: nobleman) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; for (auto it: fool) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; for (auto it: small) &#123; printf(&quot;%08d %d %d &quot;, it.num, it.virtue, it.talent); &#125; return 0;&#125; 1063 Set Similarity123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, bool&gt; nums[51];int main() &#123; int n, m, x, k, a, b; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); nums[i][x] = true; &#125; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; map&lt;int, bool&gt; tmp; tmp = nums[a]; int common = 0, total = 0; for (auto it: nums[b]) &#123; if (tmp[it.first]) &#123; tmp[it.first] = false; common++; total++; &#125; else &#123; total++; &#125; &#125; for (auto it: tmp) &#123; if (it.second) total++; &#125; printf(&quot;%.1f\\% &quot;, common * 100.0 / total); &#125; return 0;&#125; 1064 Complete Binary Search Tree123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1001;int in[N], level[N], n, idx = 0;void dfs(int root) &#123; if (root &gt;= n) return; dfs(root * 2 + 1); level[root] = in[idx++]; dfs(root * 2 + 2);&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; sort(in, in + n); dfs(0); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; level[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1065 A+B and C (64bit)12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;typedef long long LL;int main() &#123; int n; LL a, b, c; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; LL t = a + b; if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt; 0) &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: true&quot; &lt;&lt; endl; &#125; else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; t &gt; 0) &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: false&quot; &lt;&lt; endl; &#125; else if (a + b &gt; c) &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: true&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: false&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 1066 Root of AVL Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;struct node &#123; int val; node *left, *right;&#125;;node* rotateLeft(node* root) &#123; node *t = root-&gt;right; root-&gt;right = t-&gt;left; t-&gt;left = root; return t;&#125;node* rotateRight(node* root) &#123; node *t = root-&gt;left; root-&gt;left = t-&gt;right; t-&gt;right = root; return t;&#125;node* rotateLeftRight(node* root) &#123; root-&gt;left = rotateLeft(root-&gt;left); return rotateRight(root);&#125;node* rotateRightLeft(node* root) &#123; root-&gt;right = rotateRight(root-&gt;right); return rotateLeft(root);&#125;int getHeight(node* root) &#123; if (root == NULL) return 0; return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;&#125;node* insert(node* root, int val) &#123; if (root == NULL) &#123; root = new node(); root-&gt;val = val; root-&gt;left = NULL; root-&gt;right = NULL; &#125; else if (val &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, val); if (getHeight(root-&gt;left) - getHeight(root-&gt;right) == 2) &#123; root = val &lt; root-&gt;left-&gt;val ? rotateRight(root) : rotateLeftRight(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, val); if (getHeight(root-&gt;right) - getHeight(root-&gt;left) == 2) &#123; root = val &gt; root-&gt;right-&gt;val ? rotateLeft(root) : rotateRightLeft(root); &#125; &#125; return root;&#125;int main() &#123; int n, val; cin &gt;&gt; n; node *root = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; val; root = insert(root, val); &#125; cout &lt;&lt; (&quot;%d&quot;, root-&gt;val); return 0;&#125; 1067 Sort with Swap(0, i)1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];int main() &#123; int n, x, res = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;x); nums[x] = i; &#125; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] != i) &#123; while (nums[0] != 0) &#123; swap(nums[0], nums[nums[0]]); res++; &#125; if (nums[i] != i) &#123; swap(nums[0], nums[i]); res++; &#125; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1068 Find More Coinsdfs 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int nums[10001], n, m;vector&lt;int&gt; tmp;void dfs(int x, int t) &#123; if (t == m) &#123; for (int i = 0; i &lt; tmp.size(); i++) &#123; cout &lt;&lt; tmp[i]; if (i &lt; tmp.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; exit(0); &#125; if (t &gt; m || x == n) return; tmp.push_back(nums[x]); dfs(x + 1, t + nums[x]); tmp.pop_back(); dfs(x + 1, t);&#125;int main() &#123; int sum = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; sum += nums[i]; &#125; if (sum &lt; m) cout &lt;&lt; &quot;No Solution&quot;; else &#123; sort(nums, nums + n); dfs(0, 0); cout &lt;&lt; &quot;No Solution&quot;; &#125; return 0;&#125; 柳婼的（dp） 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int dp[100001], nums[100001];bool choice[100001][110];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums + 1, nums + n + 1, greater&lt;int&gt;()); for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= nums[i]; j--) &#123; if (dp[j] &lt;= dp[j - nums[i]] + nums[i]) &#123; choice[i][j] = true; dp[j] = dp[j - nums[i]] + nums[i]; &#125; &#125; &#125; if (dp[m] != m) cout &lt;&lt; &quot;No Solution&quot;; else &#123; vector&lt;int&gt; res; int v = m, idx = n; while(v &gt; 0) &#123; if (choice[idx][v] == true) &#123; res.push_back(nums[idx]); v -= nums[idx]; &#125; idx--; &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; &#125; return 0;&#125; 1069 The Black Hole of Numbers12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string n; cin &gt;&gt; n; while(n.size() &lt; 4) n = &#x27;0&#x27; + n; do &#123; string a = n, b = n; sort(a.begin(), a.end()); sort(b.begin(), b.end(), greater&lt;char&gt;()); int c = stoi(b) - stoi(a); n = to_string(c); while(n.size() &lt; 4) n = &#x27;0&#x27; + n; cout &lt;&lt; b &lt;&lt; &quot; - &quot; &lt;&lt; a &lt;&lt; &quot; = &quot; &lt;&lt; n &lt;&lt; endl; &#125; while (n != &quot;6174&quot; &amp;&amp; n!= &quot;0000&quot;); return 0;&#125; 1070 Mooncake123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; double amount, price, profit;&#125; nums[1001];bool cmp(node &amp;a, node &amp;b) &#123; return a.profit &gt; b.profit;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].amount; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].price; nums[i].profit = nums[i].price / nums[i].amount; &#125; sort(nums, nums + n, cmp); double res; for (int i = 0; i &lt; n; i++) &#123; if (nums[i].amount &gt;= m) &#123; res += m * nums[i].profit; break; &#125; else &#123; res += nums[i].price; m -= nums[i].amount; &#125; &#125; printf(&quot;%.2f&quot;, res); return 0;&#125; 1071 Speech Patterns1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; nums;int main() &#123; string str; getline(cin, str); str += &#x27;.&#x27;; for (int i = 0; i &lt; str.size(); i++) &#123; for (int j = i; j &lt; str.size(); j++) &#123; if (isalpha(str[j])) str[j] = tolower(str[j]); if (!isalnum(str[j])) &#123; if (j != i) &#123; nums[str.substr(i, j - i)]++; &#125; i = j; break; &#125; &#125; &#125; string res = nums.begin()-&gt;first; int m = nums.begin()-&gt;second; for (auto it: nums) &#123; if (m &lt; it.second) &#123; m = it.second; res = it.first; &#125; &#125; cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; m; return 0;&#125; 1072 Gas Stationdijkstra 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int N = 1012;const int INF = 0x3f3f3f3f;vector&lt;pair&lt;int, int&gt; &gt; g[N];int dist[N], n, m, sums[11], mins[11];bool visit[N];void dijkstra(int x) &#123; fill(dist, dist + N, INF); fill(visit, visit + N, false); dist[x] = 0; for (int i = 0; i &lt; n + m; i++) &#123; int u = -1, mind = INF; for (int j = 1; j &lt;= n + m; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; dist[j]) &#123; mind = dist[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v] &amp;&amp; dist[v] &gt; dist[u] + dis) &#123; dist[v] = dist[u] + dis; &#125; &#125; &#125;&#125;int main() &#123; int k, d, dis, t1, t2; string p1, p2; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis; if (p1[0] == &#x27;G&#x27;) t1 = n + stoi(p1.substr(1)); else t1 = stoi(p1); if (p2[0] == &#x27;G&#x27;) t2 = n + stoi(p2.substr(1)); else t2 = stoi(p2); g[t1].push_back(&#123;t2, dis&#125;); g[t2].push_back(&#123;t1, dis&#125;); &#125; int real_sum = INF, real_min = 0, real_id = 0; for (int i = 1; i &lt;= m; i++) &#123; dijkstra(n + i); int res = INF, sum = 0; bool flag = true; for (int j = 1; j &lt;= n; j++) &#123; if (dist[j] &gt; d) &#123; flag = false; break; &#125; sum += dist[j]; res = min(res, dist[j]); &#125; if (flag) &#123; if (real_min &lt; res) &#123; real_sum = sum; real_id = i; real_min = res; &#125; else if (real_min == res) &#123; if (real_sum &gt; sum) &#123; real_sum = sum; real_id = i; &#125; &#125; &#125; &#125; if (real_min == 0) cout &lt;&lt; &quot;No Solution&quot;; else printf(&quot;G%d %.1f %.1f&quot;, real_id, (double)real_min, (double)real_sum / n); return 0;&#125; 1073 Scientific Notation123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; if (str[0] == &#x27;-&#x27;) cout &lt;&lt; &quot;-&quot;; int exp, i; for (i = 3; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;E&#x27;) break; &#125; if (str[i + 1] == &#x27;-&#x27;) &#123; exp = stoi(str.substr(i + 2)); cout &lt;&lt; &quot;0.&quot;; for (int j = 0; j &lt; exp - 1; j++) cout &lt;&lt; 0; cout &lt;&lt; str[1] &lt;&lt; str.substr(3, i - 3); &#125; else &#123; exp = stoi(str.substr(i + 1)); if (str[1] != &#x27;0&#x27;) cout &lt;&lt; str[1]; if (exp &lt; i - 3) &#123; for (int j = 0; j &lt; exp; j++) &#123; cout &lt;&lt; str[j + 3]; &#125; cout &lt;&lt; &quot;.&quot;; for (int j = exp; j &lt; i - 3; j++) &#123; cout &lt;&lt; str[j + 3]; &#125; &#125; else &#123; for (int j = 0; j &lt; exp; j++) &#123; if (j &lt; i - 3) cout &lt;&lt; str[j + 3]; else cout &lt;&lt; 0; &#125; &#125; &#125; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int i = 0; while (s[i] != &#x27;E&#x27;) i++; string t = s.substr(1, i - 1); int n = stoi(s.substr(i + 1)); if (s[0] == &#x27;-&#x27;) cout &lt;&lt; &quot;-&quot;; if (n &lt; 0) &#123; cout &lt;&lt; &quot;0.&quot;; for (int j = 0; j &lt; abs(n) - 1; j++) cout &lt;&lt; &#x27;0&#x27;; for (int j = 0; j &lt; t.length(); j++) if (t[j] != &#x27;.&#x27;) cout &lt;&lt; t[j]; &#125; else &#123; cout &lt;&lt; t[0]; int cnt, j; for (j = 2, cnt = 0; j &lt; t.length() &amp;&amp; cnt &lt; n; j++, cnt++) cout &lt;&lt; t[j]; if (j == t.length()) &#123; for (int k = 0; k &lt; n - cnt; k++) cout &lt;&lt; &#x27;0&#x27;; &#125; else &#123; cout &lt;&lt; &#x27;.&#x27;; for (int k = j; k &lt; t.length(); k++) cout &lt;&lt; t[k]; &#125; &#125; return 0;&#125; 1074 Reversing Linked List数组模拟 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct node &#123; string addr, nex; int val;&#125; ;map&lt;string, node&gt; nums1;vector&lt;node&gt; nums2;int main() &#123; int n, k, val; string start, addr, nex; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; addr &gt;&gt; val &gt;&gt; nex; nums1[addr] = &#123;addr, nex, val&#125;; &#125; while (start != &quot;-1&quot;) &#123; nums2.push_back(&#123;nums1[start].addr, nums1[start].nex, nums1[start].val&#125;); start = nums1[start].nex; &#125; for (i = 0; i &lt;= nums2.size() - k; i += k) &#123; for (int j = i + k - 1; j &gt; i; j--) &#123; cout &lt;&lt; nums2[j].addr &lt;&lt; &quot; &quot; &lt;&lt; nums2[j].val &lt;&lt; &quot; &quot; &lt;&lt; nums2[j - 1].addr &lt;&lt; endl; &#125; cout &lt;&lt; nums2[i].addr &lt;&lt; &quot; &quot; &lt;&lt; nums2[i].val &lt;&lt; &quot; &quot;; if (i + 2 * k &lt;= nums2.size()) cout &lt;&lt; nums2[i + 2 * k - 1].addr &lt;&lt; endl; else if (i + k &lt; nums2.size()) cout &lt;&lt; nums2[i + k].addr &lt;&lt; endl; else cout &lt;&lt; &quot;-1 &quot;; &#125; for (int j = i; j &lt; nums2.size(); j++) &#123; cout &lt;&lt; nums2[j].addr &lt;&lt; &quot; &quot; &lt;&lt; nums2[j].val &lt;&lt; &quot; &quot; &lt;&lt; nums2[j].nex &lt;&lt; endl; &#125; return 0;&#125; 柳婼的 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N = 100005;int datas[N], nexts[N], list[N], res[N];int main() &#123; int first, k, n, sum = 0, tmp; cin &gt;&gt; first &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; cin &gt;&gt; datas[tmp] &gt;&gt; nexts[tmp]; &#125; while (first != -1) &#123; list[sum++] = first; first = nexts[first]; &#125; for (int i = 0; i &lt; sum; i++) res[i] = list[i]; for (int i = 0; i &lt; (sum - sum % k); i++) res[i] = list[i / k * k + k - 1 - i % k]; for (int i = 0; i &lt; sum - 1; i++) printf(&quot;%05d %d %05d &quot;, res[i], datas[res[i]], res[i + 1]); printf(&quot;%05d %d -1&quot;, res[sum - 1], datas[res[sum - 1]]); return 0;&#125; 1075 PAT Judge12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int userId = 99999, totle, s[6] = &#123;-1, -1, -1, -1, -1, -1&#125;, perfect; bool isShow;&#125; nums[10001];bool cmp(node &amp;a, node &amp;b) &#123; if (a.totle != b.totle) return a.totle &gt; b.totle; else if (a.perfect != b.perfect) return a.perfect &gt; b.perfect; return a.userId &lt; b.userId;&#125;int w[6];int main() &#123; int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; w[i]; &#125; int userId, problemId, score; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; userId &gt;&gt; problemId &gt;&gt; score; nums[userId].userId = userId; if (score &lt; 1) nums[userId].s[problemId] = max(0, nums[userId].s[problemId]); if (score &gt;= 0) nums[userId].isShow = true; if (score &gt; nums[userId].s[problemId]) &#123; if (score == w[problemId]) nums[userId].perfect++; nums[userId].totle += score - max(0, nums[userId].s[problemId]); nums[userId].s[problemId] = score; &#125; &#125; sort(nums, nums + 10001, cmp); int rank = 1; for (int i = 0; i &lt; 10000; i++) &#123; if (!nums[i].isShow) break; if (i != 0 &amp;&amp; nums[i].totle != nums[i - 1].totle) rank = i + 1; printf(&quot;%d %05d %d &quot;, rank, nums[i].userId, nums[i].totle); for (int j = 1; j &lt;= k; j++) &#123; if (nums[i].s[j] &lt; 0) cout &lt;&lt; &quot;-&quot;; else cout &lt;&lt; nums[i].s[j]; if (j &lt; k) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1076 Forwards on Weibo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; g[1001];bool visit[1001];int bfs(int u, int l) &#123; queue&lt;int&gt; q; q.push(u); fill(visit, visit + 1001, false); visit[u] = true; int res = 0, cnt = 0; while (!q.empty()) &#123; if (cnt &gt;= l) break; int len = q.size(); for (int i = 0; i &lt; len; i++) &#123; u = q.front(); q.pop(); for (int j = 0; j &lt; g[u].size(); j++) &#123; if (!visit[g[u][j]]) &#123; visit[g[u][j]] = true; res++; q.push(g[u][j]); &#125; &#125; &#125; cnt++; &#125; return res;&#125;int main() &#123; int n, l, m, x, k, query; cin &gt;&gt; n &gt;&gt; l; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; x; g[x].push_back(i); &#125; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; query; int res = bfs(query, l); cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 1077 Kuchiguse12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string strs[101];int main() &#123; int n, len = 257; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) &#123; getline(cin, strs[i]); len = min((int)strs[i].size(), len); &#125; string res = &quot;&quot;; for (int i = 1; i &lt;= len; i++) &#123; char ch = strs[0][strs[0].size() - i]; for (int j = 0; j &lt; n; j++) &#123; if (strs[j][strs[j].size() - i] != ch) &#123; if (res.empty()) cout &lt;&lt; &quot;nai&quot;; else cout &lt;&lt; res; return 0; &#125; &#125; res = ch + res; &#125; cout &lt;&lt; res; return 0;&#125; 1078 Hashing123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 20001;vector&lt;int&gt; primes;bool st[N];bool res[N];int main() &#123; int m, n, x; cin &gt;&gt; m &gt;&gt; n; for (int i = 2; i &lt; N; i++) &#123; if (!st[i]) &#123; primes.push_back(i); if (i &gt;= m) &#123; m = i; break; &#125; for (int j = i * 2; j &lt; N; j += i) &#123; st[j] = true; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; bool flag = false; for (int j = 0; j &lt; m; j++) &#123; if (!res[(x + j * j) % m]) &#123; cout &lt;&lt; (x + j * j) % m; res[(x + j * j) % m] = true; flag = true; break; &#125; &#125; if (!flag) cout &lt;&lt; &quot;-&quot;; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1079 Total Sales of Supply Chain1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int val; vector&lt;int&gt; child;&#125; trees[100001];double r, res;void dfs(int u, double p) &#123; if (trees[u].child.empty()) &#123; res += trees[u].val * p; return; &#125; for (int i = 0; i &lt;trees[u].child.size(); i++) &#123; dfs(trees[u].child[i], p + p * r); &#125;&#125;int main() &#123; int n, k, x; double p; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; r /= 100; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k; if (k == 0) &#123; cin &gt;&gt; x; trees[i].val = x; &#125; else &#123; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; x; trees[i].child.push_back(x); &#125; &#125; &#125; dfs(0, p); printf(&quot;%.1f&quot;, res); return 0;&#125; 1080 Graduate Admission123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct student &#123; int num, ge, gi, total, apps[6], rank;&#125; students[40001];int limits[101];vector&lt;int&gt; schools[101];bool cmp(student &amp;a, student &amp;b) &#123; if (a.total != b.total) return a.total &gt; b.total; else if (a.ge != b.ge) return a.ge &gt; b.ge; else return a.num &lt; b.num;&#125;int main() &#123; int n, m, k, ge, gi, total, rank = 1; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; limits[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; students[i].ge &gt;&gt; students[i].gi; students[i].total = students[i].ge + students[i].gi; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; students[i].apps[j]; &#125; students[i].num = i; &#125; sort(students, students + n, cmp); for (int i = 0; i &lt; n; i++) &#123; if (i != 0 &amp;&amp; (students[i].total != students[i - 1].total || students[i].ge != students[i - 1].ge)) rank++; students[i].rank = rank; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int t = students[i].apps[j]; if (limits[t]) &#123; schools[t].push_back(students[i].num); limits[t]--; while (limits[t] == 0 &amp;&amp; i &lt; n - 1 &amp;&amp; students[i].rank == students[i + 1].rank) &#123; schools[t].push_back(students[i + 1].num); i++; &#125; break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; sort(schools[i].begin(), schools[i].end()); for (int j = 0; j &lt; schools[i].size(); j++) &#123; cout &lt;&lt; schools[i][j]; if (j &lt; schools[i].size() - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1081 Rational Sum123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b) &#123; if (b == 0) return a; else return gcd(b, a % b);&#125;void convert(LL a, LL b) &#123; if (a * b &lt; 0) &#123; cout &lt;&lt; &quot;-&quot;; a = abs(a); b = abs(b); &#125; LL t = a / b; if (t) cout &lt;&lt; t; a -= b * t; if (a == 0) &#123; if (t == 0) cout &lt;&lt; 0; return; &#125; if (t != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; a &lt;&lt; &quot;/&quot; &lt;&lt; b;&#125;int main() &#123; LL n, numerator, denominator, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b); if (i != 0) &#123; LL c = numerator * b + denominator * a; LL d = denominator * b; LL t = gcd(c, d); numerator = c / t; denominator = d / t; &#125; else numerator = a, denominator = b; &#125; convert(numerator, denominator); return 0;&#125; 1082 Read Number in Chinese大模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main() &#123; string dicts[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; int n; vector&lt;string&gt; res; cin &gt;&gt; n; if (n == 0) &#123; cout &lt;&lt; &quot;ling&quot;; return 0; &#125; if (n &lt; 0) &#123; res.push_back(&quot;Fu&quot;); n = -n; &#125; int raw = n; if (n &gt;= 100000000) &#123; res.push_back(dicts[n / 100000000]); res.push_back(&quot;Yi&quot;); n = n % 100000000; &#125; bool zero = false; if (n &gt;= 10000) &#123; if (n / 10000000) &#123; res.push_back(dicts[n / 10000000]); res.push_back(&quot;Qian&quot;); n %= 10000000; &#125; else if (raw &gt; 10000000)&#123; zero = true; &#125; if (n / 1000000) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 1000000]); res.push_back(&quot;Bai&quot;); n %= 1000000; &#125; else if (raw &gt; 1000000) &#123; zero = true; &#125; if (n / 100000) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 100000]); res.push_back(&quot;Shi&quot;); n %= 100000; &#125; else if (raw &gt; 100000)&#123; zero = true; &#125; if (n / 10000) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 10000]); n %= 10000; &#125; res.push_back(&quot;Wan&quot;); &#125; zero = false; if (n / 1000) &#123; res.push_back(dicts[n / 1000]); res.push_back(&quot;Qian&quot;); n %= 1000; &#125; else if (raw &gt; 1000)&#123; zero = true; &#125; if (n / 100) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 100]); res.push_back(&quot;Bai&quot;); n %= 100; &#125; else if (raw &gt; 100)&#123; zero = true; &#125; if (n / 10) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n / 10]); res.push_back(&quot;Shi&quot;); n %= 10; &#125; else if (raw &gt; 10)&#123; zero = true; &#125; if (n % 10) &#123; if (zero) &#123; res.push_back(&quot;ling&quot;); zero = false; &#125; res.push_back(dicts[n % 10]); &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 优化 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main() &#123; string nums[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; string wei[5] = &#123;&quot;Shi&quot;, &quot;Bai&quot;, &quot;Qian&quot;, &quot;Wan&quot;, &quot;Yi&quot;&#125;; string str; cin &gt;&gt; str; int len = str.length(); int left = 0, right = len - 1; if (str[0] == &#x27;-&#x27;) &#123; cout &lt;&lt; &quot;Fu&quot;; left++; &#125; while (left + 4 &lt;= right) right -= 4; while (left &lt; len) &#123; bool flag = false, isPrint = false; while (left &lt;= right) &#123; if (left &gt; 0 &amp;&amp; str[left] == &#x27;0&#x27;) flag = true; else &#123; if (flag == true) &#123; cout &lt;&lt; &quot; ling&quot;; flag = false; &#125; if (left &gt; 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; nums[str[left] - &#x27;0&#x27;]; isPrint = true; if (left != right) cout &lt;&lt; &quot; &quot; &lt;&lt; wei[right - left - 1]; &#125; left++; &#125; if (isPrint == true &amp;&amp; right != len - 1) cout &lt;&lt; &quot; &quot; &lt;&lt; wei[(len - 1 - right) / 4 + 2]; right += 4; &#125; return 0;&#125; 1083 List Grades1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; string name, num; int grade;&#125; nums[100001];bool cmp(node a, node b) &#123; return a.grade &gt; b.grade;&#125;int main() &#123; int n, left, right; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i].name &gt;&gt; nums[i].num &gt;&gt; nums[i].grade; &#125; cin &gt;&gt; left &gt;&gt; right; sort(nums, nums + n, cmp); bool flag = true; for (int i = 0; i &lt; n; i++) &#123; if (nums[i].grade &gt;= left &amp;&amp; nums[i].grade &lt;= right) &#123; cout &lt;&lt; nums[i].name &lt;&lt; &quot; &quot; &lt;&lt; nums[i].num &lt;&lt; endl; flag = false; &#125; &#125; if (flag) cout &lt;&lt; &quot;NONE&quot;; return 0;&#125; 1084 Broken Keyboard12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool st[256];int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; a.size(); i++) &#123; if (isalpha(a[i])) a[i] = tolower(a[i]); st[a[i]] = true; &#125; for (int i = 0; i &lt; b.size(); i++) &#123; if (isalpha(b[i])) b[i] = tolower(b[i]); st[b[i]] = false; &#125; for (int i = 0; i &lt; a.size(); i++) &#123; if (st[a[i]]) &#123; char t = a[i]; if (isalpha(t)) t = toupper(t); cout &lt;&lt; t; st[a[i]] = false; &#125; &#125; return 0;&#125; 柳婼的 1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string s1, s2, res; cin &gt;&gt; s1 &gt;&gt; s2; for (int i = 0; i &lt; s1.size(); i++) if (s2.find(s1[i]) == string::npos &amp;&amp; res.find(toupper(s1[i])) == string::npos) res += toupper(s1[i]); cout &lt;&lt; res; return 0;&#125; 1085 Perfect Sequence暴力（超时） 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL nums[100001], res = 1, p;void dfs(LL l, LL r) &#123; if (res &gt; r - l + 1) return; if (nums[l] * p &lt; nums[r]) &#123; dfs(l + 1, r); dfs(l, r - 1); &#125; else &#123; res = max(res, r - l + 1); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n &gt;&gt; p; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n); dfs(0, n - 1); cout &lt;&lt; res; return 0;&#125; 柳婼的 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL nums[100001];int main() &#123; int n, p, res = 1; cin &gt;&gt; n &gt;&gt; p; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n); for (int i = 0; i &lt; n; i++) &#123; // res = max((int)(upper_bound(nums, nums + n, nums[i] * p) - (nums + i)), res); for (int j = i + res; j &lt; n; j++) &#123; if (nums[i] * p &gt;= nums[j]) &#123; res = max(res, j - i + 1); &#125; else break; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1086 Tree Traversals Again1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int l, r;&#125; trees[31];stack&lt;int&gt; st;vector&lt;int&gt; in, pre, post;int build(int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR) return -1; int root = in[inL], idx = preL; for (int i = preL; i &lt;= preR; i++) &#123; if (root == pre[i]) &#123; idx = i; break; &#125; &#125; int cntL = idx - preL; trees[root].l = build(preL, preL + cntL - 1, inL + 1, inL + cntL); trees[root].r = build(idx + 1, preR, inL + cntL + 1, inR); return root;&#125;void dfs(int root) &#123; if (root == -1) return; dfs(trees[root].l); dfs(trees[root].r); post.push_back(root);&#125;int main() &#123; int n, x; string ops; cin &gt;&gt; n; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ops; if (ops == &quot;Push&quot;) &#123; cin &gt;&gt; x; st.push(x); in.push_back(x); &#125; else &#123; pre.push_back(st.top()); st.pop(); &#125; &#125; int root = build(0, n - 1, 0, n - 1); dfs(root); for (int i = 0; i &lt; post.size(); i++) &#123; cout &lt;&lt; post[i]; if (i &lt; post.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 柳婼的 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;stack&lt;int&gt; st;vector&lt;int&gt; pre, in, post, value;void postorder(int root, int start, int end) &#123; if (start &gt; end) return; int i = start; while (i &lt; end &amp;&amp; in[i] != pre[root]) i++; postorder(root + 1, start, i - 1); postorder(root + 1 + i - start, i + 1, end); post.push_back(pre[root]);&#125;int main() &#123; int n, x, key = 0; string ops; cin &gt;&gt; n; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ops; if (ops == &quot;Push&quot;) &#123; cin &gt;&gt; x; value.push_back(x); pre.push_back(key); st.push(key++); &#125; else &#123; in.push_back(st.top()); st.pop(); &#125; &#125; postorder(0, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; value[post[i]]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1087 All Roads Lead to Rome123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 201;const int INF = 0x3f3f3f3f;map&lt;string, int&gt; strToInt;string intToStr[N], start;vector&lt;PII&gt; g[N];int d[N], haps[N], pre[N], cnt[N], happys[N], cnt2[N], n;bool visit[N];void dijkstra(int a) &#123; fill(d, d + n, INF); d[a] = 0; cnt2[a] = 1; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; d[j] &lt; mind) &#123; u = j; mind = d[j]; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].first, dis = g[u][j].second; if (!visit[v]) &#123; if (d[v] &gt; d[u] + dis) &#123; d[v] = d[u] + dis; happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; cnt2[v] = cnt2[u]; pre[v] = u; &#125; else if (d[v] == d[u] + dis) &#123; if (happys[v] &lt; happys[u] + haps[v]) &#123; happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; pre[v] = u; &#125; else if (happys[v] == happys[u] + haps[v]) &#123; if (cnt[v] &gt; cnt[u] + 1) &#123; cnt[v] = cnt[u] + 1; pre[v] = u; &#125; &#125; cnt2[v] += cnt2[u]; &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; res;void dfs(int u) &#123; res.push_back(u); if (u == strToInt[start]) &#123; for (int i = res.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; intToStr[res[i]]; if (i &gt; 0) cout &lt;&lt; &quot;-&gt;&quot;; &#125; &#125; else &#123; dfs(pre[u]); &#125;&#125;int main() &#123; string city1, city2; int k, hap, cost; cin &gt;&gt; n &gt;&gt; k &gt;&gt; start; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; city1 &gt;&gt; hap; strToInt[city1] = i; intToStr[i] = city1; haps[i] = hap; &#125; strToInt[start] = n - 1; intToStr[n - 1] = start; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; cost; g[strToInt[city1]].push_back(&#123;strToInt[city2], cost&#125;); g[strToInt[city2]].push_back(&#123;strToInt[city1], cost&#125;); &#125; dijkstra(strToInt[start]); cout &lt;&lt; cnt2[strToInt[&quot;ROM&quot;]] &lt;&lt; &quot; &quot; &lt;&lt; d[strToInt[&quot;ROM&quot;]] &lt;&lt; &quot; &quot; &lt;&lt; happys[strToInt[&quot;ROM&quot;]] &lt;&lt; &quot; &quot; &lt;&lt; happys[strToInt[&quot;ROM&quot;]] / cnt[strToInt[&quot;ROM&quot;]] &lt;&lt; endl; dfs(strToInt[&quot;ROM&quot;]); return 0;&#125; 1088 Rational Arithmetic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b) &#123; if (b == 0) return a; return gcd(b, a % b);&#125;string convert(LL a, LL b) &#123; string res; if (b == 0) return &quot;Inf&quot;; LL tt = a; if (tt &lt; 0) res += &quot;(-&quot;; a = abs(a), b = abs(b); LL d = gcd(a, b); a /= d; b /= d; LL t = a / b; a -= t * b; if (t &amp;&amp; a) res += to_string(t) + &quot; &quot; + to_string(a) + &quot;/&quot; + to_string(b); else if(t &amp;&amp; a == 0) res += to_string(t); else if(t == 0 &amp;&amp; a) res += to_string(a) + &quot;/&quot; + to_string(b); else res += &quot;0&quot;; if (tt &lt; 0) res += &quot;)&quot;; return res;&#125;string add(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * b2 + a2 * b1; b = b1 * b2; return convert(a, b);&#125;string sub(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * b2 - a2 * b1; b = b1 * b2; return convert(a, b);&#125;string mul(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * a2; b = b1 * b2; return convert(a, b);&#125;string div(LL a1, LL b1, LL a2, LL b2) &#123; LL a, b; a = a1 * b2; b = b1 * a2; if (b &lt; 0) a = -a, b = -b; return convert(a, b);&#125;int main() &#123; LL a1, b1, a2, b2; scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;b1, &amp;a2, &amp;b2); cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; + &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; add(a1, b1, a2, b2) &lt;&lt; endl; cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; - &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; sub(a1, b1, a2, b2) &lt;&lt; endl; cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; * &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; mul(a1, b1, a2, b2) &lt;&lt; endl; cout &lt;&lt; convert(a1, b1) &lt;&lt; &quot; / &quot; &lt;&lt; convert(a2, b2) &lt;&lt; &quot; = &quot; &lt;&lt; div(a1, b1, a2, b2) &lt;&lt; endl; return 0;&#125; 1089 Insert or Merge123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 101;int nums[N], now[N], tmp[N], tmp2[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; now[i]; int id = 0; for (int i = 0; i &lt; n - 1; i++) &#123; if (now[i + 1] &lt; now[i]) &#123; id = i; break; &#125; &#125; bool isInsert = true; for (int j = id + 1; j &lt; n; j++) &#123; if (nums[j] != now[j]) &#123; isInsert = false; break; &#125; &#125; if (isInsert) &#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(nums, nums + id + 2); &#125; else &#123; cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl; bool flag = true; int k = 1; while (flag) &#123; flag = false; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] != now[i]) flag = true; &#125; k *= 2; for (int i = 0; i &lt; n / k; i++) sort(nums + i * k, nums + (i + 1) * k); sort(nums + n / k * k, nums + n); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1090 Highest Price in Supply Chain123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; g[100001];int cnt[100001], res = 0;void dfs(int n, int t) &#123; if (res &lt; t) &#123; res = t; cnt[t] = 1; &#125; else cnt[t]++; for (int i = 0; i &lt; g[n].size(); i++) &#123; dfs(g[n][i], t + 1); &#125;&#125;int main() &#123; int n, x; double p, r; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (x == -1) &#123; g[n].push_back(i); &#125; else &#123; g[x].push_back(i); &#125; &#125; dfs(n, 0); for (int i = 0; i &lt; res - 1; i++) &#123; p *= (100 + r) / 100.0; &#125; printf(&quot;%.2f %d&quot;, p, cnt[res]); return 0;&#125; 1091 Acute Stroke123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int g[61][1287][129], m, n, l, t;bool v[61][1287][129];struct node &#123; int i, j, k;&#125;;int x[6] = &#123;1, -1, 0, 0, 0, 0&#125;;int y[8] = &#123;0, 0, 1, -1, 0, 0&#125;;int z[8] = &#123;0, 0, 0, 0, 1, -1&#125;;int bfs(int i, int j, int k) &#123; v[i][j][k] = true; int cnt = 1; queue&lt;node&gt; q; q.push(&#123;i, j, k&#125;); while (!q.empty()) &#123; node u = q.front(); q.pop(); i = u.i, j = u.j, k = u.k; for (int id = 0; id &lt; 6; id++) &#123; int a = i + x[id], b = j + y[id], c = k + z[id]; if (a &gt;= 0 &amp;&amp; a &lt; l &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; n &amp;&amp; !v[a][b][c] &amp;&amp; g[a][b][c] == 1) &#123; cnt++; v[a][b][c] = true; q.push(&#123;a, b, c&#125;); &#125; &#125; &#125; if (cnt &lt; t) return 0; else return cnt;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; t; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; scanf(&quot;%d&quot;, &amp;g[i][j][k]); &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; if (!v[i][j][k] &amp;&amp; g[i][j][k]) &#123; res += bfs(i, j, k); &#125; &#125; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1092 To Buy or Not to Buy1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int nums[256];int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; a.size(); i++) &#123; nums[a[i]]++; &#125; bool flag = true; int cnt = 0; for (int i = 0; i &lt; b.size(); i++) &#123; if (nums[b[i]] &lt;= 0) &#123; flag = false; cnt++; &#125; nums[b[i]]--; &#125; if (flag) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; a.size() - b.size(); else cout &lt;&lt; &quot;No &quot; &lt;&lt; cnt; return 0;&#125; 1093 Count PAT’s1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() &#123; string str; cin &gt;&gt; str; int res = 0; for (int i = 1; i &lt; str.size(); i++) &#123; p[i] = p[i - 1]; if (str[i - 1] == &#x27;P&#x27;) p[i]++; &#125; for (int i = str.size() - 1; i &gt;= 0; i--) &#123; t[i] = t[i + 1]; if (str[i + 1] == &#x27;T&#x27;) t[i]++; &#125; for (int i = 1; i &lt; str.size() - 1; i++) &#123; if (str[i] == &#x27;A&#x27;) &#123; res = (res + p[i] * t[i] % MOD) % MOD; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 柳婼的 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() &#123; string s; cin &gt;&gt; s; int res = 0, len = s.size(), p = 0, t = 0; for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;T&#x27;) t++; &#125; for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;P&#x27;) p++; if (s[i] == &#x27;T&#x27;) t--; if (s[i] == &#x27;A&#x27;) res = (res + p * t % MOD) % MOD; &#125; cout &lt;&lt; res; return 0;&#125; 1094 The Largest Generation1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; trees[101];int res, cntn;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); int depth = 1; while (!q.empty()) &#123; int cnt = q.size(); for (int i = 0; i &lt; cnt; i++) &#123; u = q.front(); q.pop(); for (int j = 0; j &lt; trees[u].size(); j++) &#123; q.push(trees[u][j]); &#125; &#125; if (cntn &lt; cnt) &#123; res = depth; cntn = cnt; &#125; depth++; &#125; return;&#125;int main() &#123; int n, m, id, k, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; x; trees[id].push_back(x); &#125; &#125; bfs(1); cout &lt;&lt; cntn &lt;&lt; &quot; &quot; &lt;&lt; res; return 0;&#125; 1095 Cars on Campus1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int time; string op;&#125;;bool cmp(node a, node b) &#123; return a.time &lt; b.time;&#125;map&lt;string, int&gt; strToInt;map&lt;int, string&gt; intToStr;vector&lt;node&gt; nums[10001], finall;int times[86401];int main() &#123; string a, op; int n, k, h, m, s, id = 1; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; if (!strToInt[a]) &#123; strToInt[a] = id; intToStr[id++] = a; &#125; scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); cin &gt;&gt; op; int time = h * 60 * 60 + m * 60 + s; nums[strToInt[a]].push_back(&#123;time, op&#125;); &#125; int total[id + 1]; for (int i = 1; i &lt; id; i++) &#123; sort(nums[i].begin(), nums[i].end(), cmp); for (int j = 0; j &lt; nums[i].size() - 1; j++) &#123; if (nums[i][j].op == &quot;in&quot; &amp;&amp; nums[i][j + 1].op == &quot;out&quot;) &#123; finall.push_back(nums[i][j]); finall.push_back(nums[i][j + 1]); total[i] += nums[i][j + 1].time - nums[i][j].time; &#125; &#125; &#125; sort(finall.begin(), finall.end(), cmp); int t = 0; for (int i = 0; i &lt;= 86400; i++) &#123; if (i != 0) times[i] = times[i - 1]; while (finall[t].time == i) &#123; if (finall[t].op == &quot;in&quot;) times[i]++; else times[i]--; t++; if (t == finall.size()) break; &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); int time = h * 60 * 60 + m * 60 + s; cout &lt;&lt; times[time] &lt;&lt; endl; &#125; int maxTime = 0; vector&lt;string&gt; res; for (int i = 0; i &lt; id; i++) &#123; if (maxTime &lt; total[i]) &#123; maxTime = total[i]; res.clear(); res.push_back(intToStr[i]); &#125; else if (maxTime == total[i]) &#123; res.push_back(intToStr[i]); &#125; &#125; for (auto it: res) &#123; cout &lt;&lt; it &lt;&lt; &quot; &quot;; &#125; h = maxTime / 3600, m = maxTime % 3600 / 60, s = maxTime % 60; printf(&quot;%02d:%02d:%02d&quot;, h, m, s); return 0;&#125; 1096 Consecutive Factors1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;int main() &#123; LL n, t; cin &gt;&gt; n; int l = 0, j = 0, res = 0; for (int i = 2; i &lt; sqrt(n) + 1; i++) &#123; t = 1; for (j = i; j &lt; sqrt(n) + 1; j++) &#123; t *= j; if (n % t != 0) break; &#125; if (j - i &gt; l) &#123; l = j - i; res = i; &#125; &#125; if (l == 0) cout &lt;&lt; &quot;1 &quot; &lt;&lt; n; else &#123; cout &lt;&lt; l &lt;&lt; endl; for (int k = res; k &lt; l + res; k++) &#123; cout &lt;&lt; k; if (k &lt; l + res - 1) cout &lt;&lt; &quot;*&quot;; &#125; &#125; return 0;&#125; 1097 Deduplication on a Linked List123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 100001;struct node &#123; int add, key, nex;&#125; nums[N];bool st[N];int main() &#123; int start, n, add, key, nex; cin &gt;&gt; start &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; key &gt;&gt; nex; nums[add] = &#123;add, key, nex&#125;; &#125; vector&lt;node&gt; list, red; while (start != -1) &#123; if (!st[abs(nums[start].key)]) &#123; list.push_back(nums[start]); st[abs(nums[start].key)] = true; &#125; else &#123; red.push_back(nums[start]); &#125; start = nums[start].nex; &#125; if (!list.empty()) &#123; for (int i = 0; i &lt; list.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, list[i].add, list[i].key, list[i + 1].add); &#125; printf(&quot;%05d %d -1 &quot;, list[list.size() - 1].add, list[list.size() - 1].key); &#125; if (!red.empty()) &#123; for (int i = 0; i &lt; red.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, red[i].add, red[i].key, red[i + 1].add); &#125; printf(&quot;%05d %d -1 &quot;, red[red.size() - 1].add, red[red.size() - 1].key); &#125; return 0;&#125; 1098 Insertion or Heap Sort错误答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 101;int a[N], b[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; b[i]; &#125; int id = 0; for (int i = 1; i &lt; n; i++) &#123; if (b[i] &gt;= b[i - 1]) id = i; else break; &#125; bool isInsert = true; for (int j = id + 1; j &lt; n; j++) &#123; if (a[j] != b[j]) &#123; isInsert = false; break; &#125; &#125; if (isInsert) &#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(b, b + id + 2); &#125; else &#123; cout &lt;&lt; &quot;Heap Sort&quot; &lt;&lt; endl; int i = 0, t = b[0]; while(2 * i + 1 &lt; n) &#123; if (b[2 * i + 1] &gt; b[2 * i + 2]) swap(b[2 * i + 1], b[2 * i + 2]); if (b[i] &gt; b[2 * i + 2]) &#123; swap(b[i], b[2 * i + 2]); i = 2 * i + 2; &#125; else if (b[i] &gt; b[2 * i + 1]) &#123; swap(b[i], b[2 * i + 1]); i = 2 * i + 1; &#125; else &#123; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; b[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void down(vector&lt;int&gt; &amp;b, int low, int high) &#123; int i = 1, j = i * 2; while (j &lt;= high) &#123; if (j + 1 &lt;= high &amp;&amp; b[j] &lt; b[j + 1]) j = j + 1; if (b[i] &gt;= b[j]) break; swap(b[i], b[j]); i = j; j = i * 2; &#125;&#125;int main() &#123; int n, p = 2; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1), b(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; while (p &lt;= n &amp;&amp; b[p - 1] &lt;= b[p]) p++; int idx = p; while (p &lt;= n &amp;&amp; a[p] == b[p]) p++; if (p == n + 1) &#123; cout &lt;&lt; &quot;Insertion Sort &quot;; sort(b.begin() + 1, b.begin() + idx + 1); &#125; else &#123; cout &lt;&lt; &quot;Heap Sort &quot;; p = n; while(p &gt; 2 &amp;&amp; b[p] &gt;= b[1]) p--; swap(b[1], b[p]); down(b, 1, p - 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; b[i]; if (i &lt; n) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1099 Build A Binary Search Tree123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int N = 101;struct node &#123; int data, l, r;&#125; a[N];int b[N], cnt;vector&lt;int&gt; res;void dfs(int root) &#123; if (root == -1) return; dfs(a[root].l); a[root].data = b[cnt++]; dfs(a[root].r);&#125;void bfs(int root) &#123; queue&lt;int&gt; q; q.push(root); while (!q.empty()) &#123; root = q.front(); q.pop(); res.push_back(a[root].data); if (a[root].l != -1) q.push(a[root].l); if (a[root].r != -1) q.push(a[root].r); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].l &gt;&gt; a[i].r; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; sort(b, b + n); dfs(0); bfs(0); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; res[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1100 Mars Numbers123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n; string x; string shi[12] = &#123;&quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;&#125;; string ge[12] = &#123;&quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;&#125;; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) &#123; getline(cin, x); if (x == &quot;0&quot;) cout &lt;&lt; &quot;tret&quot; &lt;&lt; endl; else if (isdigit(x[0])) &#123; int t = stoi(x); int a = t / 13; int b = t % 13; if (a &amp;&amp; b) cout &lt;&lt; shi[a - 1] &lt;&lt; &quot; &quot; &lt;&lt; ge[b - 1] &lt;&lt; endl; else if (a) cout &lt;&lt; shi[a - 1] &lt;&lt; endl; else if (b) cout &lt;&lt; ge[b - 1] &lt;&lt; endl; &#125; else &#123; if (x == &quot;tret&quot;) cout &lt;&lt; 0 &lt;&lt; endl; else if (x.size() &gt; 3) &#123; int a = 0; for (int i = 0; i &lt; 12; i++) &#123; if (x.substr(0, 3) == shi[i]) a += (i + 1) * 13; if (x.substr(4, 3) == ge[i]) a += i + 1; &#125; cout &lt;&lt; a &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 12; i++) &#123; if (x == shi[i]) cout &lt;&lt; (i + 1) * 13 &lt;&lt; endl; if (x == ge[i]) cout &lt;&lt; i + 1 &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; 1101 Quick Sort12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;const int INF = 0x3f3f3f3f;int nums[N], minr[N], maxl[N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; fill(minr, minr + n, INF); for (int i = 1; i &lt; n; i++) &#123; maxl[i] = max(maxl[i - 1], nums[i - 1]); &#125; for (int i = n - 2; i &gt;= 0; i--) &#123; minr[i] = min(minr[i + 1], nums[i + 1]); &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] &gt;= maxl[i] &amp;&amp; nums[i] &lt;= minr[i]) &#123; res.push_back(nums[i]); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int v[100001];int main() &#123; int n, max = 0, cnt = 0; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(a.begin(), a.end()); for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i] &amp;&amp; b[i] &gt; max) v[cnt++] = b[i]; if (b[i] &gt; max) max = b[i]; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; v[i]; if (i &lt; cnt - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1102 Invert a Binary Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int l, r;&#125; trees[11];bool st[11];vector&lt;int&gt; level, in;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; u = q.front(); level.push_back(u); q.pop(); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); &#125;&#125;void dfs(int u) &#123; if (u == -1) return; dfs(trees[u].l); in.push_back(u); dfs(trees[u].r);&#125;int main() &#123; int n, root; char a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (isdigit(a)) &#123; trees[i].r = a - &#x27;0&#x27;; st[a - &#x27;0&#x27;] = true; &#125; else &#123; trees[i].r = -1; &#125; if (isdigit(b)) &#123; trees[i].l = b - &#x27;0&#x27;; st[b - &#x27;0&#x27;] = true; &#125; else &#123; trees[i].l = -1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) root = i; &#125; bfs(root); dfs(root); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; level[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; in[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1103 Integer Factorizationdfs 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; res, tmp, v;int n, k, p, t, m, sumt, mint = -1;void dfs(int idx, int a) &#123; if (a == k &amp;&amp; t == n) &#123; if (sumt &gt; mint) &#123; mint = sumt; res = tmp; &#125; return; &#125; if (a &gt;= k || t &gt;= n) return; for (int i = idx; i &gt;= 0; i--) &#123; t += v[i]; sumt += i; tmp.push_back(i + 1); dfs(i, a + 1); tmp.pop_back(); sumt -= i; t -= v[i]; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; for (int i = 1; i &lt;= n; i++) &#123; int b = pow(i, p); v.push_back(b); if (b &gt; n) break; &#125; dfs(v.size() - 1, 0); if (mint == -1) cout &lt;&lt; &quot;Impossible&quot;; else &#123; cout &lt;&lt; n &lt;&lt; &quot; = &quot;; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i] &lt;&lt; &quot;^&quot; &lt;&lt; p; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; + &quot;; &#125; &#125; return 0;&#125; 1104 Sum of Number Segments精度问题（坑） 1234567891011121314151617#include &lt;iostream&gt;using namespace std;const int N = 100001;double nums[N];int n;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; long long res = 0; for (int i = 0; i &lt; n; i++) &#123; res += (long long)(nums[i] * 1000) * i * (n - i + 1); &#125; printf(&quot;%.2f&quot;, res / 1000.0); return 0;&#125; 柳婼的 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; double tmp; long long res; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; res += (long long)(tmp * 1000) * i * (n - i + 1); &#125; printf(&quot;%.2f&quot;, res / 1000.0); return 0;&#125; 1105 Spiral Matrix1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int nums[10001], id, res[100][100];int main() &#123; int t, n, m, mi = 10001; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + t, greater&lt;int&gt;()); for (int i = 1; i * i &lt;= t; i++) &#123; if (t % i == 0) n = i; &#125; m = t / n; int l = 0, r = n - 1, u = 0, d = m - 1; while (l &lt;= r &amp;&amp; u &lt;= d) &#123; for (int i = l; i &lt;= r; i++) res[u][i] = nums[id++]; u++; if (u &gt; d) break; for (int i = u; i &lt;= d; i++) res[i][r] = nums[id++]; r--; if (r &lt; l) break; for (int i = r; i &gt;= l; i--) res[d][i] = nums[id++]; d--; if (u &gt; d) break; for (int i = d; i &gt;= u; i--) res[i][l] = nums[id++]; l++; if (l &gt; r) break; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; res[i][j]; if (j &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1106 Lowest Price in Supply Chain123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; trees[100001];int depth = 1, cnt = 0;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); bool flag = false; while (!q.empty()) &#123; int size = q.size(); cnt = 0; for (int i = 0; i &lt; size; i++) &#123; u = q.front(); q.pop(); if (trees[u].empty()) &#123; flag = true; cnt++; &#125; for (int i = 0; i &lt; trees[u].size(); i++) &#123; q.push(trees[u][i]); &#125; &#125; if (flag) return; depth++; &#125;&#125;int main() &#123; int n, k, x; double p, r; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; x; trees[i].push_back(x); &#125; &#125; bfs(0); printf(&quot;%.4f %d&quot;, p * pow(1 + r / 100, depth - 1), cnt); return 0;&#125; 1107 Social Clusters123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n, cnt = 0; string x; double sum, t; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; try &#123; t = stod(x); if (t &gt; 1000 || t &lt; -1000) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; int j = 0; bool flag = true; while (j &lt; x.size() &amp;&amp; x[j] != &#x27;.&#x27;) j++; if (j != x.size() &amp;&amp; j + 3 &lt; x.size()) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; if (flag) &#123; cnt++; sum += t; &#125; &#125; catch(exception) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; &#125; &#125; if (cnt == 0) cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum); else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt); return 0;&#125; 1108 Finding Average1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n, cnt = 0; string x; double sum, t; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; try &#123; t = stod(x); if (t &gt; 1000 || t &lt; -1000) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; int j = 0; bool flag = true; while (j &lt; x.size() &amp;&amp; x[j] != &#x27;.&#x27;) j++; if (j != x.size() &amp;&amp; j + 3 &lt; x.size()) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; if (flag) &#123; cnt++; sum += t; // cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl; &#125; &#125; catch(exception) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; x &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; &#125; &#125; if (cnt == 0) cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum); else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt); return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int n, cnt = 0; char a[50], b[50]; double t, sum; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; sscanf(a, &quot;%lf&quot;, &amp;t); sprintf(b, &quot;%.2f&quot;, t); bool flag = false; for (int j = 0; j &lt; strlen(a); j++) if (a[j] != b[j]) flag = true; if (flag || t &lt; -1000 || t &gt; 1000) &#123; cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; a &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; continue; &#125; else &#123; sum += t; cnt++; &#125; &#125; if (cnt == 0) cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum); else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt); return 0;&#125; 1109 Group Photo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;string, int&gt; PII;PII nums[10001];bool cmp(PII a, PII b) &#123; if (a.second != b.second) return a.second &gt; b.second; return a.first &lt; b.first;&#125;void fun(int start, int n) &#123; if (n % 2 == 0) &#123; for (int i = n - 1; i &gt;= 1; i-=2) &#123; cout &lt;&lt; nums[start + i].first &lt;&lt; &quot; &quot;; &#125; for (int i = 0; i &lt; n; i+=2) &#123; cout &lt;&lt; nums[start + i].first; if (i + 2 == n) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125; else &#123; for (int i = n - 2; i &gt;= 1; i-=2) &#123; cout &lt;&lt; nums[start + i].first &lt;&lt; &quot; &quot;; &#125; for (int i = 0; i &lt; n; i+=2) &#123; cout &lt;&lt; nums[start + i].first; if (i + 1 == n) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;int main() &#123; int n, k, height; string name; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; height; nums[i] = &#123;name, height&#125;; &#125; sort(nums, nums + n, cmp); int num = n / k; int last = n - num * k + num; fun(0, last); for (int j = 1; j &lt; k; j++) &#123; fun(last + (j - 1) * num, num); &#125; return 0;&#125; 1110 Complete Binary Treebfs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int l = -1, r = -1;&#125; nums[100];bool st[100], isCBT = true, flag;int bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); int cnt = 1, a = 0; while(!q.empty()) &#123; u = q.front(); q.pop(); if (nums[u].l != -1) &#123; q.push(nums[u].l); if (flag) isCBT = false; &#125; else flag = true; if (nums[u].r != -1) &#123; q.push(nums[u].r); if (flag) isCBT = false; &#125; else flag = true; &#125; return u;&#125;int main() &#123; int n, root = 0; string l, r; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; l &gt;&gt; r; if (l != &quot;-&quot;) &#123; nums[i].l = stoi(l); st[stoi(l)] = true; &#125; if (r != &quot;-&quot;) &#123; nums[i].r = stoi(r); st[stoi(r)] = true; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) root = i; &#125; int last = bfs(root); if (!isCBT) cout &lt;&lt; &quot;NO &quot; &lt;&lt; root; else cout &lt;&lt; &quot;YES &quot; &lt;&lt; last; return 0;&#125; dfs 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int l = -1, r = -1;&#125; nums[100];bool st[100];int maxn = -1, last;void dfs(int root, int index) &#123; if (maxn &lt; index) &#123; maxn = index; last = root; &#125; if (nums[root].l != -1) dfs(nums[root].l, index * 2); if (nums[root].r != -1) dfs(nums[root].r, index * 2 + 1);&#125;int main() &#123; int n, root = 0; string l, r; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; l &gt;&gt; r; if (l != &quot;-&quot;) &#123; nums[i].l = stoi(l); st[stoi(l)] = true; &#125; if (r != &quot;-&quot;) &#123; nums[i].r = stoi(r); st[stoi(r)] = true; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!st[i]) root = i; &#125; dfs(root, 1); if (maxn != n) cout &lt;&lt; &quot;NO &quot; &lt;&lt; root; else cout &lt;&lt; &quot;YES &quot; &lt;&lt; last; return 0;&#125; 1111 Online Mapdijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node&#123; int v, dist, time;&#125;;vector&lt;node&gt; g[N];int d[N], cost1[N], cost2[N], cnt[N], pre[N], start, dest, n;bool visit[N];void dijkstra1(int a) &#123; fill(d, d + N, INF); d[a] = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; d[j]) &#123; mind = d[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (d[u] + dist &lt; d[v]) &#123; d[v] = d[u] + dist; cost1[v] = cost1[u] + time; pre[v] = u; &#125; else if (d[u] + dist == d[v]) &#123; if (cost1[v] &gt; cost1[u] + time)&#123; pre[v] = u; cost1[v] = cost1[u] + time; &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; res1;void dfs1(int x) &#123; if (x != start) &#123; res1.push_back(x); dfs1(pre[x]); &#125; else res1.push_back(start);&#125;void dijkstra2(int a) &#123; fill(cost2, cost2 + N, INF); fill(visit, visit + N, false); cost2[a] = 0; cnt[a] = 1; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; mind &gt; cost2[j]) &#123; mind = cost2[j]; u = j; &#125; &#125; if (u == -1) return; visit[u] = true; for (int j = 0; j &lt; g[u].size(); j++) &#123; int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (cost2[u] + time &lt; cost2[v]) &#123; cost2[v] = cost2[u] + time; cnt[v] = cnt[u] + 1; pre[v] = u; &#125; else if (cost2[u] + time == cost2[v]) &#123; if (cnt[v] &gt; cnt[u] + 1)&#123; pre[v] = u; cnt[v] = cnt[u] + 1; &#125; &#125; &#125; &#125;&#125;vector&lt;int&gt; res2;void dfs2(int x) &#123; if (x != start) &#123; res2.push_back(x); dfs2(pre[x]); &#125; else res2.push_back(start);&#125;int main() &#123; int m, v1, v2, one, len, time; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; one &gt;&gt; len &gt;&gt; time; g[v1].push_back(&#123;v2, len, time&#125;); if (!one) g[v2].push_back(&#123;v1, len, time&#125;); &#125; cin &gt;&gt; start &gt;&gt; dest; dijkstra1(start); dfs1(dest); dijkstra2(start); dfs2(dest); if (res1 == res2) &#123; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; d[dest] &lt;&lt; &quot;; Time = &quot; &lt;&lt; cost2[dest] &lt;&lt; &quot;: &quot;; for (int i = res1.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res1[i]; if (i &gt; 0) cout &lt;&lt; &quot; -&gt; &quot;; &#125; &#125; else &#123; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; d[dest] &lt;&lt; &quot;: &quot;; for (int i = res1.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res1[i]; if (i &gt; 0) cout &lt;&lt; &quot; -&gt; &quot;; else cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Time = &quot; &lt;&lt; cost2[dest] &lt;&lt; &quot;: &quot;; for (int i = res2.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; res2[i]; if (i &gt; 0) cout &lt;&lt; &quot; -&gt; &quot;; &#125; &#125; return 0;&#125; 1112 Stucked Keyboard123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int st[257];int main() &#123; int k, i = 0; string a; cin &gt;&gt; k &gt;&gt; a; for (; i &lt;= a.size() - k; i++) &#123; char t = a[i]; bool flag = false; for (int j = i + 1; j &lt; i + k; j++) &#123; if (a[j] != t) &#123; flag = true; break; &#125; &#125; if (flag) st[t] = 1; else i += k - 1; &#125; for (; i &lt; a.size(); i++) &#123; st[a[i]] = 1; &#125; for (int i = 0; i &lt; a.size(); i++) &#123; if (!st[a[i]]) &#123; cout &lt;&lt; a[i]; st[a[i]] = 2; &#125; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; a.size(); i++) &#123; if (st[a[i]] == 1) cout &lt;&lt; a[i]; else if (st[a[i]] == 2) &#123; cout &lt;&lt; a[i]; i += k - 1; &#125; &#125; return 0;&#125; 1113 Integer Set Partition1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; sort(nums, nums + n); long long res = 0; for (int i = 0; i &lt; n / 2; i++) &#123; res += nums[n - i - 1] - nums[i]; &#125; if (n % 2 == 0) cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; res; else &#123; res += nums[n / 2]; cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; res; &#125; return 0;&#125; 1114 Family Property1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10001;struct node &#123; int fa, mo, set, area; vector&lt;int&gt; childs;&#125; nums[N];struct family &#123; int id, cnt; double set, area;&#125;;bool cmp(family &amp;a, family &amp;b) &#123; if (a.area != b.area) return a.area &gt; b.area; return a.id &lt; b.id;&#125;bool visit[N];int fa[N], cnt[N];set&lt;int&gt; ids, ids2, resid;int find(int x) &#123; if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];&#125;void union1(int a, int b) &#123; ids.insert(b); int fa1 = find(a); int fb = find(b); if (fa1 != fb) &#123; if (fa1 &lt; fb) fa[fb] = fa1; else fa[fa1] = fb; &#125;&#125;int main() &#123; int n, id, k, child; for (int i = 1; i &lt; N; i++) fa[i] = i; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id; ids.insert(id); ids2.insert(id); cin &gt;&gt; nums[id].fa &gt;&gt; nums[id].mo &gt;&gt; k; if (nums[id].fa != -1) union1(id, nums[id].fa); if (nums[id].mo != -1) union1(id, nums[id].mo); for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; child; nums[id].childs.push_back(child); union1(id, child); &#125; cin &gt;&gt; nums[id].set &gt;&gt; nums[id].area; &#125; for (auto id: ids) &#123; cnt[find(id)]++; resid.insert(find(id)); &#125; family tmp[N]; for (int i = 0; i &lt; N; i++) &#123; if (cnt[i]) tmp[i] = &#123;i, cnt[i], 0, 0&#125;; &#125; for (auto id: ids2) &#123; tmp[find(id)].set += nums[id].set; tmp[find(id)].area += nums[id].area; &#125; vector&lt;family&gt; res; for (auto id: resid) &#123; tmp[id].set /= tmp[id].cnt; tmp[id].area /= tmp[id].cnt; res.push_back(tmp[id]); &#125; sort(res.begin(), res.end(), cmp); cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%04d %d %.3f %.3f &quot;, res[i].id, res[i].cnt, res[i].set, res[i].area); &#125; return 0;&#125; 1115 Counting Nodes in a Binary Search Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int data, l = -1, r = -1;&#125; nums[1001];int idx = 0, last = 0, llast = 0;void insert(int x, int root) &#123; if (x &lt;= nums[root].data) &#123; if (nums[root].l == -1) &#123; nums[root].l = idx; nums[idx++].data = x; &#125; else insert(x, nums[root].l); &#125; else &#123; if (nums[root].r == -1) &#123; nums[root].r = idx; nums[idx++].data = x; &#125; else insert(x, nums[root].r); &#125;&#125;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; int size = q.size(); llast = last; last = size; for (int i = 0; i &lt; size; i++) &#123; u = q.front(); q.pop(); if (nums[u].l != -1) q.push(nums[u].l); if (nums[u].r != -1) q.push(nums[u].r); &#125; &#125;&#125;int main() &#123; int n, root, x; cin &gt;&gt; n &gt;&gt; root; nums[idx++].data = root; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x; insert(x, 0); &#125; bfs(0); cout &lt;&lt; last &lt;&lt; &quot; + &quot; &lt;&lt; llast &lt;&lt; &quot; = &quot; &lt;&lt; last + llast; return 0;&#125; 1116 Come on! Let’s C12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int N = 10001;bool st[N], visit[N];map&lt;int, int&gt; nums;int main() &#123; for (int i = 2; i &lt; N; i++) &#123; if (!st[i]) &#123; for (int j = i * 2; j &lt; N; j += i) st[j] = true; &#125; &#125; int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; nums[x] = i; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (nums[x] == 0) &#123; printf(&quot;%04d: Are you kidding? &quot;, x); &#125; else if (visit[x]) &#123; printf(&quot;%04d: Checked &quot;, x); &#125; else &#123; if (nums[x] == 1) &#123; printf(&quot;%04d: Mystery Award &quot;, x); visit[x] = true; &#125; else if (!st[nums[x]]) &#123; printf(&quot;%04d: Minion &quot;, x); visit[x] = true; &#125; else &#123; printf(&quot;%04d: Chocolate &quot;, x); visit[x] = true; &#125; &#125; &#125; return 0;&#125; 1117 Eddington Number12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[100001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n, greater&lt;int&gt;()); int res = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i &gt;= nums[i - 1]) break; else res = i; &#125; cout &lt;&lt; res; return 0;&#125; 1118 Birds in Forest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 10001;int fa[N], cnt[N], maxb;set&lt;int&gt; birds;int find(int x) &#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;void union1(int a, int b) &#123; int faa = find(a); int fbb = find(b); if (faa != fbb) &#123; fa[fbb] = faa; &#125;&#125;int main() &#123; for (int i = 1; i &lt; N; i++) &#123; fa[i] = i; &#125; int n, k, x, y; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k &gt;&gt; x; maxb = max(maxb, x); for (int j = 1; j &lt; k; j++) &#123; cin &gt;&gt; y; maxb = max(maxb, y); union1(x, y); &#125; &#125; int mtree = 0; for (int i = 1; i &lt;= maxb; i++) &#123; if (find(i) == i) mtree++; &#125; cout &lt;&lt; mtree &lt;&lt; &quot; &quot; &lt;&lt; maxb &lt;&lt; endl; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if (fa[x] != fa[y]) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 1119 Pre- and Post-order Traversals12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 31;int pre[N], post[N];vector&lt;int&gt; in;bool flag = true;void getIn(int preleft, int preright, int postleft, int postright)&#123; if (preleft == preright) &#123; in.push_back(pre[preleft]); return; &#125; if (pre[preleft] == post[postright]) &#123; int i = preleft + 1; while (i &lt;= preright &amp;&amp; pre[i] != post[postright - 1]) i++; if (i - preleft &gt; 1) getIn(preleft + 1, i - 1, postleft, postleft + (i - preleft - 1) - 1); else flag = false; in.push_back(post[postright]); getIn(i, preright, postleft + (i - preleft - 1), postright - 1); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; getIn(0, n - 1, 0, n - 1); if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; for (int i = 0; i &lt; in.size(); i++) &#123; cout &lt;&lt; in[i]; if (i &lt; in.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return 0;&#125; 1120 Friend Numbers123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[40];int main() &#123; int n, x; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; int t = 0; while (x &gt; 0) &#123; t += x % 10; x /= 10; &#125; nums[t]++; &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; 40; i++) &#123; if (nums[i]) res.push_back(i); &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1121 Damn Single12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;int g[N], tmp[N];int main() &#123; fill(g, g + N, -1); fill(tmp, tmp + N, -1); int n, a, b, m, c; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a] = b; g[b] = a; &#125; cin &gt;&gt; m; vector&lt;int&gt; tmp1, res; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; c; if (g[c] == -1) res.push_back(c); else if (tmp[g[c]] == -1) &#123; tmp[g[c]] = 1; tmp1.push_back(c); &#125; &#125; for (auto i: tmp1) &#123; if (tmp[i] == -1) res.push_back(i); &#125; sort(res.begin(), res.end()); cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%05d&quot;, res[i]); if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1122 Hamiltonian Cycle1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, g[201][201];bool visit[201];bool check(int q) &#123; bool flag = true; if (q != n + 1) flag = false; fill(visit, visit + 201, false); int x, last, start; cin &gt;&gt; last; start = last; visit[start] = true; for (int i = 1; i &lt; q; i++) &#123; cin &gt;&gt; x; if (!g[last][x]) flag = false; visit[x] = true; last = x; &#125; if (start != last) flag = false; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) flag = false; &#125; return flag;&#125;int main() &#123; int m, a, b, k, q; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a][b] = 1; g[b][a] = 1; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; q; if (check(q)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n, m, cnt, k, a[201][201] = &#123;0&#125;; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int t1, t2; cin &gt;&gt; t1 &gt;&gt; t2; a[t1][t2] = a[t2][t1] = 1; &#125; cin &gt;&gt; cnt; while (cnt--) &#123; cin &gt;&gt; k; vector&lt;int&gt; v(k); set&lt;int&gt; s; int flag1 = 1, flag2 = 1; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; v[i]; s.insert(v[i]); &#125; if (s.size() != n || k - 1 != n || v[0] != v[k - 1]) flag1 = 0; for (int i = 0; i &lt; k - 1; i++) if (a[v[i]][v[i+1]] == 0) flag2 = 0; printf(&quot;%s&quot;, flag1 &amp;&amp; flag2 ? &quot;YES &quot; : &quot;NO &quot;); &#125; return 0;&#125; 1123 Is It a Complete AVL Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node&#123; int val; node *left, *right;&#125;;node* rotateLeft(node* root) &#123; node *t = root-&gt;right; root-&gt;right = t-&gt;left; t-&gt;left = root; return t;&#125;node* rotateRight(node* root) &#123; node *t = root-&gt;left; root-&gt;left = t-&gt;right; t-&gt;right = root; return t;&#125;node* rotateLeftRight(node* root) &#123; root-&gt;left = rotateLeft(root-&gt;left); return rotateRight(root);&#125;node* rotateRightLeft(node* root) &#123; root-&gt;right = rotateRight(root-&gt;right); return rotateLeft(root);&#125;int getHeight(node* root) &#123; if (root == NULL) return 0; return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;&#125;node* insert(node* root, int val) &#123; if (root == NULL) &#123; root = new node(); root-&gt;val = val; root-&gt;left = NULL; root-&gt;right = NULL; &#125; else if (val &lt; root-&gt;val) &#123; root-&gt;left = insert(root-&gt;left, val); if (getHeight(root-&gt;left) - getHeight(root-&gt;right) == 2) &#123; root = val &lt; root-&gt;left-&gt;val ? rotateRight(root) : rotateLeftRight(root); &#125; &#125; else &#123; root-&gt;right = insert(root-&gt;right, val); if (getHeight(root-&gt;right) - getHeight(root-&gt;left) == 2) &#123; root = val &gt; root-&gt;right-&gt;val ? rotateLeft(root) : rotateRightLeft(root); &#125; &#125; return root;&#125;vector&lt;int&gt; res;bool bfs(node* u) &#123; queue&lt;node*&gt; q; q.push(u); int t = 1; bool flag1 = true, flag2 = true; while (!q.empty()) &#123; u = q.front(); q.pop(); if (u == NULL) flag1 = false; else &#123; if (!flag1) flag2 = false; res.push_back(u-&gt;val); q.push(u-&gt;left); q.push(u-&gt;right); &#125; &#125; return flag2;&#125;int main() &#123; int n, val; cin &gt;&gt; n; node * root = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; val; root = insert(root, val); &#125; int flag = bfs(root); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; if (flag) cout &lt;&lt; &quot;YES&quot;; else cout &lt;&lt; &quot;NO&quot;; return 0;&#125; 1124 Raffle for Weibo Followers12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;string nums[1001];map&lt;string, bool&gt; st;int main() &#123; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; nums[i]; &#125; bool flag = false; for (int i = s; i &lt;= m;) &#123; if (!st[nums[i]]) &#123; flag = true; st[nums[i]] = true; cout &lt;&lt; nums[i] &lt;&lt; endl; i += n; &#125; else i++; &#125; if (!flag) cout &lt;&lt; &quot;Keep going...&quot;; return 0;&#125; 1125 Chain the Ropes123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nums[10001];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + n); double res = nums[0]; for (int i = 1; i &lt; n; i++) &#123; res = (res + nums[i]) / 2; &#125; cout &lt;&lt; (int)res; return 0;&#125; 1126 Eulerian Path12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N = 501;int degree[N], g[N][N], n;bool visit[N];void dfs(int u) &#123; visit[u] = true; for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i] &amp;&amp; g[u][i]) dfs(i); &#125;&#125;int main() &#123; int m, a, b; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; degree[a]++; degree[b]++; g[a][b] = g[b][a] = 1; &#125; int odd = 0; for (int i = 1; i &lt;= n; i++) &#123; if (degree[i] % 2) odd++; cout &lt;&lt; degree[i]; if (i &lt; n) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; dfs(a); for (int i = 1; i &lt;= n; i++) &#123; if (!visit[i]) &#123; cout &lt;&lt; &quot;Non-Eulerian&quot;; return 0; &#125; &#125; if (odd == 0) cout &lt;&lt; &quot;Eulerian&quot;; else if (odd == 2) cout &lt;&lt; &quot;Semi-Eulerian&quot;; else cout &lt;&lt; &quot;Non-Eulerian&quot;; return 0;&#125; 1127 ZigZagging on a Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 31;struct node&#123; int l, r;&#125; trees[N];int in[N], post[N], n;int build(int leftIn, int rightIn, int leftPost, int rightPost) &#123; if (leftIn &gt; rightIn) return -1; int root = post[rightPost], id = leftIn; for (int i = leftIn; i &lt;= rightIn; i++) &#123; if (in[i] == root) id = i; &#125; int leftCnt = id - leftIn; trees[root].l = build(leftIn, id - 1,leftPost, leftPost + leftCnt - 1); trees[root].r = build(id + 1, rightIn, leftPost + leftCnt, rightPost - 1); return root;&#125;vector&lt;int&gt; res;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); int depth = 1; while (!q.empty()) &#123; int size = q.size(); vector&lt;int&gt; tmp; for (int i = 0; i &lt; size; i++) &#123; u = q.front(); q.pop(); tmp.push_back(u); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); &#125; if (depth % 2) for (int i = tmp.size() - 1; i &gt;= 0; i--) res.push_back(tmp[i]); else for (int i = 0; i &lt; tmp.size(); i++) res.push_back(tmp[i]); depth += 1; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1128 N Queens Puzzle1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1001;bool de[2*N], inde[2*N], row[N];int main() &#123; int n, k, x; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; k; bool flag = true; memset(de, false, sizeof(de)); memset(inde, false, sizeof(inde)); memset(row, false, sizeof(row)); for (int j = 1; j &lt;= k; j++) &#123; cin &gt;&gt; x; if (de[x+j] || inde[-x+j+k] || row[x])flag = false; else de[x+j] = inde[-x+j+k] = row[x] = true; &#125; if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125;&#125; 1129 Recommendation System暴力（超时） 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;map&lt;int, int&gt; nums;bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; if (a.second != b.second) return a.second &gt; b.second; return a.first &lt; b.first;&#125;int main() &#123; int n, k, x; cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; nums[x]++; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x; vector&lt;pair&lt;int, int&gt; &gt; t(nums.begin(), nums.end()); sort(t.begin(), t.end(), cmp); cout &lt;&lt; x &lt;&lt; &quot;:&quot;; for (int i = 0; i &lt; min(k, (int)t.size()); i++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; t[i].first; &#125; cout &lt;&lt; endl; nums[x]++; &#125; return 0;&#125; 柳婼的 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int nums[50001];struct node&#123; int num, val; bool operator &lt; (const node &amp;a) const &#123; if (val != a.val) return val &gt; a.val; return num &lt; a.num; &#125;&#125;;int main() &#123; int n, k, x; cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; nums[x]++; set&lt;node&gt; st; st.insert(&#123;x, nums[x]&#125;); for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x; cout &lt;&lt; x &lt;&lt; &quot;:&quot;; int j = 0; for (auto it = st.begin(); j &lt; k &amp;&amp; it != st.end(); it++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;num; j++; &#125; cout &lt;&lt; endl; auto t = st.find(&#123;x, nums[x]&#125;); if (t != st.end()) st.erase(t); nums[x]++; st.insert(&#123;x, nums[x]&#125;); &#125; return 0;&#125; 1130 Infix Expression123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct node &#123; string x; int l, r;&#125; trees[21];bool st[21];string dfs(int u) &#123; if (trees[u].l == -1 &amp;&amp; trees[u].r == -1) return trees[u].x; if (trees[u].l == -1 &amp;&amp; trees[u].r != -1) return &quot;(&quot; + trees[u].x + dfs(trees[u].r) + &quot;)&quot;; if (trees[u].l != -1 &amp;&amp; trees[u].r != -1) return &quot;(&quot; + dfs(trees[u].l) + trees[u].x + dfs(trees[u].r) + &quot;)&quot;;&#125;int main() &#123; int n, l, r, root; string x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; trees[i] = &#123;x, l, r&#125;; st[l] = st[r] = true; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!st[i]) root = i; &#125; string res = dfs(root); if (res[0] == &#x27;(&#x27;) res = res.substr(1, res.size() - 2); cout &lt;&lt; res; return 0;&#125; 1131 Subway Map1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 10001;unordered_map&lt;int, int&gt; line;vector&lt;int&gt; g[N], tmp, res;int dest, mind, mint, pre, pret;bool visit[N];int cnt() &#123; int cnt = -1, pre = 0; for (int i = 1; i &lt; tmp.size(); i++) &#123; if (line[tmp[i - 1] * 10000 + tmp[i]] != pre) cnt++; pre = line[tmp[i - 1] * 10000 + tmp[i]]; &#125; return cnt;&#125;void dfs(int u, int d) &#123; if (u == dest &amp;&amp; (mind &gt; d || mind == d &amp;&amp; mint &gt; cnt())) &#123; mind = d; mint = cnt(); res = tmp; &#125; if (u == dest) return; for (int i = 0; i &lt; g[u].size(); i++) &#123; if (!visit[g[u][i]]) &#123; visit[g[u][i]] = true; tmp.push_back(g[u][i]); dfs(g[u][i], d + 1); tmp.pop_back(); visit[g[u][i]] = false; &#125; &#125;&#125;int main() &#123; int n, k, x, y; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k &gt;&gt; x; for (int j = 1; j &lt; k; j++) &#123; cin &gt;&gt; y; g[x].push_back(y); g[y].push_back(x); line[x * 10000 + y] = line[y * 10000 + x] = i; x = y; &#125; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; dest; mind = 0x3f3f3f3f, mint = 0x3f3f3f3f, pre = 0, pret = x; tmp.clear(); tmp.push_back(x); visit[x] = true; dfs(x, 0); visit[x] = false; cout &lt;&lt; mind &lt;&lt; endl; for (int j = 1; j &lt; res.size(); j++) &#123; if (line[res[j - 1] * 10000 + res[j]] != pre) &#123; if (pre != 0) printf(&quot;Take Line#%d from %04d to %04d. &quot;, pre, pret, res[j - 1]); pre = line[res[j - 1] * 10000 + res[j]]; pret = res[j - 1]; &#125; &#125; printf(&quot;Take Line#%d from %04d to %04d. &quot;, pre, pret, dest); &#125; return 0;&#125; 1132 Cut Integer1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string z; cin &gt;&gt; z; int c = stoi(z); int a = stoi(z.substr(0, z.size() / 2)); int b = stoi(z.substr(z.size() / 2)); if (a * b == 0 || c % (a * b)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 1133 Splitting A Linked List123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int add, val, nex;&#125; nums[100001];vector&lt;int&gt; res1, res2, res3, res;int main() &#123; int start, n, k, add, val, nex; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add &gt;&gt; val &gt;&gt; nex; nums[add] = &#123;add, val, nex&#125;; &#125; int t = start; while (t != -1) &#123; if (nums[t].val &lt; 0) res1.push_back(t); else if (nums[t].val &lt;= k) res2.push_back(t); else res3.push_back(t); t = nums[t].nex; &#125; for (auto it: res1) res.push_back(it); for (auto it: res2) res.push_back(it); for (auto it: res3) res.push_back(it); for (int i = 0; i &lt; res.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); &#125; printf(&quot;%05d %d -1&quot;, nums[res[res.size() - 1]].add, nums[res[res.size() - 1]].val); return 0;&#125; 1134 Vertex Cover12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int N = 10001;vector&lt;int&gt; g[N];set&lt;int&gt; res;int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(b); g[b].push_back(a); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; res.clear(); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a; for (int i = 0; i &lt; g[a].size(); i++) &#123; if (a &lt; g[a][i]) res.insert(a * 10000 + g[a][i]); else res.insert(g[a][i] * 10000 + a); &#125; &#125; if (res.size() == m) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 柳婼的 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 10001;vector&lt;int&gt; g[N];bool st[N];int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(i); g[b].push_back(i); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; fill(st, st + N, false); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a; for (int i = 0; i &lt; g[a].size(); i++) st[g[a][i]] = true; &#125; bool flag = true; for (int j = 0; j &lt; m; j++) &#123; if (!st[j]) &#123; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1135 Is It A Red-Black Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;struct node &#123; int val; node *l, *r;&#125;;node* build(node* root, int val) &#123; if (root == NULL) &#123; root = new node(); root-&gt;val = val; root-&gt;l = root-&gt;r = NULL; &#125; else if (abs(val) &lt;= abs(root-&gt;val)) &#123; root-&gt;l = build(root-&gt;l, val); &#125; else root-&gt;r = build(root-&gt;r, val); return root;&#125;bool judge1(node* root) &#123; if (root == NULL) return true; if (root-&gt;val &lt; 0) &#123; if (root-&gt;l != NULL &amp;&amp; root-&gt;l-&gt;val &lt; 0) return false; if (root-&gt;r != NULL &amp;&amp; root-&gt;r-&gt;val &lt; 0) return false; &#125; return judge1(root-&gt;l) &amp;&amp; judge1(root-&gt;r);&#125;int getnum(node* root) &#123; if (root == NULL) return 0; int l = getnum(root-&gt;l); int r = getnum(root-&gt;r); if (root-&gt;val &gt; 0) return max(l, r) + 1; else return max(l, r);&#125;bool judge2(node* root) &#123; if (root == NULL) return true; int l = getnum(root-&gt;l); int r = getnum(root-&gt;r); if (l != r) return false; return judge2(root-&gt;l) &amp;&amp; judge2(root-&gt;r);&#125;int main() &#123; int k, n, x, start; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; node* root = NULL; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; x; if (j == 0) start = x; root = build(root, x); &#125; if (start &lt; 0 || !judge1(root) || !judge2(root)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; return 0;&#125; 1136 A Delayed Palindrome1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool check(string s) &#123; for (int i = 0; i &lt; s.size() / 2; i++) &#123; if (s[i] != s[s.size() - i - 1]) return false; &#125; return true;&#125;string add(string a, string b) &#123; if (a.size() &lt; b.size()) swap(a, b); string res = &quot;&quot;; int i, t = 0; for (i = 0; i &lt; b.size(); i++) &#123; t = a[a.size() - i - 1] - &#x27;0&#x27; + b[b.size() - i - 1] - &#x27;0&#x27; + t; res += (t % 10) + &#x27;0&#x27;; t /= 10; &#125; for (; i &lt; a.size(); i++) &#123; t = a[a.size() - i - 1] - &#x27;0&#x27; + t; res += (t % 10) + &#x27;0&#x27;; t /= 10; &#125; if (t) res += &#x27;1&#x27;; reverse(res.begin(), res.end()); return res;&#125;int main() &#123; string a; int cnt = 0; cin &gt;&gt; a; while(!check(a) &amp;&amp; cnt &lt; 10) &#123; string b = a; reverse(a.begin(), a.end()); string c = add(a, b); cout &lt;&lt; b &lt;&lt; &quot; + &quot; &lt;&lt; a &lt;&lt; &quot; = &quot; &lt;&lt; c &lt;&lt; endl; a = c; cnt++; &#125; if (check(a)) cout &lt;&lt; a &lt;&lt; &quot; is a palindromic number.&quot;; else cout &lt;&lt; &quot;Not found in 10 iterations.&quot;; return 0;&#125; 1137 Final Grading12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;struct node &#123; string id; int gp, gm, gf, g;&#125;;vector&lt;node&gt; nums;map&lt;string, int&gt; mgp;map&lt;string, int&gt; mgm;map&lt;string, int&gt; mgf;set&lt;string&gt; ids;bool cmp(node &amp;a, node &amp;b) &#123; if (a.g != b.g) return a.g &gt; b.g; else return a.id &lt; b.id;&#125;int main() &#123; int p, m, n, g; string id; cin &gt;&gt; p &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; p; i++) &#123; cin &gt;&gt; id &gt;&gt; g; mgp[id] = g; ids.insert(id); &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; id &gt;&gt; g; mgm[id] = g; ids.insert(id); &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id &gt;&gt; g; mgf[id] = g; ids.insert(id); &#125; for (auto id: ids) &#123; if (mgp[id] &gt;= 200) &#123; if(mgm.find(id) == mgm.end()) mgm[id] = -1; if (mgm[id] &gt; mgf[id]) g = mgm[id] * 0.4 + mgf[id] * 0.6 + 0.5; else g = mgf[id]; if (g &gt;= 60) &#123; nums.push_back(&#123;id, mgp[id], mgm[id], mgf[id], g&#125;); &#125; &#125; &#125; sort(nums.begin(), nums.end(), cmp); for (auto it: nums) &#123; cout &lt;&lt; it.id &lt;&lt; &quot; &quot; &lt;&lt; it.gp &lt;&lt; &quot; &quot; &lt;&lt; it.gm &lt;&lt; &quot; &quot; &lt;&lt; it.gf &lt;&lt; &quot; &quot; &lt;&lt; it.g &lt;&lt; endl; &#125; return 0;&#125; 1138 Postorder Traversal12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 50001;int pre[N], in[N];bool flag;void build(int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR || flag) return; int root = pre[preL], id = inL; for (int i = inL; i &lt;= inR; i++) &#123; if (root == in[i]) &#123; id = i; break; &#125; &#125; int cntL = id - inL; build(preL + 1, preL + cntL, inL, id - 1); build(preL + cntL + 1, preR, id + 1, inR); if (!flag) &#123; cout &lt;&lt; root &lt;&lt; endl; flag = true; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; in[i]; &#125; build(0, n - 1, 0, n - 1); return 0;&#125; 1139 First Contact没考虑-0000 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; g[20001];bool visit[20001];int main() &#123; int n, m, k, a, b; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &lt; 0) a += 20000; if (b &lt; 0) b += 20000; g[a].push_back(b); g[b].push_back(a); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a &gt;&gt; b; fill(visit, visit + 20001, false); if (a &lt; 0) a += 20000; if (b &lt; 0) b += 20000; visit[a] = visit[b] = true; vector&lt;pair&lt;int, int&gt; &gt; res; if (a &lt; 10000 &amp;&amp; b &lt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &lt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &lt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;g[a][j], g[g[a][j]][p]&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; else if (a &gt; 10000 &amp;&amp; b &lt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &gt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &lt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;-g[a][j] + 20000, g[g[a][j]][p]&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; else if (a &lt; 10000 &amp;&amp; b &gt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &lt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &gt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;g[a][j], -g[g[a][j]][p] + 20000&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; else if (a &gt; 10000 &amp;&amp; b &gt; 10000) &#123; for (int j = 0; j &lt; g[a].size(); j++) &#123; if (!visit[g[a][j]] &amp;&amp; g[a][j] &gt; 10000) &#123; visit[g[a][j]] = true; for (int p = 0; p &lt; g[g[a][j]].size(); p++) &#123; if (!visit[g[g[a][j]][p]] &amp;&amp; g[g[a][j]][p] &gt; 10000) &#123; for (int q = 0; q &lt; g[g[g[a][j]][p]].size(); q++) &#123; if (g[g[g[a][j]][p]][q] == b) &#123; res.push_back(&#123;-g[a][j] + 20000, -g[g[a][j]][p] + 20000&#125;); break; &#125; &#125; &#125; &#125; visit[g[a][j]] = false; &#125; &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%04d %04d &quot;, res[i].first, res[i].second); &#125; &#125; return 0;&#125; 柳婼的 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, bool&gt; arr;vector&lt;int&gt; v[10000];int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; if (a.length() == b.length()) &#123; v[abs(stoi(a))].push_back(abs(stoi(b))); v[abs(stoi(b))].push_back(abs(stoi(a))); &#125; arr[abs(stoi(a)) * 10000 + abs(stoi(b))] = arr[abs(stoi(b)) * 10000 + abs(stoi(a))] = true; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; int c, d; cin &gt;&gt; c &gt;&gt; d; vector&lt;pair&lt;int, int&gt; &gt; res; for (int j = 0; j &lt; v[abs(c)].size(); j++) &#123; for (int k = 0; k &lt; v[abs(d)].size(); k++) &#123; if (v[abs(c)][j] == abs(d) || abs(c) == v[abs(d)][k]) continue; if (arr[v[abs(c)][j] * 10000 + v[abs(d)][k]] == true) res.push_back(&#123;v[abs(c)][j], v[abs(d)][k]&#125;); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; printf(&quot;%04d %04d &quot;, res[i].first, res[i].second); &#125; &#125; return 0;&#125; 1140 Look-and-say Sequence1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; string s; int n, j; cin &gt;&gt; s &gt;&gt; n; for (int cnt = 1; cnt &lt; n; cnt++) &#123; string t; for (int i = 0; i &lt; s.length(); i = j) &#123; for (j = i; j &lt; s.length() &amp;&amp; s[j] == s[i]; j++); t += s[i] + to_string(j - i); &#125; s = t; &#125; cout &lt;&lt; s; return 0;&#125; 1141 PAT Ranking of Institutions123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; string name; int tws, ns;&#125;;bool cmp(node &amp;a, node &amp;b) &#123; if (a.tws != b.tws) return a.tws &gt; b.tws; else if(a.ns != b.ns) return a.ns &lt; b.ns; else return a.name &lt; b.name;&#125;unordered_map&lt;string, vector&lt;double&gt; &gt; schools;vector&lt;node&gt; res;int main() &#123; int n; double score; string id, school; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; for (int j = 0; j &lt; school.size(); j++) &#123; school[j] = tolower(school[j]); &#125; if (id[0] == &#x27;B&#x27;) score /= 1.5; else if (id[0] == &#x27;T&#x27;) score *= 1.5; schools[school].push_back(score); &#125; for (auto it: schools) &#123; double s = 0; for (double i: it.second) s += i; res.push_back(&#123;it.first, (int)s, it.second.size()&#125;); &#125; sort(res.begin(), res.end(), cmp); cout &lt;&lt; res.size() &lt;&lt; endl; int rank = 1; for (int i = 0; i &lt; res.size(); i++) &#123; if (i != 0 &amp;&amp; res[i].tws != res[i - 1].tws) rank = i + 1; cout &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; res[i].name &lt;&lt; &quot; &quot; &lt;&lt; res[i].tws &lt;&lt; &quot; &quot; &lt;&lt; res[i].ns &lt;&lt; endl; &#125; return 0;&#125; 1142 Maximal Clique123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;int, bool&gt; mp;int pre[10001];int main() &#123; int m, n, u, v, a; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; mp[pre[i]] = true; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; for (int j = 0; j &lt; n; j++) &#123; a = pre[j]; if (a &gt;= u &amp;&amp; a &lt;= v || a &gt;= v &amp;&amp; a &lt;= u) break; &#125; if (mp[u] == false &amp;&amp; mp[v] == false) printf(&quot;ERROR: %d and %d are not found. &quot;, u, v); else if (mp[u] == false || mp[v] == false) printf(&quot;ERROR: %d is not found. &quot;, mp[u] == false ? u : v); else if (a == u || a == v) printf(&quot;%d is an ancestor of %d. &quot;, a, a == u ? v : u); else printf(&quot;LCA of %d and %d is %d. &quot;, u, v, a); &#125; return 0;&#125; 1143 Lowest Common Ancestor123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;int, bool&gt; mp;int pre[10001];int main() &#123; int m, n, u, v, a; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; pre[i]; mp[pre[i]] = true; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; for (int j = 0; j &lt; n; j++) &#123; a = pre[j]; if (a &gt;= u &amp;&amp; a &lt;= v || a &gt;= v &amp;&amp; a &lt;= u) break; &#125; if (mp[u] == false &amp;&amp; mp[v] == false) printf(&quot;ERROR: %d and %d are not found. &quot;, u, v); else if (mp[u] == false || mp[v] == false) printf(&quot;ERROR: %d is not found. &quot;, mp[u] == false ? u : v); else if (a == u || a == v) printf(&quot;%d is an ancestor of %d. &quot;, a, a == u ? v : u); else printf(&quot;LCA of %d and %d is %d. &quot;, u, v, a); &#125; return 0;&#125; 1144 The Missing Number12345678910111213141516#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, a, num = 1; cin &gt;&gt; n; map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; m[a]++; &#125; while (true) if (m[num++] == 0) break; cout &lt;&lt; num - 1; return 0;&#125; 1145 Hashing - Average Search Time12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int nums[10001];bool isprime(int x) &#123; if (x &lt;= 1) return false; for (int i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;int main() &#123; int ms, n, m, x; cin &gt;&gt; ms &gt;&gt; n &gt;&gt; m; while (!isprime(ms)) ms++; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; bool flag = false; for (int j = 0; j &lt; ms; j++) &#123; if (nums[(x + j * j) % ms] == 0) &#123; nums[(x + j * j) % ms] = x; flag = true; break; &#125; &#125; if (!flag) cout &lt;&lt; x &lt;&lt; &quot; cannot be inserted.&quot; &lt;&lt; endl; &#125; int times = m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x; bool flag = false; for (int j = 0; j &lt; ms; j++) &#123; if (nums[(x + j * j) % ms] == x || nums[(x + j * j) % ms] == 0) &#123; times += j; flag = true; break; &#125; &#125; if (!flag) times += ms; &#125; printf(&quot;%.1f&quot;, (double)times / m); return 0;&#125; 1146 Topological Order1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v[1010], res;int main() &#123; int n, m, a, b, k, in[1010], tin[1010]; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; v[a].push_back(b); in[b]++; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; bool flag = true; for (int i = 1; i &lt;= n; i++) &#123; tin[i] = in[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; if (tin[a] != 0) flag = false; for (int it :v[a]) tin[it]--; &#125; if (flag) continue; res.push_back(i); &#125; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1147 Heaps12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int nums[2001], n;struct node &#123; int val, l, r;&#125;trees[1001];vector&lt;int&gt; res;void post(int root) &#123; if (root &gt;= n) return; post(trees[root].l); post(trees[root].r); res.push_back(trees[root].val);&#125;int main() &#123; int m; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; int flag = 0; fill(nums, nums + 2 * n, -1); for (int j = 0; j &lt; n; j++) cin &gt;&gt; nums[j]; if (nums[0] &gt; nums[1] &amp;&amp; nums[0] &gt; nums[2]) flag = 1; if (nums[0] &lt; nums[1] &amp;&amp; nums[0] &lt; nums[2]) flag = 2; for (int j = 0; j &lt; n; j++) &#123; trees[j].val = nums[j]; if (flag == 1 &amp;&amp; (2*j+1 &lt; n &amp;&amp; nums[j] &lt; nums[2*j+1] || 2*j+2 &lt; n &amp;&amp; nums[j] &lt; nums[2*j+2])) flag = 0; if (flag == 2 &amp;&amp; (2*j+1 &lt; n &amp;&amp; nums[j] &gt; nums[2*j+1] || 2*j+2 &lt; n &amp;&amp; nums[j] &gt; nums[2*j+2])) flag = 0; trees[j].l = 2 * j + 1; trees[j].r = 2 * j + 2; &#125; post(0); if (flag == 0) cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl; else if (flag == 1) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl; else if (flag == 2) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; res.clear(); &#125; return 0;&#125; 柳婼的 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int a[1005], m, n;void post(int root) &#123; if (root &gt; n) return; post(root * 2); post(root * 2 + 1); printf(&quot;%d%s&quot;, a[root], root == 1 ? &quot; &quot; : &quot; &quot;);&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; for (int j = 0; j &lt; m; j++) &#123; int minn = 1, maxn = 1; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 2; i &lt;= n; i++) &#123; if (a[i] &gt; a[i / 2]) maxn = 0; if (a[i] &lt; a[i / 2]) minn = 0; &#125; if (maxn == 1) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl; else if (minn == 1) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl; post(1); &#125; return 0;&#125; 1148 Werewolf - Simple Version123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int nums[101];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 1; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; int t = 0, flag = 0; for (int k = 0; k &lt; n; k++) &#123; if (nums[k] &lt; 0 &amp;&amp; -nums[k] != i &amp;&amp; -nums[k] != j) &#123; t++; if ((k + 1) == i || (k + 1) == j) flag++; &#125; if (nums[k] &gt; 0 &amp;&amp; (nums[k] == i || nums[k] == j)) &#123; t++; if ((k + 1) == i || (k + 1) == j) flag++; &#125; &#125; if (t == 2 &amp;&amp; flag == 1) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; return 0;&#125; 1149 Dangerous Goods Packaging12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 100001;bool st[N];int nums[N];vector&lt;int&gt; g[N];int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(b); g[b].push_back(a); &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; k; bool flag = true; fill(st, st + N, false); for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; nums[j]; st[nums[j]] = true; &#125; for (int j = 0; j &lt; k; j++) &#123; for (int r = 0; r &lt; g[nums[j]].size(); r++) &#123; if (st[g[nums[j]][r]]) &#123; flag = false; break; &#125; &#125; if (!flag) break; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1150 Travelling Salesman Problem123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;bool visit[205];int g[205][205], nums[205];int main() &#123; int n, m, k, t, city1, city2, d, res = 0x3f3f3f3f, id = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; d; g[city1][city2] = g[city2][city1] = d; &#125; cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; t; bool isCycle = true, isSimple = true, isNA = false; int dist = 0; for (int j = 0; j &lt; t; j++) cin &gt;&gt; nums[j]; fill(visit, visit + 205, false); for (int j = 1; j &lt; t; j++) &#123; if (g[nums[j]][nums[j-1]]) &#123; dist += g[nums[j]][nums[j-1]]; if (!visit[nums[j]]) visit[nums[j]] = true; else isSimple = false; &#125; else &#123; isCycle = false; isNA = true; &#125; &#125; for (int i = 1; i &lt;= n; i++) if (!visit[i]) isCycle = false; if (isCycle &amp;&amp; dist &lt; res) &#123; res = dist; id = i; &#125; if (isCycle &amp;&amp; isSimple) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist &lt;&lt; &quot; (TS simple cycle)&quot; &lt;&lt; endl; else if (isCycle &amp;&amp; !isSimple) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist &lt;&lt; &quot; (TS cycle)&quot; &lt;&lt; endl; else if (!isCycle &amp;&amp; isNA) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: NA (Not a TS cycle)&quot; &lt;&lt; endl; else if (!isCycle &amp;&amp; !isNA) cout &lt;&lt; &quot;Path &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist &lt;&lt; &quot; (Not a TS cycle)&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Shortest Dist(&quot; &lt;&lt; id &lt;&lt; &quot;) = &quot; &lt;&lt; res; return 0;&#125; 1151 LCA in a Binary Tree12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; pos;vector&lt;int&gt; in, pre;void lca(int inl, int inr, int preRoot, int a, int b) &#123; if (inl &gt; inr) return; int inRoot = pos[pre[preRoot]], aIn = pos[a], bIn = pos[b]; if (aIn &lt; inRoot &amp;&amp; bIn &lt; inRoot) lca(inl, inRoot - 1, preRoot + 1, a, b); else if ((aIn &lt; inRoot &amp;&amp; bIn &gt; inRoot) || (aIn &gt; inRoot &amp;&amp; bIn &lt; inRoot)) printf(&quot;LCA of %d and %d is %d. &quot;, a, b, in[inRoot]); else if (aIn &gt; inRoot &amp;&amp; bIn &gt; inRoot) lca(inRoot + 1, inr, preRoot + 1 + (inRoot - inl), a, b); else if (aIn == inRoot) printf(&quot;%d is an ancestor of %d. &quot;, a, b); else if (bIn == inRoot) printf(&quot;%d is an ancestor of %d. &quot;, b, a);&#125;int main() &#123; int m, n, a, b; cin &gt;&gt; m &gt;&gt; n; in.resize(n + 1); pre.resize(n + 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; in[i]; pos[in[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; pre[i]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (pos[a] == 0 &amp;&amp; pos[b] == 0) printf(&quot;ERROR: %d and %d are not found. &quot;, a, b); else if (pos[a] == 0 || pos[b] == 0) printf(&quot;ERROR: %d is not found. &quot;, pos[a] == 0 ? a : b); else lca(1, n, 1, a, b); &#125; return 0;&#125; 1152 Google Recruitment12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long LL;bool check(LL n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt; n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int l, k; string str; cin &gt;&gt; l &gt;&gt; k; cin &gt;&gt; str; for (int i = 0; i &lt;= l - k; i++) &#123; if (check(stol(str.substr(i, k)))) &#123; cout &lt;&lt; str.substr(i, k); return 0; &#125; &#125; cout &lt;&lt; 404 &lt;&lt; endl; return 0;&#125; 1153 Decode Registration Card of PAT)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct node&#123; string num; char ch; int site, date, score;&#125;nums[10005];bool cmp1(node &amp;a, node &amp;b) &#123; if (a.score != b.score) return a.score &gt; b.score; return a.num &lt; b.num;&#125;bool cmp2(PII &amp;a, PII &amp;b) &#123; if (a.second != b.second) return a.second &gt; b.second; return a.first &lt; b.first;&#125;int main() &#123; int n, m, flag, site, date, score, x; char ch; string num; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num &gt;&gt; score; nums[i] = &#123;num, num[0], stoi(num.substr(1, 3)), stoi(num.substr(4, 6)), score&#125;; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; flag; if (flag == 1) &#123; vector&lt;node&gt; t; cin &gt;&gt; ch; cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; &quot;: 1 &quot; &lt;&lt; ch &lt;&lt; endl; for (int j = 0; j &lt; n; j++) if (ch == nums[j].ch) t.push_back(nums[j]); sort(t.begin(), t.end(), cmp1); for (auto it: t) cout &lt;&lt; it.num &lt;&lt; &quot; &quot; &lt;&lt; it.score &lt;&lt; endl; if (t.empty()) cout &lt;&lt; &quot;NA&quot; &lt;&lt; endl; &#125; else if (flag == 2) &#123; cin &gt;&gt; site; cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; &quot;: 2 &quot; &lt;&lt; site &lt;&lt; endl; int nt = 0, ns = 0; for (int j = 0; j &lt; n; j++) &#123; if (site == nums[j].site) &#123; nt++; ns += nums[j].score; &#125; &#125; if (nt == 0) cout &lt;&lt; &quot;NA&quot; &lt;&lt; endl; else cout &lt;&lt; nt &lt;&lt; &quot; &quot; &lt;&lt; ns &lt;&lt; endl; &#125; else if (flag == 3) &#123; cin &gt;&gt; date; printf(&quot;Case %d: 3 %06d &quot;, i, date); map&lt;int, int&gt; t; vector&lt;pair&lt;int, int&gt;&gt; t2; for (int j = 0; j &lt; n; j++) &#123; if (date == nums[j].date) &#123; t[nums[j].site] ++; &#125; &#125; for (auto it: t) t2.push_back(&#123;it.first, it.second&#125;); sort(t2.begin(), t2.end(), cmp2); for (auto it: t2) cout &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second &lt;&lt; endl; if (t2.empty()) cout &lt;&lt; &quot;NA&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 1154 Vertex Coloring1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int level[1005];struct node&#123; int val, l, r;&#125; nums[1005];int n;int build(int root) &#123; if (root &gt;= n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;&#125;vector&lt;int&gt; t;void dfs(int root) &#123; if (root == -1) &#123; for (int i = 0; i &lt; t.size(); i++) &#123; cout &lt;&lt; t[i]; if (i &lt; t.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return; &#125; t.push_back(nums[root].val); if (nums[root].l == -1 &amp;&amp; nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) dfs(nums[root].r); else if (nums[root].r == -1) dfs(nums[root].l); else &#123; dfs(nums[root].r); dfs(nums[root].l); &#125; t.pop_back();&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; level[i]; build(0); dfs(0); bool ismin = true, ismax = true; for (int i = 2; i &lt;= n; i++) &#123; if (level[i/2-1] &gt; level[i-1]) ismin = false; if (level[i/2-1] &lt; level[i-1]) ismax = false; &#125; if (ismin) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; else printf(&quot;%s&quot;, ismax ? &quot;Max Heap&quot; : &quot;Not Heap&quot;); return 0;&#125; 1155 Heap Paths123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int level[1005];struct node&#123; int val, l, r;&#125; nums[1005];int n;bool ismax, ismin;int build(int root) &#123; if (root &gt;= n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;&#125;vector&lt;int&gt; t;void dfs(int root) &#123; if (root == -1) &#123; for (int i = 0; i &lt; t.size(); i++) &#123; cout &lt;&lt; t[i]; if (i &lt; t.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return; &#125; t.push_back(nums[root].val); if (nums[root].l == -1 &amp;&amp; nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) &#123; if (nums[root].val &gt; nums[nums[root].r].val) ismax = true; else if (nums[root].val &lt; nums[nums[root].r].val) ismin = true; dfs(nums[root].r); &#125; else if (nums[root].r == -1) &#123; if (nums[root].val &gt; nums[nums[root].l].val) ismax = true; else if (nums[root].val &lt; nums[nums[root].l].val) ismin = true; dfs(nums[root].l); &#125; else &#123; if (nums[root].val &gt; nums[nums[root].r].val &amp;&amp; nums[root].val &gt; nums[nums[root].l].val) ismax = true; else if (nums[root].val &lt; nums[nums[root].r].val &amp;&amp; nums[root].val &lt; nums[nums[root].l].val) ismin = true; dfs(nums[root].r); dfs(nums[root].l); &#125; t.pop_back();&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; level[i]; build(0); dfs(0); if (ismax &amp;&amp; ismin) cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl; else if (ismax) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl; else if (ismin) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl; return 0;&#125; 1156 Sexy Primes123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;bool check(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; if (check(n) &amp;&amp; check(n - 6)) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; n - 6; else if (check(n) &amp;&amp; check(n + 6)) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; n + 6; else &#123; for (int i = n + 1; ; i++) &#123; if (check(i) &amp;&amp; check(i - 6) || check(i) &amp;&amp; check(i + 6)) &#123; cout &lt;&lt; &quot;No &quot; &lt;&lt; i; break; &#125; &#125; &#125; return 0;&#125; 1157 Anniversary123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;map&lt;string, bool&gt; isAlumni;vector&lt;string&gt; alumnu, guest;int main() &#123; int n; string num; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; isAlumni[num] = true; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; if (isAlumni[num]) alumnu.push_back(num); else guest.push_back(num); &#125; cout &lt;&lt; alumnu.size() &lt;&lt; endl; if (!alumnu.empty()) &#123; string mind = alumnu[0].substr(6, 8), res = alumnu[0]; for (int i = 1; i &lt; alumnu.size(); i++) &#123; if (mind &gt; alumnu[i].substr(6, 8)) &#123; mind = alumnu[i].substr(6, 8); res = alumnu[i]; &#125; &#125; cout &lt;&lt; res; &#125; else &#123; string mind = guest[0].substr(6, 8), res = guest[0]; for (int i = 1; i &lt; guest.size(); i++) &#123; if (mind &gt; guest[i].substr(6, 8)) &#123; mind = guest[i].substr(6, 8); res = guest[i]; &#125; &#125; cout &lt;&lt; res; &#125;&#125; 1158 Telefraud Detection1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;int g[1005][1005] , father[1005];vector&lt;int&gt; suspects;int find(int x) &#123; if (father[x] != x) father[x] = find(father[x]); return father[x];&#125;void union1(int a, int b) &#123; int fa = find(a); int fb = find(b); if (fa != fb) &#123; if (fa &lt; fb) father[fb] = fa; else father[fa] = fb; &#125;&#125;int main() &#123; int k, n, m, caller, receiver, duration; cin &gt;&gt; k &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; caller &gt;&gt; receiver &gt;&gt; duration; g[caller][receiver] += duration; &#125; for (int i = 1; i &lt;= n; i++) &#123; int to = 0, back = 0; for (int j = 1; j &lt;= n; j++) &#123; if (g[i][j] &amp;&amp; g[i][j] &lt;= 5) to++; if (g[i][j] &amp;&amp; g[i][j] &lt;= 5 &amp;&amp; g[j][i]) back++; if (to &gt; k &amp;&amp; back &lt;= to * 0.2) &#123; suspects.push_back(i); break; &#125; &#125; &#125; if (suspects.empty()) cout &lt;&lt; &quot;None&quot; &lt;&lt; endl; for (int i = 0; i &lt; suspects.size(); i++) father[suspects[i]] = suspects[i]; for (int i = 0; i &lt; suspects.size(); i++) &#123; for (int j = i + 1; j &lt; suspects.size(); j++) &#123; if (g[suspects[i]][suspects[j]] &amp;&amp; g[suspects[j]][suspects[i]]) &#123; union1(suspects[i], suspects[j]); &#125; &#125; &#125; map&lt;int, vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; suspects.size(); i++) &#123; int t = find(suspects[i]); res[t].push_back(suspects[i]); &#125; for (auto it: res) &#123; sort(it.second.begin(), it.second.end()); for (int i = 0; i &lt; it.second.size(); i++) &#123; cout &lt;&lt; it.second[i]; if (i &lt; it.second.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1159 Structure of a Binary Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;int post[31], in[31];struct node &#123; int l, r, parent, level;&#125; trees[1005];bool isFull = true;int build(int postL, int postR, int inL, int inR, int parent, int level) &#123; if (postL &gt; postR) return -1; int root = post[postR], id = inL; for (int i = inL; i &lt;= inR; i++) &#123; if (root == in[i]) &#123; id = i; break; &#125; &#125; int cntL = id - inL; trees[root].parent = parent; trees[root].level = level; trees[root].l = build(postL, postL + cntL - 1, inL, id - 1, root, level + 1); trees[root].r = build(postL + cntL, postR - 1, id + 1, inR, root, level + 1); if (trees[root].l * trees[root].r &lt; 0) isFull = false; return root;&#125;int main() &#123; int n, m, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; int root = build(0, n - 1, 0, n - 1, -1, 0); cin &gt;&gt; m; string ops; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; ops; if (ops == &quot;It&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; ops &gt;&gt; ops; if (isFull) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; continue; &#125; a = stoi(ops); cin &gt;&gt; ops; if (ops == &quot;is&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops; if (ops == &quot;root&quot;) &#123; if (a == root) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;parent&quot;) &#123; cin &gt;&gt; ops &gt;&gt; b; if (trees[a].l == b || trees[a].r == b) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;left&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; b; if (trees[b].l == a) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;right&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; b; if (trees[b].r == a) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; else if (ops == &quot;and&quot;) &#123; cin &gt;&gt; b &gt;&gt; ops &gt;&gt; ops; if (ops == &quot;siblings&quot;) &#123; if (trees[a].parent == trees[b].parent) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (ops == &quot;on&quot;) &#123; cin &gt;&gt; ops &gt;&gt; ops &gt;&gt; ops; if (trees[a].level == trees[b].level) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 1160 Forever12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;int, LL&gt; PII;int k, m;vector&lt;PII&gt; res;int gcd(int a, int b) &#123; if (b) return gcd(b, a % b); else return a;&#125;bool isprime(int x) &#123; if (x &lt; 2) return false; for (int i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;void dfs(int cnt, int sum, LL x) &#123; if (cnt &gt; k || sum &gt; m || m &gt; sum + 9*(k-cnt)) return; if (cnt == k &amp;&amp; sum == m) &#123; LL y = x + 1; int n = 0; while (y) &#123; n += y % 10; y /= 10; &#125; if (gcd(n, m) &gt; 2 &amp;&amp; isprime(gcd(n, m))) res.push_back(&#123;n, x&#125;); return; &#125; for (int i = 0; i &lt;= 9; i++) &#123; if (sum == 0 &amp;&amp; i == 0) continue; else dfs(cnt + 1, sum + i, x * 10 + i); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; endl; cin &gt;&gt; k &gt;&gt; m; res.clear(); dfs(0, 0, 0); if (res.empty()) cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; else &#123; sort(res.begin(), res.end()); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i].first &lt;&lt; &quot; &quot; &lt;&lt; res[i].second &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 1161 Merging Linked Lists12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int add, val, nxt;&#125; nums[100005];vector&lt;node&gt; l1, l2, res;int main() &#123; int s1, s2, n, id; cin &gt;&gt; s2 &gt;&gt; s1 &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id; cin &gt;&gt; nums[id].val &gt;&gt; nums[id].nxt; nums[id].add = id; &#125; while (s1 != -1) &#123; l1.push_back(nums[s1]); s1 = nums[s1].nxt; &#125; while (s2 != -1) &#123; l2.push_back(nums[s2]); s2 = nums[s2].nxt; &#125; if (l1.size() &lt; l2.size()) swap(l1, l2); id = 0; for (int i = l2.size() - 1; i &gt;= 0; i--) &#123; res.push_back(l1[id++]); res.push_back(l1[id++]); res.push_back(l2[i]); &#125; for (int i = id; i &lt; l1.size(); i++) res.push_back(l1[i]); for (int i = 0; i &lt; res.size() - 1; i++) printf(&quot;%05d %d %05d &quot;, res[i].add, res[i].val, res[i + 1].add); printf(&quot;%05d %d -1&quot;, res.back().add, res.back().val); return 0;&#125; 1162 Postfix Expression123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct node&#123; string ch; int l, r;&#125; trees[21];bool st[21];void postorder(int x) &#123; if (x == -1) return; if (trees[x].l == -1) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; trees[x].ch; postorder(trees[x].r); cout &lt;&lt; &quot;)&quot;; &#125; else &#123; cout &lt;&lt; &quot;(&quot;; postorder(trees[x].l); postorder(trees[x].r); cout &lt;&lt; trees[x].ch &lt;&lt; &quot;)&quot;; &#125;&#125;int main() &#123; int n, root = 1; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; trees[i].ch &gt;&gt; trees[i].l &gt;&gt; trees[i].r; st[trees[i].l] = st[trees[i].r] = true; &#125; for (int i = 1; i &lt;= n; i++) if (!st[i]) root = i; postorder(root); return 0;&#125; 柳婼的 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n, root = 1, lc[31], rc[31], mark[32];string d[32];void deal(int x) &#123; cout &lt;&lt; &quot;(&quot;; if (lc[x] * rc[x] &gt; 1) &#123; deal(lc[x]); deal(rc[x]); &#125; cout &lt;&lt; d[x]; if (lc[x] * rc[x] &lt; 0) deal(rc[x]); cout &lt;&lt; &quot;)&quot;;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i] &gt;&gt; lc[i] &gt;&gt; rc[i]; mark[lc[i]] = mark[rc[i]] = 1; &#125; while (mark[root]) root++; deal(root); return 0;&#125; 1163 Dijkstra Sequence1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, m, g[1005][1005], nums[1005], d[1005];bool visit[1005];bool dijkstra(int x) &#123; fill(visit, visit + 1005, false); fill(d, d + 1005, INF); d[x] = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, mind = INF; for (int j = 1; j &lt;= n; j++) &#123; if (!visit[j]) &#123; if (mind &gt; d[j]) &#123; mind = d[j]; u = j; &#125; else if (mind == d[j]) &#123; if (j == nums[i]) u = j; &#125; &#125; &#125; if (u != nums[i]) return false; visit[u] = true; for (int j = 1; j &lt;= n; j++) &#123; if (g[u][j] &amp;&amp; !visit[j] &amp;&amp; d[u] + g[u][j] &lt; d[j]) &#123; d[j] = d[u] + g[u][j]; &#125; &#125; &#125; return true;&#125;int main() &#123; int a, b, c, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] = g[b][a] = c; &#125; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; if (dijkstra(nums[0])) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 1164 Good in C1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string alp[27][8];int main() &#123; for (int i = 0; i &lt; 26; i++) &#123; for (int j = 0; j &lt; 7; j++) cin &gt;&gt; alp[i][j]; &#125; string strs[1000], t, str; char ch; int id2 = 0; getchar(); getline(cin, t); for (int i = 0; i &lt; t.size(); i++) &#123; ch = t[i]; if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) str.push_back(ch); else if (!str.empty()) &#123; strs[id2++] = str; str.clear(); &#125; &#125; if (!str.empty()) &#123; strs[id2++] = str; str.clear(); &#125; for (int i = 0; i &lt; id2; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; for (int k = 0; k &lt; strs[i].size(); k++) &#123; cout &lt;&lt; alp[strs[i][k] - &#x27;A&#x27;][j]; if (k &lt; strs[i].size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; &#125; if (i &lt; id2 - 1) cout &lt;&lt; endl; &#125; return 0;&#125; 1165 Block Reversing12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int add, val, nxt;&#125; nums[100005];int main() &#123; int start, n, k, add, val, nxt; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; add; nums[add].add = add; cin &gt;&gt; nums[add].val &gt;&gt; nums[add].nxt; &#125; vector&lt;int&gt; tmps, res; while (start != -1) &#123; tmps.push_back(start); start = nums[start].nxt; &#125; int t = tmps.size() / k; for (int i = t * k; i &lt; tmps.size(); i++) &#123; res.push_back(tmps[i]); &#125; for (int i = t * k - k; i &gt;= 0; i -= k) &#123; for (int j = 0; j &lt; k; j++) &#123; res.push_back(tmps[i + j]); &#125; &#125; for (int i = 0; i &lt; res.size() - 1; i++) &#123; printf(&quot;%05d %d %05d &quot;, nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); &#125; printf(&quot;%05d %d -1&quot;, nums[res.back()].add, nums[res.back()].val); return 0;&#125; 1166 Summit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int g[205][205], nums[205];bool st[205];int main() &#123; int n, m, a, b, k; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a][b] = g[b][a] = 1; &#125; cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; &quot;Area &quot; &lt;&lt; i; cin &gt;&gt; m; fill (st, st + 205, false); for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; nums[j]; st[nums[j]] = true; &#125; bool flag1 = false, flag2 = false, flag3 = false; for (int p = 0; p &lt; m; p++) &#123; for (int q = p + 1; q &lt; m; q++) &#123; if (g[nums[p]][nums[q]] == 0) &#123; flag1 = true; break; &#125; &#125; if (flag1) &#123; cout &lt;&lt; &quot; needs help.&quot; &lt;&lt; endl; break; &#125; &#125; if (!flag1) &#123; for (int p = 1; p &lt;= n; p++) &#123; if (!st[p]) &#123; flag2 = false; for (int q = 0; q &lt; m; q++) if (g[p][nums[q]] == 0) flag2 = true; if (!flag2) &#123; cout &lt;&lt; &quot; may invite more people, such as &quot; &lt;&lt; p &lt;&lt; &quot;.&quot; &lt;&lt; endl; flag3 = true; break; &#125; &#125; &#125; if (!flag3) cout &lt;&lt; &quot; is OK.&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 1167 Cartesian Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int val, l, r;&#125; trees[32];int in[32];vector&lt;int&gt; level;int build(int l, int r) &#123; if (l &gt; r) return -1; int mind = 0x3f3f3f3f, root = l; for (int i = l; i &lt;= r; i++) &#123; if (mind &gt; in[i]) &#123; mind = in[i]; root = i; &#125; &#125; trees[root].val = mind; trees[root].l = build(l, root - 1); trees[root].r = build(root + 1, r); return root;&#125;void bfs(int u) &#123; queue&lt;int&gt; q; q.push(u); while (!q.empty()) &#123; u = q.front(); q.pop(); level.push_back(trees[u].val); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; int root = build(0, n - 1); bfs(root); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; level[i]; if (i &lt; n - 1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 1168 Prime Day1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPrime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; string n; cin &gt;&gt; n; bool flag = true; for (int i = 0; i &lt; 8; i++) &#123; if (isPrime(stoi(n))) cout &lt;&lt; n &lt;&lt; &quot; Yes&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; n &lt;&lt; &quot; No&quot; &lt;&lt; endl; flag = false; &#125; n = n.substr(1); &#125; if (flag) cout &lt;&lt; &quot;All Prime!&quot;; return 0;&#125; 1169 The Judger12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool st[100005], out[11];int g[12][1005];vector&lt;int&gt; nums;bool check(int x) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (x == abs(nums[i] - nums[j])) return true; &#125; &#125; return false;&#125;int main() &#123; int a, b, n, m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n &gt;&gt; m; st[a] = st[b] = true; nums.push_back(a); nums.push_back(b); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) cin &gt;&gt; g[i][j]; &#125; for (int i = 0; i &lt; m; i++) &#123; vector&lt;int&gt; tmp; for (int j = 0; j &lt; n; j++) &#123; if (!out[j]) &#123; if (!st[g[j][i]] &amp;&amp; check(g[j][i])) &#123; nums.push_back(g[j][i]); st[g[j][i]] = true; &#125; else &#123; tmp.push_back(j + 1); out[j] = true; &#125; &#125; &#125; if (!tmp.empty()) &#123; for (int j = 0; j &lt; tmp.size(); j++) cout &lt;&lt; &quot;Round #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; tmp[j] &lt;&lt; &quot; is out.&quot; &lt;&lt; endl; &#125; &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; n; i++) if (!out[i]) res.push_back(i + 1); if (!res.empty()) &#123; cout &lt;&lt; &quot;Winner(s):&quot;; for (int i = 0; i &lt; res.size(); i++) cout &lt;&lt; &quot; &quot; &lt;&lt; res[i]; &#125; else cout &lt;&lt; &quot;No winner.&quot;; return 0;&#125; 1170 Safari Park1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int g[505][505];int main() &#123; int n, r, k, a, b; cin &gt;&gt; n &gt;&gt; r &gt;&gt; k; for (int i = 0; i &lt; r; i++) &#123; cin &gt;&gt; a &gt;&gt; b; g[a][b] = g[b][a] = 1; &#125; cin &gt;&gt; r; for (int i = 0; i &lt; r; i++) &#123; map&lt;int, vector&lt;int&gt;&gt; nums; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; a; nums[a].push_back(j); &#125; if (nums.size() == k) &#123; bool flag = true; for (auto it: nums) &#123; for (int p = 0; p &lt; it.second.size(); p++) &#123; for (int q = p + 1; q &lt; it.second.size(); q++) &#123; if (g[it.second[p]][it.second[q]]) flag= false; &#125; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; else if (nums.size() &lt; k) cout &lt;&lt; &quot;Error: Too few species.&quot; &lt;&lt; endl; else if (nums.size() &gt; k) cout &lt;&lt; &quot;Error: Too many species.&quot; &lt;&lt; endl; &#125; return 0;&#125; 1171 Replacement Selection123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int nums[100005];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q1, q2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; if (i &lt; m) q1.push(nums[i]); &#125; int id = m; while (q1.size()) &#123; int now = q1.top(); cout &lt;&lt; now; q1.pop(); if (id &lt; n) &#123; if (nums[id] &lt; now) q2.push(nums[id]); else q1.push(nums[id]); id++; &#125; if (q1.size()) cout &lt;&lt; &quot; &quot;; else &#123; swap(q1, q2); cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1172 Panda and PP Milk1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int nums[10005], tmps[10005];int main() &#123; int n, res = 0; cin &gt;&gt; n; fill(tmps, tmps + n, 200); for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; i++) &#123; int t = nums[i], id = 0; for (int j = i - 1; j &gt;= 0; j--) &#123; if (t &lt; nums[j]) &#123; id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; &#125; else if (t == nums[j]) &#123; tmps[j] = max(tmps[j], 200 + id * 100); &#125; else break; &#125; t = nums[i], id = 0; for (int j = i + 1; j &lt; n; j++) &#123; if (t &lt; nums[j]) &#123; id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; &#125; else if (t == nums[j]) &#123; tmps[j] = max(tmps[j], 200 + id * 100); &#125; else break; &#125; &#125; for (int i = 0; i &lt; n; i++) res += tmps[i]; cout &lt;&lt; res; return 0;&#125; 1173 How Many Ways to Buy a Piece of Land12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int nums[10005];int main() &#123; int n, m, res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; i++) &#123; int t = 0; for (int j = i; j &lt; n; j++) &#123; t += nums[j]; if (t &lt;= m) res++; else break; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1174 Left-View of Binary Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int in[25], pre[25];vector&lt;int&gt; res;struct node &#123; int l, r;&#125; trees[200005];int build(int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR) return -1; int root = pre[preL], id = inL; for (int i = inL; i &lt;= inR; i++) &#123; if (root == in[i]) &#123; id = i; break; &#125; &#125; int cntL = id - inL; trees[root].l = build(preL + 1, preL + cntL, inL, id - 1); trees[root].r = build(preL + cntL + 1, preR, id + 1, inR); return root;&#125;void bfs(int root) &#123; queue&lt;int&gt; q; q.push(root); while (!q.empty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; root = q.front(); q.pop(); if (i == 0) res.push_back(root); if (trees[root].l != -1) q.push(trees[root].l); if (trees[root].r != -1) q.push(trees[root].r); &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i &lt; res.size(); i++) &#123; cout &lt;&lt; res[i]; if (i &lt; res.size() - 1) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; &#125; return 0;&#125; 1175 Professional Ability Test - PAT (Advanced Level) Practice (pintia.cn)柳婼的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int v, score, voucher; bool operator &lt; (const node &amp;x) const &#123; if(score != x.score) return score &gt; x.score; else return voucher &lt; x.voucher; &#125;&#125;;struct bian &#123; int next, S, D;&#125;;vector&lt;bian&gt; E[1005];vector&lt;pair&lt;int,int&gt;&gt; Dis(1005, &#123;2e9, -1&#125;);int N, M, T1, T2, S, D, f, T, in[1005], in2[1005], Last[1005];queue&lt;int&gt; DAG;int huan() &#123; vector&lt;int&gt; S; while(DAG.size()) &#123; int now = DAG.front(); DAG.pop(); S.push_back(now); for(auto it : E[now]) &#123; in2[it.next]--; if(!in2[it.next]) DAG.push(it.next); &#125; &#125; return S.size() == N;&#125;void dijkstra() &#123; vector&lt;int&gt; vis(1005); priority_queue&lt;node&gt; Q; Q.push(&#123;1002, 0, 0&#125;); Dis[1002].first = Dis[1002].second = 0; while(Q.size()) &#123; node now = Q.top(); Q.pop(); if(vis[now.v]) continue; vis[now.v] = 1; Dis[now.v].first = now.score; Dis[now.v].second = now.voucher; for (auto it : E[now.v]) &#123; if(vis[it.next]) continue; if((Dis[it.next].first &gt; Dis[now.v].first + it.S) || ((Dis[it.next].first == Dis[now.v].first + it.S) &amp;&amp; (Dis[it.next].second &lt; Dis[now.v].second + it.D))) &#123; Dis[it.next].first = Dis[now.v].first + it.S; Dis[it.next].second = Dis[now.v].second + it.D; Last[it.next] = now.v; Q.push(&#123;it.next, Dis[it.next].first, Dis[it.next].second&#125;); &#125; &#125; &#125; return;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; T1 &gt;&gt; T2 &gt;&gt; S &gt;&gt; D; E[T1].push_back(&#123;T2, S, D&#125;); in[T2]++, in2[T2]++; &#125; for (int i = 0; i &lt; N; i++) &#123; if (in[i] == 0) &#123; E[1002].push_back(&#123;i, 0, 0&#125;); DAG.push(i); &#125; &#125; f = huan(); dijkstra(); cin &gt;&gt; T; if(f) cout &lt;&lt; &quot;Okay. &quot;; else cout &lt;&lt; &quot;Impossible. &quot;; for (int i = 1, q; i &lt;= T; i++) &#123; cin &gt;&gt; q; if(!in[q]) cout &lt;&lt; &quot;You may take test &quot; &lt;&lt; q &lt;&lt; &quot; directly. &quot;; else if(!f) cout &lt;&lt; &quot;Error. &quot;; else &#123; vector&lt;int&gt; path; int now = q; while(q != 1002) &#123; path.push_back(q); q = Last[q]; &#125; for (int j = path.size() - 1; j &gt;= 0; j--) &#123; cout &lt;&lt; path[j]; if(j) cout &lt;&lt; &quot;-&gt;&quot;; &#125; cout &lt;&lt; &#x27; &#x27;; &#125; &#125; return 0;&#125; 1176 The Closest Fibonacci Number12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[43];int main() &#123; int n, res = 0, m = 0x3f3f3f3f; cin &gt;&gt; n; dp[0] = dp[1] = 1; if (n == 1) &#123; cout &lt;&lt; n; return 0; &#125; for (int i = 2; i &lt; 43; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; if (m &gt; abs(dp[i] - n)) &#123; m = abs(dp[i] - n); res = dp[i]; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 1177 Subsequence in Substring12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; int m = 0x3f3f3f3f, idx, l = 0, r = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == p[0]) &#123; idx = 1; for (int j = i + 1; j &lt; s.size(); j++) &#123; if (j - i &gt;= m) break; if (s[j] == p[idx]) idx++; if (idx == p.size()) &#123; l = i, r = j; m = r - l; &#125; &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; cout &lt;&lt; s[i]; &#125; return 0;&#125; 1178 File Path1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, string&gt; superior;map&lt;int, string&gt; last;int main() &#123; int n, k; string root, str, res; cin &gt;&gt; n &gt;&gt; root; last[1] = root; superior[root] = root; getchar(); for (int i = 1; i &lt; n; i++) &#123; getline(cin, str); int depth = 0; while (str[depth] == &#x27; &#x27;) depth++; superior[str.substr(depth)] = last[depth]; last[depth + 1] = str.substr(depth); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; str; if (!superior.count(str)) cout &lt;&lt; &quot;Error: &quot; &lt;&lt; str &lt;&lt; &quot; is not found.&quot; &lt;&lt; endl; else &#123; res = &quot; &quot;; while (str != root) &#123; res = &quot;-&gt;&quot; + str + res; str = superior[str]; &#125; cout &lt;&lt; root &lt;&lt; res; &#125; &#125; return 0;&#125; 1179 Chemical Equation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, m, k, num, used[101], res[101];string s;vector&lt;int&gt; product, tmp;vector&lt;vector&lt;int&gt; &gt; equa[101];bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123; for (int i = 0; ; i++) if (a[i] != b[i]) return a[i] &lt; b[i];&#125;void dfs(int x) &#123; if (x == m) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; equa[product[i]][res[i]].size(); j++) &#123; if (j != 0) cout &lt;&lt; &quot; + &quot;; printf(&quot;%02d&quot;, equa[product[i]][res[i]][j]); &#125; printf(&quot; -&gt; %02d &quot;, product[i]); &#125; exit(0); &#125; for (int i = 0; i &lt; equa[product[x]].size(); i++) &#123; int flag = 1; vector&lt;int&gt; A = equa[product[x]][i]; for (auto it: A) if (used[it] != 1) &#123; flag = 0; break; &#125; if (flag == 0) continue; for (auto it: A) used[it] = 2; res[x] = i; dfs(x + 1); for (auto it: A) used[it] = 1; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; used[num] = 1; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num; if (used[num] == 1) equa[num].push_back(&#123;num&#125;); product.push_back(num); &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; tmp.clear(); while (cin &gt;&gt; num &gt;&gt; s) &#123; tmp.push_back(num); if (s == &quot;-&gt;&quot;) &#123; cin &gt;&gt; num; equa[num].push_back(tmp); break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) sort(equa[product[i]].begin(), equa[product[i]].end(), cmp); dfs(0); return 0;&#125;","tags":["算法","PAT","C++"],"categories":["算法"]},{"title":"力扣常见题目","path":"/2024/07/29/力扣常见题/","content":"无重复字符的最长子串123456789class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: dic, res, i = &#123;&#125;, 0, -1 for j in range(len(s)): if s[j] in dic: i = max(dic[s[j]], i) dic[s[j]] = j res = max(res, j - i) return res 反转链表递推 12345678910111213class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, pre = head, None while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre 递归 123456789class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: def recur(cur, pre): if not cur: return pre res = recur(cur.next, cur) cur.next = pre return res return recur(head, None) 数组中的第K个最大元素123456789101112131415161718class Solution: def findKthLargest(self, nums: List[int], k:int) -&gt; int: def quick_sort(nums, k): pivot = random.choice(nums) big, small = [], [] for num in nums: if num &gt; pivot: big.append(num) elif num &lt; pivot: small.append(num) if k &lt;= len(big): return quick_select(big, k) if len(nums) - len(small) &lt; k: return quick_select(small, k - len(nums) + len(small)) return pivot return quick_select(nums, k) K 个一组翻转链表1234567891011121314151617181920212223242526class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]: n = 0 cur = head while cur: n += 1 cur = cur.next p0 = dummy = ListNode(next=head) pre = None cur = head while n &gt;= k: n -= k for _ in range(k): nxt = cur.next cur.next = pre pre = cur cur = nxt nxt = p0.next nxt.next = cur p0.next = pre p0 = nxt return dummy.next 三数之和12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: [int]) -&gt; [[int]]: nums.sort() res, k = [], 0 for k in range(len(nums) - 2): if nums[k] &gt; 0: break if k &gt; 0 and nums[k] == nums[k - 1]: continue i, j = k + 1, len(nums) - 1 while i &lt; j: s = nums[k] + nums[i] + nums[j] if s &lt; 0: i += 1 while i &lt; j and nums[i] == nums[i - 1]: i += 1 elif s &gt; 0: j -= 1 while i &lt; j and nums[j] == nums[j + 1]: j -= 1 else: res.append([nums[k], nums[i], nums[j]]) i += 1 j -= 1 while i &lt; j and nums[i] == nums[i - 1]: i += 1 while i &lt; j and nums[j] == nums[j + 1]: j -= 1 return res 最大子数组和12345678910111213class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: size = len(nums) if size == 0: return 0 dp = [0 for _ in range(size)] dp[0] = nums[0] for i in range(1, size): if dp[i - 1] &gt;= 0: dp[i] = dp[i - 1] + nums[i] else: dp[i] = nums[i] return max(dp) 排序数组123456789101112131415161718192021class Solution: def sortArray(self, nums: List[int]) -&gt; List[int]: import random def quicksort(nums, left, right): flag = nums[random.randint(left, right)] i, j = left, right while i &lt;= j: while nums[i] &lt; flag: i += 1 while nums[j] &gt; flag: j -= 1 if i &lt;= j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 if i &lt; right: quicksort(nums, i, right) if j &gt; left: quicksort(nums, left, j) quicksort(nums, 0, len(nums) - 1) return nums","tags":["算法","Python","LeetCode"],"categories":["算法"]},{"title":"算法笔记","path":"/2024/07/29/算法笔记(c++)/","content":"刷题地址：晴问算法 (sunnywhy.com) 入门模拟简单模拟3N+1猜想 123456789101112#include &lt;cstdio&gt;int main() &#123; int n, res = 0; scanf(&quot;%d&quot;, &amp;n); while (n != 1) &#123; if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; res ++; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 判断三角形 1234567891011#include &lt;cstdio&gt;int main() &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) &#123; printf(&quot;YES&quot;); &#125; else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; 单调递增序列 12345678910111213141516171819#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; bool flag = true; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &lt; nums[i - 1]) &#123; flag = false; break; &#125; &#125; printf(flag ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; 数列奇数和 123456789101112#include &lt;cstdio&gt;int main() &#123; int n, x, res = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;x); if (x % 2 == 1) res += x; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 三位数 12345678910#include &lt;cstdio&gt;int main() &#123; int n, bai = 0, shi = 0, ge = 0; scanf(&quot;%d&quot;, &amp;n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; printf(&quot;%d %d %d&quot;, bai, shi, ge); return 0;&#125; 水仙花数 123456789101112131415#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int n, bai, shi, ge; scanf(&quot;%d&quot;, &amp;n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; if (pow(bai, 3) + pow(shi, 3) + pow(ge, 3) == n) &#123; printf(&quot;YES&quot;); &#125; else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; 水仙花数II 123456789101112131415161718192021222324#include &lt;cstdio&gt;bool check(int x) &#123; int a = x / 100; int b = x % 100 / 10; int c = x % 10; return a * a * a + b * b * b + c * c * c == x;&#125;const int MAXN = 100;int nums[MAXN];int main() &#123; int a, b, idx = 0; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); for (int i = a; i &lt;= b; i++) &#123; if (check(i)) &#123; nums[idx++] = i; &#125; &#125; for (int i = 0; i &lt; idx; i++) &#123; printf(&quot;%d&quot;, nums[i]); if (i &lt; idx - 1) printf(&quot; &quot;); &#125; if (idx == 0) printf(&quot;NO&quot;); return 0;&#125; 2的幂 12345678910#include &lt;cstdio&gt;int main() &#123; int n, res = 1; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; res = (res * 2) % 1007; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 查找元素查找元素 1234567891011121314151617181920#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n, x, res = -1; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; scanf(&quot;%d&quot;, &amp;x); for (int i = 0; i &lt; n; i++) &#123; if (x == nums[i]) &#123; res = i + 1; break; &#125; &#125; if (res == -1) printf(&quot;NO&quot;); else printf(&quot;%d&quot;, res); return 0;&#125; 统计元素个数 123456789101112131415161718#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n, x, res = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; scanf(&quot;%d&quot;, &amp;x); for (int i = 0; i &lt; n; i++) &#123; if (x == nums[i]) &#123; res ++; &#125; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 寻找元素对 123456789101112131415161718#include &lt;cstdio&gt;const int MAXN = 1001;int nums[MAXN];int main() &#123; int n, k, res = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; scanf(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[i] + nums[j] == k) res ++; &#125; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 图形输出等腰直角三角形 123456789101112#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; printf(&quot;*&quot;); &#125; printf(&quot; &quot;); &#125; return 0;&#125; 等腰直角三角形II 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; if (j == 0 || j == i || i == n - 1) &#123; printf(&quot;*&quot;); &#125; else &#123; printf(&quot; &quot;); &#125; &#125; printf(&quot; &quot;); &#125; return 0;&#125; 画X 123456789101112131415161718#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j == i || j == n - i - 1) &#123; printf(&quot;*&quot;); &#125; else if (j &gt; i &amp;&amp; j &gt; n - i - 1) &#123; continue; &#125; else &#123; printf(&quot; &quot;); &#125; &#125; printf(&quot; &quot;); &#125; return 0;&#125; 日期处理判断闰年 1234567891011#include &lt;cstdio&gt;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); if (n % 400 == 0 || n % 100 != 0 and n % 4 == 0) &#123; printf(&quot;YES&quot;); &#125; else &#123; printf(&quot;NO&quot;); &#125; return 0;&#125; 日期加法 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int dayOfMonth[2][13] = &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int year) &#123; return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);&#125;void addOneDay(int &amp;year, int &amp;month, int &amp;day) &#123; day++; if (day &gt; dayOfMonth[isLeapYear(year)][month]) &#123; month ++; day = 1; &#125; if (month &gt; 12) &#123; year++; month = 1; &#125;&#125;int main() &#123; int year, month, day, n; scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; addOneDay(year, month, day); &#125; printf(&quot;%04d-%02d-%02d&quot;, year, month, day); return 0;&#125; 日期减法 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int daOfMonth[2][13] = &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int year) &#123; return (year % 400 == 0 || year % 4 == 0 and year % 100 != 0);&#125;void subDay(int &amp;year, int &amp;month, int &amp;day)&#123; day--; if (day == 0) &#123; month--; if (month == 0) &#123; year --; month = 12; &#125; day = daOfMonth[isLeapYear(year)][month]; &#125;&#125;int main() &#123; int year, month, day, n; scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; subDay(year, month, day); &#125; printf(&quot;%04d-%02d-%02d&quot;, year, month,day); return 0;&#125; 一年中的第几天 12345678910111213141516171819#include &lt;cstdio&gt;int dayOfMonth[2][13] = &#123; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;bool isLeapYear(int year) &#123; return (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0);&#125;int main() &#123; int year, month, day; scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); int res = day; for (int i = 1; i &lt; month; i++) &#123; res += dayOfMonth[isLeapYear(year)][i]; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 日期先后 1234567891011121314151617#include &lt;cstdio&gt;bool isBefore(int year1, int month1, int day1, int year2, int month2, int day2) &#123; if (year1 != year2) &#123; return year1 &lt; year2; &#125; if (month1 != month2) &#123; return month1 &lt; month2; &#125; return day1 &lt; day2;&#125;int main() &#123; int year1, year2, month1, month2, day1, day2; scanf(&quot;%d-%d-%d&quot;, &amp;year1, &amp;month1, &amp;day1); scanf(&quot;%d-%d-%d&quot;, &amp;year2, &amp;month2, &amp;day2); printf(isBefore(year1, month1, day1, year2, month2, day2) ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; 进制转换十进制转二进制 123456789101112131415#include &lt;cstdio&gt;const int MAXN = 11;int nums[MAXN];int main() &#123; int n, idx = 0; scanf(&quot;%d&quot;, &amp;n); while (n != 0) &#123; nums[idx++] = n % 2; n /= 2; &#125; for (int i = idx - 1; i &gt;= 0; i--) &#123; printf(&quot;%d&quot;, nums[i]); &#125; return 0;&#125; 二进制转十进制 123456789101112#include &lt;cstdio&gt;int main() &#123; int s, res = 0, p = 1; scanf(&quot;%d&quot;, &amp;s); while (s != 0) &#123; res += p * (s % 10); p *= 2; s /= 10; &#125; printf(&quot;%d&quot;, res); return 0;&#125; 十进制转K进制 1234567891011121314151617181920#include &lt;cstdio&gt;const int MAXN = 101;int nums[MAXN];int main() &#123; int n, k, idx = 0; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); while (n != 0) &#123; nums[idx++] = n % k; n /= k; &#125; for (int i = idx - 1; i &gt;= 0; i--) &#123; if (nums[i] &gt; 9) &#123; printf(&quot;%c&quot;, nums[i] - 10 + &#x27;A&#x27;); &#125; else &#123; printf(&quot;%d&quot;, nums[i]); &#125; &#125; return 0;&#125; K进制转十进制 123456789101112131415#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 10;char nums[MAXN];int main() &#123; int k, res = 0, p = 1; scanf(&quot;%s %d&quot;, nums, &amp;k); for (int i = strlen(nums) - 1; i &gt;= 0 ; i--) &#123; int t = (nums[i] &gt;= &#x27;0&#x27; &amp;&amp; nums[i] &lt;= &#x27;9&#x27;) ? (nums[i] - &#x27;0&#x27;) : (nums[i] - &#x27;A&#x27; + 10); res += p * t; p *= k; &#125; printf(&quot;%d&quot;, res); return 0; &#125; 字符串处理回文字符串 1234567891011121314#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; bool flag = true; int n = str.length(); for (int i = 0; i &lt; n / 2; i++) &#123; if (str[i] != str[str.length() - i - 1]) flag = false; &#125; printf(flag ? &quot;YES&quot; : &quot;NO&quot;); return 0; &#125; 单词倒序 1234567891011121314#include &lt;cstdio&gt;const int MAXN = 500;const int MAXL = 11;char str[MAXN][MAXL], num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; for (int i = num - 1; i &gt;= 0; i--) &#123; printf(&quot;%s&quot;, str[i]); if (i &gt; 0) printf(&quot; &quot;); &#125; return 0;&#125; 单词倒序II 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = strlen(str[i]) - 1; j &gt;= 0; j--) &#123; printf(&quot;%c&quot;, str[i][j]); &#125; if (i &lt; num - 1) printf(&quot; &quot;); &#125; return 0;&#125; 单词数 1234567891011#include &lt;cstdio&gt;const int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; printf(&quot;%d&quot;, num); return 0;&#125; 首字母大写 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM];int num = 0;int main() &#123; while (scanf(&quot;%s&quot;, str[num]) != EOF) &#123; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = 0; j &lt; strlen(str[i]); j++) &#123; if (j == 0) printf(&quot;%c&quot;, str[i][j] - 32); else printf(&quot;%c&quot;, str[i][j]); &#125; if (i &lt; num - 1) printf(&quot; &quot;); &#125; return 0;&#125; 公共前缀 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 20;const int MAXM = 51;char str[MAXN][MAXM];int main() &#123; int n, minl = 51; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, str[i]); minl = min(minl, (int)strlen(str[i])); &#125; for (int j = 0; j &lt; minl; j++) &#123; char a = str[0][j]; bool flag = true; for (int i = 1; i &lt; n; i++) &#123; if (a != str[i][j]) &#123; flag = false; break; &#125; &#125; if (flag) printf(&quot;%c&quot;, a); else break; &#125; return 0;&#125; 连续相同字符统计 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXL = 101;char str[MAXL];int main() &#123; scanf(&quot;%s&quot;, str); int idx = 0, len = strlen(str); while (idx &lt; len) &#123; printf(&quot;%c &quot;, str[idx++]); int cnt = 1; while (idx &lt; len &amp;&amp; str[idx] == str[idx - 1]) &#123; cnt ++; idx ++; &#125; printf(&quot;%d &quot;, cnt); &#125; return 0;&#125; C语言合法变量名 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXL = 21;char str[MAXL];int main() &#123; scanf(&quot;%s&quot;, str); bool result = true; int len = strlen(str); if (!((str[0] &gt;= &#x27;A&#x27; &amp;&amp; str[0] &lt;= &#x27;Z&#x27;) || (str[0] &gt;= &#x27;a&#x27; &amp;&amp; str[0] &lt;= &#x27;z&#x27;) || str[0] == &#x27;_&#x27;)) &#123; result = false; &#125; for (int i = 1; i &lt; len; i++) &#123; if (!((str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;) || (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) || (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) || str[i] == &#x27;_&#x27;)) &#123; result = false; break; &#125; &#125; printf(result ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; 算法初步排序简单选择排序 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;int a[MAXN], n;void selectSort() &#123; for (int i = 0; i &lt; n; i++) &#123; int k = i; for (int j = i; j &lt; n; j++) &#123; if (a[j] &lt; a[k]) &#123; k = j; &#125; &#125; swap(a[i], a[k]); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; selectSort(); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, a[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; 直接插入排序 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 51;int nums[MAXN], n;void insertSort() &#123; for (int i = 1; i &lt; n; i++) &#123; int t = nums[i]; int j = i; while (j - 1 &gt;= 0 &amp;&amp; nums[j - 1] &gt; t) &#123; nums[j] = nums[j - 1]; j --; &#125; nums[j] = t; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; insertSort(); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, nums[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; 整数升序排序 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 50;int a[MAXN], n;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, a[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; 整数降序排序 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;int nums[MAXN], n;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; sort(nums, nums + n, cmp); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d&quot;, nums[i]); printf(i &lt; n - 1 ? &quot; &quot; : &quot; &quot;); &#125; return 0;&#125; 字符串升序排序 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;int n;string str[MAXN];int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125; return 0;&#125; 字符串降序排序 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 51;string str[MAXN];int n;bool cmp(string a, string b) &#123; return a &gt; b;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n, cmp); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125; return 0;&#125; 考生排序 1 散列递归贪心二分双指针其他高效技巧与算法数学问题简单数学最大公约数与最小公倍数分数的四则运算素数质因子分解大整数运算扩展欧几里得算法组合数数据结构I栈队列链表搜索深度优先搜索广度优先搜索数据结构II树与二叉树二叉树的遍历树的遍历二叉查找树BST平衡二叉树AVL并查集堆哈夫曼树图图的定义图的存储图的遍历最短路径最小生成树拓扑排序关键路径动态规划动态规划的递归与递推最大连续子序列和最长不下降子序列LIS最长公共子序列最长回文子串DAG最长路背包问题总结字符串字符串hash进阶KMP算法专题扩展分块思想树状数组BIT","tags":["算法","C++"],"categories":["算法"]},{"title":"蓝桥杯真题","path":"/2024/05/19/蓝桥杯真题/","content":"蓝桥杯真题单词分析123456from collections import Counters = list(input())s.sort()d = Counter(s)print(d.most_common(1)[0][0])print(d.most_common(1)[0][1]) 成绩统计1234567891011n = int(input())nums = [int(input()) for _ in range(n)]a = d = 0for num in nums: if num &gt;= 85: a += 1 d += 1 elif num &gt;= 60: d += 1print(f&#x27;&#123;round(d*100/n)&#125;%&#x27;)print(f&#x27;&#123;round(a*100/n)&#125;%&#x27;) 门牌制作12345n = 2020res = 0for i in range(1, n + 1): res += str(i).count(&#x27;2&#x27;)print(res) 数字三角形1234567891011n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0 for _ in range(n + 2)] for _ in range(n)]dp[0][1] = nums[0][0]for i in range(1, n): for j in range(1, i+2): dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + nums[i][j-1]if n &amp; 1: print(dp[n-1][(n + 1) // 2])else: print(max(dp[n-1][n // 2], dp[n-1][n // 2 + 1])) 卡片12345678from sys import exitnums = [2021] * 10for i in range(1, 10000): for char in str(i): nums[int(char)] -= 1 if nums[int(char)] &lt; 0: print(i-1) exit(0) 跑步锻炼1234567891011from datetime import datetime,timedeltastart = datetime(2000, 1, 1)end = datetime(2020, 10, 1)res = 0while start &lt;= end: if start.day == 1 or start.weekday() == 0: res += 2 else: res += 1 start += timedelta(days=1)print(res) 蛇形填数123456789101112131415161718192021nums = [[0] * 100 for _ in range(100)]nums[0][0] = 1i, j, t = 0, 0, 1for _ in range(30): j += 1 t += 1 nums[i][j] = t for _ in range(j): i += 1 j -= 1 t += 1 nums[i][j] = t i += 1 t += 1 nums[i][j] = t for _ in range(i): i -= 1 j += 1 t += 1 nums[i][j] = tprint(nums[19][19]) 货物摆放123456789101112n = 2021041820210418nums = []for i in range(1, int(n ** 0.5) + 1): if n % i == 0: nums.append(i) nums.append(n/i)res = 0for i in nums: for j in nums: if n % (i*j) == 0: res += 1print(res) # 2430 ！杨辉三角形暴力（40%） 123456789101112n = int(input())nums = []for i in range(1, 1600): nums.append([1] * i + [0]) for j in range(1, i): nums[i-1][j] = nums[i-2][j] + nums[i-2][j-1]for i, num in enumerate(nums): if n in num: d = num.index(n) res = i * (i+1) // 2 + d + 1 print(res) break 组合数+二分 12345678910111213141516171819202122232425import mathdef C(n, m): a, b = 1, 1 for i in range(1, min(m, n-m) + 1): a *= n n -= 1 b *= i return a // b # return math.comb(n, m) # python3.8def search(x): l = x r = max(x, n) while l &lt; r: mid = l + r &gt;&gt; 1 if C(mid, x // 2) &lt; n: l = mid + 1 else: r = mid return ln = int(input())for i in range(34, -1, -2): t = search(i) if C(t, i//2) == n: print(t * (t+1) // 2 + i//2 + 1) break 时间显示1234from datetime import datetime, timedeltastamp = int(input())d = datetime(1970, 1, 1) + timedelta(milliseconds=stamp)print(d.strftime(&#x27;%H:%M:%S&#x27;)) 裁纸刀12n, m = 20, 22print(4 + m - 1 + (n - 1) * m) 路径1234567891011121314import mathdp = [0] * 2022nums = [[float(&#x27;inf&#x27;)] * 2022 for _ in range(2022)]for i in range(1, 2022): for j in range(i+1, min(i+22, 2022)): d = math.gcd(i, j) nums[i][j] = d * i//d * j//ddp[1] = 0for i in range(2, 2022): t = float(&#x27;inf&#x27;) for j in range(min(i, 22)): t = min(t, dp[i-j] + nums[i-j][i]) dp[i] = tprint(dp[2021]) 排列字母123s = list(input())s.sort()print(&#x27;&#x27;.join(s)) 答疑12345678n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key = lambda x:(x[0] + x[1] + x[2], x[0] + x[1]))res = last = 0for num in nums: res += last + num[0] + num[1] last += num[0] + num[1] + num[2]print(res) 直线123456789101112n, m = 20, 21res = set()for x1 in range(n): for y1 in range(m): for x2 in range(n): for y2 in range(m): if x1 == x2: continue k = (y2 - y1) / (x2 - x1) b = (x2 * y1 - x1 * y2) / (x2 - x1) res.add((k, b))print(len(res) + n) 特殊日期1234567891011import datetimestart = datetime.datetime(1900, 1, 1)end = datetime.datetime(9999, 12, 31)res = 0while start &lt; end: t = start.strftime(&#x27;%Y %m %d&#x27;) y, m, d = t.split() if sum(map(int, y)) == sum(map(int, m)) + sum(map(int, d)): res += 1 start += datetime.timedelta(days=1)print(res) 纸张尺寸12345678910a, b = 1189, 841res = [(a, b )]for i in range(9): if a &lt; b: a, b = b, a a //= 2 res.append((b, a))s = int(input()[-1])print(res[s][0])print(res[s][1]) 青蛙过河123456789101112131415161718n, x = map(int, input().split())nums = list(map(int, input().split()))sums = [0] * nfor i in range(n - 1): sums[i + 1] = sums[i] + nums[i]def check(y): for i in range(n - y): if sums[i + y] - sums[i] &lt; 2 * x: return False return Truel, r = 1, nwhile l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) 工作时长12345678910from datetime import datetimetmp = []with open(&#x27;records.txt&#x27;) as f: for line in f: tmp.append(datetime.strptime(line.strip(), &#x27;%Y-%m-%d %H:%M:%S&#x27;))tmp.sort()res = 0for i in range(0, len(tmp), 2): res += (tmp[i + 1] - tmp[i]).total_seconds()print(int(res)) 求和1234res = 0for i in range(1, 20230409): res += iprint(res) 特殊时间12345678910def check(s): return s.count(&#x27;1&#x27;) == 3 or s.count(&#x27;2&#x27;) == 3tmp = [] #0111, 0222, 1011, 1101, 1110, 1112, 1121, 1222, 1211, 1113, 1114, 1115, 1116, 1117, 1118, 1119for i in range(1, 13): for j in range(1, 31): s = f&#x27;&#123;i:02d&#125;&#123;j:02d&#125;&#x27; if check(s): tmp.append(s)res = 4 * (4*9 + 3*3 + 2*4)print(res) 数位排序1234n, m = int(input()), int(input())tmp = list(range(1, n + 1))tmp.sort(key=lambda x:sum([int(i) for i in str(x)]))print(tmp[m - 1]) 括号序列！！！ 天干地支12345tiangan = [&#x27;jia&#x27;, &#x27;yi&#x27;, &#x27;bing&#x27;, &#x27;ding&#x27;, &#x27;wu&#x27;, &#x27;ji&#x27;, &#x27;geng&#x27;, &#x27;xin&#x27;, &#x27;ren&#x27;, &#x27;gui&#x27;]dizhi = [&#x27;zi&#x27;, &#x27;chou&#x27;, &#x27;yin&#x27;, &#x27;mao&#x27;, &#x27;chen&#x27;, &#x27;si&#x27;, &#x27;wu&#x27;, &#x27;wei&#x27;, &#x27;shen&#x27;, &#x27;you&#x27;, &#x27;xu&#x27;, &#x27;hai&#x27;]n = int(input()) + 56a, b = n % 10, n % 12print(f&#x27;&#123;tiangan[a]&#125;&#123;dizhi[b]&#125;&#x27;) 阶乘的和1234567891011121314151617n = int(input())nums = list(map(int, input().split()))nums.sort()res = nums[0]count = 0nex = nums[0] + 1while True: for num in nums: if num == res: count += 1 if count % nex == 0: count /= nex res = nex nex += 1 else: breakprint(res) 分糖果123456789101112n, x = map(int, input().split())s = list(input())s.sort()if s[x - 1] != s[0]: print(s[x - 1])elif s[x] == s[-1]: print(s[x - 1], end = &#x27;&#x27;) for i in range(x, n, x): print(s[i], end = &#x27;&#x27;)else: for i in s[x - 1: ]: print(i, end = &#x27;&#x27;) 平面切分1234567891011121314n = int(input())nums = list(set([tuple(map(int, input().split())) for _ in range(n)]))res = 1 + len(nums)lines = []for k1, b1 in nums: point = set() for k2, b2 in lines: if k1 != k2: x = (b2 - b1) / (k1 - k2) y = (b1 *k2 - b2*k1) / (k2 - k1) point.add((x, y)) res += len(point) lines.append([k1, b1])print(res) 回路计数123456789101112131415161718def gcd(a, b): return a if b == 0 else gcd(b, a % b)n, state = 21, 1 &lt;&lt; 21g = [[0] * (n + 1) for _ in range(n + 1)]dp = [[0] * (n + 1) for _ in range(state)]dp[1][0] = 1for i in range(n + 1): for j in range(n + 1): if gcd(i, j) == 1: g[i][j] = 1for i in range(state): for j in range(n): if i &gt;&gt; j &amp; 1: for k in range(n): if g[j + 1][k + 1] == 1 and i &gt;&gt; k &amp; 1: dp[i][j] += dp[i - (1 &lt;&lt; j)][k]print(sum(dp[-1]))# print(881012367360) 三国游戏123456789101112131415n = int(input())X, Y, Z = list(map(int, input().split())), list(map(int, input().split())), list(map(int, input().split()))A = sorted([X[i] - Y[i] - Z[i] for i in range(n)], reverse=True)B = sorted([Y[i] - X[i] - Z[i] for i in range(n)], reverse=True)C = sorted([Z[i] - X[i] - Y[i] for i in range(n)], reverse=True)a = b = c = res = 0for i in range(n): a += A[i] b += B[i] c += C[i] if a &gt; 0 or b &gt; 0 or c &gt; 0: res += 1 else: breakprint(res if res else -1) 左孩子右兄弟123456789101112131415import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]for i in range(2, n + 1): t = int(input()) g[t].append(i)def dfs(u): if not g[u]: return 0 res = 0 for i in g[u]: res = max(res, dfs(i)) return len(g[u]) + resprint(dfs(1)) 20231234567891011121314151617181920res = 0def check(s): for i in range(8): if s[i] == &#x27;2&#x27; and i &lt; 5: for j in range(i+1, 8): if s[j] == &#x27;0&#x27; and j &lt; 6: for k in range(j+1, 8): if s[k] == &#x27;2&#x27; and k &lt; 7: for t in range(k+1, 8): if s[t] == &#x27;3&#x27; and t &lt; 8: return True return Falsefor s in range(12345678, 98765433): s = str(s) if &#x27;2&#x27; not in s or &#x27;0&#x27; not in s or &#x27;3&#x27; not in s: continue if check(s): res += 1print(98765433 - 12345678 - res)# print(85959030) 翻转12345678910111213141516n = int(input())for _ in range(n): res = 0 t, s = list(input()), list(input()) m = len(s) if s[0] != t[0] or s[-1] != t[-1]: res = -1 else: for i in range(1, m-1): if s[i] != t[i]: if s[i] != s[i-1] and s[i] != s[i+1]: res += 1 else: res = -1 break print(res) 123！！！暴力 12345678910t = int(input())nums = [0]for i in range(1, 3300): for j in range(1, i): nums.append(j)for i in range(1, len(nums)): nums[i] += nums[i - 1]for _ in range(t): a, b = map(int, input().split()) print(nums[b] - nums[a-1]) ！！！二分 123456789101112131415161718maxn = 1414215s, a = [0] * maxn, [0] * maxnfor i in range(1, maxn): a[i] = a[i - 1] + i s[i] = s[i - 1] + a[i]def presum(x): l, r = 0, maxn while l &lt; r: mid = (l + r + 1)&gt;&gt; 1 if a[mid] &gt; x: r = mid - 1 else: l = mid return s[l] + a[x - a[l]]T = int(input())for _ in range(T): l, r = map(int, input().split()) print(presum(r) - presum(l - 1)) 平均1234567891011n = int(input())nums = [[] for _ in range(10)]for _ in range(n): a, b = map(int, input().split()) nums[a].append(b)res = 0n = n // 10for i in range(10): nums[i] = sorted(nums[i]) res += sum(nums[i][:-n])print(res) 填充12345678910s = input()judge = [&#x27;00&#x27;, &#x27;11&#x27;, &#x27;0?&#x27;, &#x27;?0&#x27;, &#x27;1?&#x27;, &#x27;?1&#x27;, &#x27;11&#x27;]i = res = 0while i &lt; len(s) - 1: if s[i: i + 2] in judge: i += 2 res += 1 else: i += 1print(res) 阶乘约数1234567891011121314dicts = &#123;&#125;def divisor(x): for i in range(2, int(x ** 0.5) + 1): while x % i == 0: dicts[i] = dicts.get(i, 0) + 1 x //= i if x &gt; 1: dicts[x] = dicts.get(x, 0) + 1for i in range(1, 101): divisor(i)res = 1for i in dicts.values(): res *= i + 1print(res) 子树的大小12345678910111213T = int(input())for _ in range(T): n, m, k = map(int, input().split()) l = r = k res = tmp = 1 while r * m + 1 &lt; n: tmp *= m l = l * m - m + 2 r = r * m + 1 res += tmp l = l * m - m + 2 res += max(0, n - l + 1) print(res) 硬币兑换123456nums = [i for i in range(2024)] + [0] * 2023for i in range(1, 2024): nums[2 * i] += i // 2 for j in range(i + 1, 2024): nums[i + j] += iprint(max(nums)) 玩具蛇1234567891011121314151617181920dicts = [(1, 0), (-1, 0), (0, 1), (0, -1)]res = 0g = [[False] * 4 for _ in range(4)]def dfs(x, y, c): if c == 16: global res res += 1 return for i, j in dicts: a, b = x + i, y + j if 0 &lt;= a &lt; 4 and 0 &lt;= b &lt; 4 and not g[a][b]: g[a][b] = True dfs(a, b, c + 1) g[a][b] = Falsefor i in range(4): for j in range(4): g[i][j] = True dfs(i, j, 1) g[i][j] = Falseprint(res) 寻找整数123456789# 11 * 17 = 187for i in range(187, 10**12, 187): if i % 49 == 46 and i % 48 == 41 and i % 47 == 5 and i % 46 == 15 and i % 45 == 29: print(i) # 5458460249 12590206409for i in range(5458460249, 10 ** 17, 7131746160): if i % 44 == 33 and i % 43 == 11 and i % 42 == 11 and i % 41 == 1 and i % 40 == 9 \\ and i % 39 == 23 and i % 38 == 37 and i % 37 == 22 and i % 36 == 29 and i % 35 == 4: print(i) 合数个数1234567891011n = 2020state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n + 1, i): state[j] = Falseres = 0for i in range(1, n + 1): if state[i]: res += 1print(n - res) 寻找202012345678910111213141516n = 300g = [input() for _ in range(n)]res = 0for i in range(n): for j in range(n - 3): if g[i][j: j + 4] == &#x27;2020&#x27;: res += 1for i in range(n - 3): for j in range(n): if g[i][j] == &#x27;2&#x27; and g[i + 1][j] == &#x27;0&#x27; and g[i + 2][j] == &#x27;2&#x27; and g[i + 3][j] == &#x27;0&#x27;: res += 1for i in range(n - 3): for j in range(n - 3): if g[i][j] == &#x27;2&#x27; and g[i + 1][j + 1] == &#x27;0&#x27; and g[i + 2][j + 2] == &#x27;2&#x27; and g[i + 3][j + 3] == &#x27;0&#x27;: res += 1print(res) 子矩阵！！暴力（5 123456789101112131415MOD = 998244353n, m, a, b = map(int, input().split())A = [list(map(int, input().split())) for _ in range(n)]def fun(c, d): x, y = float(&#x27;-inf&#x27;), float(&#x27;inf&#x27;) for i in range(a): for j in range(b): x = max(x, A[c + i][d + j]) y = min(y, A[c + i][d + j]) return (x * y) % MODres = 0for i in range(n - a + 1): for j in range(m - b + 1): res = (res + fun(i, j)) % MODprint(res) 管道123456789101112131415161718192021222324252627n, m = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]def check(time): tmp = [] for i in range(n): if time &gt; nums[i][1]: l = max(1, nums[i][0] - time + nums[i][1]) r = min(m, nums[i][0] + time - nums[i][1]) tmp.append((l, r)) tmp.sort() if not tmp or tmp[0][0] &gt; 1: return False a = tmp[0][1] for l, r in tmp[1:]: if a + 1 &lt; l: return False else: a = max(a, r) return a == ml, r = 1, 1000000000while l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) 异或数列1234567891011121314151617181920212223242526272829def init(n): cnt = 1 while n: if n &amp; 1: nums[cnt] += 1 n &gt;&gt;= 1 cnt += 1T = int(input())for _ in range(T): a = list(map(int, input().split())) n = a[0] nums = [0] * 23 s = 0 for i in range(1, n + 1): init(a[i]) s ^= a[i] if not s: print(0) else: for i in range(20, 0, -1): if nums[i] == 1: print(1) break elif nums[i] % 2 == 1: if n % 2 == 1: print(1) else: print(-1) break 纯质数123456789101112131415n = 20210605state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n, i): state[j] = Falseres = 0for i in range(2, n + 1): if state[i]: for char in str(i): if char not in &#x27;2357&#x27;: res -= 1 break res += 1print(res) 互质数的个数123456789101112131415161718192021a, b = map(int, input().split())MOD = 998244353def qpow(a, b): res = 1 while b: if b &amp; 1: res = res * a % MOD b &gt;&gt;= 1 a = a * a % MOD return resdef euler(x): res = x for i in range(2, int(x ** 0.5) + 1): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x &gt; 1: res *= (1 - 1 / x) return int(res)print(qpow(a, b - 1) * euler(a) % MOD) 最长不下降子序列1234567891011121314151617from bisect import bisect_rightn, k = map(int, input().split())nums = list(map(int, input().split()))interval = [0] * nres = []for i in range(n): idx = bisect_right(res, nums[i]) if idx &gt;= len(res): res.append(nums[i]) else: res[idx] = nums[i] interval[i] = 1maxl = tmp = sum(interval[:k])for i in range(1, n - k + 1): tmp = tmp + interval[i + k - 1] - interval[i - 1] maxl = max(tmp, maxl)print(len(res) + maxl) 松散子序列12345678910s = list(map(lambda x: ord(x) - 96, list(input())))n = len(s)if n &lt;= 2: print(max(s))else: dp = [[0] * 2 for _ in range(n)] for i in range( n): dp[i][1] = max(dp[i - 2]) + s[i] dp[i][0] = max(dp[i - 1]) print(max(dp[-1])) 奇怪的数！！暴力（10%） 123456789101112131415def check(num): for i in range(len(num) - 4): if sum(int(s) for s in num[i: i + 5]) &gt; m: return False return Truen, m = map(int, input().split())if n &gt; 10: exit(0)res = 0for i in range(10 ** n): num = str(i).zfill(n) if all(int(s) % 2 == j % 2 for j, s in enumerate(num)): if check(num): res += 1print(res) 公因数匹配！！暴力（33.3%） 12345678910import sysdef gcd(a, b): return gcd(b, a % b) if b else an = int(input())nums = list(map(int, input().split()))for i in range(n): for j in range(i + 1, n): if gcd(nums[i], nums[j]) &gt; 1: print(i + 1, j + 1) sys.exit(0) 求因数+堆 1234567891011121314151617181920import heapqfrom collections import defaultdictn = int(input())nums = list(map(int, input().split()))facts = defaultdict(list)for i, num in enumerate(nums): for j in range(2, int(num ** 0.5) + 1): if num % j == 0: heapq.heappush(facts[j], i + 1) heapq.heappush(facts[num // j], i + 1) heapq.heappush(facts[num], i + 1)l = r = float(&#x27;inf&#x27;)for v in facts.values(): if len(v) &gt; 1: if l &gt; v[0]: l = v[0] r = v[1] elif l == v[0]: r = min(r, v[1])print(l, r) 保险箱123456789101112n = int(input())s = [0] + list(map(int, input()[::-1]))t = [0] + list(map(int, input()[::-1]))dp = [[0] * 3 for _ in range(n + 1)]dp[1][0] = abs(s[1] - t[1])dp[1][1] = -s[1] + 10 + t[1]dp[1][2] = s[1] + 10 - t[1]for i in range(2, n + 1): dp[i][0] = min(dp[i-1][0] + abs(s[i] - t[i]), dp[i-1][1] + abs(s[i] + 1 - t[i]), dp[i-1][2] + abs(s[i] - 1 - t[i])) dp[i][1] = min(dp[i-1][0] + 10 - s[i] + t[i], dp[i-1][1] + 9 - s[i] + t[i], dp[i-1][2] + 11 - s[i] + t[i]) dp[i][2] = min(dp[i-1][0] + 10 + s[i] - t[i], dp[i-1][1] + 11 + s[i] - t[i], dp[i-1][2] + 9 + s[i] - t[i])print(min(dp[n])) 蜂巢12345678910111213141516171819202122232425262728d1, p1, q1, d2, p2, q2 = map(int, input().split())def fun(d, p, q): if d == 0: x = -p + q/2 y = q if d == 1: x = -p/2 + q y = p if d == 2: x = p/2 + q/2 y = p - q if d == 3: x = p - q/2 y = -q if d == 4: x = p/2 - q y = -p if d == 5: x = -p/2 - q/2 y = q - p return x, yx1, y1 = fun(d1, p1, q1)x2, y2 = fun(d2, p2, q2)a, b = abs(x1 - x2), abs(y1 - y2)if a &lt; b / 2: print(int(b))else: print(int(a + b - b // 2)) 异或和1234567891011121314151617181920n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]for _ in range(n - 1): u, v = map(int, input().split()) if u &gt; v: u, v = v, u adj_list[u].append(v)def dfs(u): res = nums[u] for v in adj_list[u]: res ^= dfs(v) return res for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: nums[li[1]] = li[2] elif li[0] == 2: res = dfs(li[1]) print(res) 棋盘！！暴力 123456789n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): g[i][j] = 1 if g[i][j] == 0 else 0for i in range(1, n + 1): print(&#x27;&#x27;.join(map(str, g[i][1:]))) 差分+前缀和 12345678910111213141516171819n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]diff = [[0] * (n + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += 1 diff[x2 + 1][y1] -= 1 diff[x1][y2 + 1] -= 1 diff[x2 + 1][y2 + 1] += 1for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) insert(x1, y1, x2, y2, 1)for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1] + diff[i][j]for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = 1 if g[i][j] % 2 else 0for i in range(1, n + 1): print(&#x27;&#x27;.join(map(str, g[i][1:]))) 美丽的 2123456n = 2020res = 0for i in range(1, n + 1): if &#x27;2&#x27; in str(i): res += 1print(res) 数的拆分！！暴力（10%） 123456789101112131415161718192021T = int(input())nums = []for i in range(2, 10000): for j in range(2, 1000): if i ** j &gt; 1e9: break nums.append(i ** j)nums.sort()def check(a): if a in nums: return &#x27;yes&#x27; else: for num in nums: if a &lt; num: return &#x27;no&#x27; if a % num == 0 and a // num in nums: return &#x27;yes&#x27; return &#x27;no&#x27;for _ in range(T): a = int(input()) print(check(a)) 数学 12345678910111213141516171819202122232425262728293031323334status = [True] * 4001primes = []def is_square(x): n = round(x ** 0.5) return n * n == xdef is_cubic(x): n = round(x ** (1/3)) return n * n * n == xfor i in range(2, 4001): if status[i]: primes.append(i) for j in range(2 * i, 4001, i): status[j] = Falsedef check(a): flag = True for prime in primes: if a % prime == 0: t = 0 while a % prime == 0: a //= prime t += 1 if t == 1: flag = False if flag and (is_square(a) or is_cubic(a)): print(&#x27;yes&#x27;) else: print(&#x27;no&#x27;)T = int(input())for _ in range(T): a = int(input()) if is_square(a) or is_cubic(a): print(&#x27;yes&#x27;) else: check(a) 大写12s = input()print(s.upper()) 重新排序12345678910111213141516171819n = int(input())nums = list(map(int, input().split()))diff = [0] * (n + 2)m = int(input())for _ in range(m): l, r = map(int, input().split()) diff[l] += 1 diff[r + 1] -= 1tmps = [0] * (n + 1)for i in range(1, n + 1): tmps[i] = tmps[i - 1] + diff[i]res1 = res2 = 0for i in range(n): res1 += nums[i] * tmps[i + 1]nums.sort(reverse = True)tmps.sort(reverse = True)for i in range(n): res2 += nums[i] * tmps[i]print(res2 - res1) 消除游戏！！暴力（58.3%） 12345678910111213141516s = list(input())for _ in range(10000): n = len(s) state = [True] * n for i in range(1, n - 1): if s[i] == s[i - 1] and s[i] != s[i + 1]: state[i] = state[i + 1] = 0 elif s[i] != s[i - 1] and s[i] == s[i + 1]: state[i] = state[i - 1] = 0 s = [s[i] for i in range(n) if state[i]] if len(s) == n: breakif s: print(&#x27;&#x27;.join(map(str, s)))else: print(&#x27;EMPTY&#x27;) 技能升级！！暴力（40%） 123456789n, m = map(int, input().split())nums = []for _ in range(n): a, b = map(int, input().split()) while a &gt; 0: nums.append(a) a -= bnums.sort(reverse=True)print(sum(nums[:m])) 二分 123456789101112131415161718192021222324252627282930313233n, m = map(int, input().split())a, b = [], []for i in range(n): x, y = map(int, input().split()) a.append(x) b.append(y)def check(x): cnt = 0 for i in range(n): if a[i] &lt; x: continue cnt += (a[i] - x) // b[i] + 1 if cnt &gt;= m: return True return Falsel, r = 0, 1000000while l &lt;= r: mid = l + r &gt;&gt; 1 if check(mid): l = mid + 1 else: r = mid - 1res = 0surplus = mfor i in range(n): if a[i] &lt; r: continue t = (a[i] - l) // b[i] + 1 if a[i] - (t - 1) * b[i] == r: t -= 1 res += t * a[i] - t * (t - 1) * b[i] // 2 surplus -= tprint(res + surplus * r) 质因数个数！！暴力（80%） 12345678910111213n = int(input())primes = []state = [True] * 5000001for i in range(2, 5000001): if state[i]: primes.append(i) for j in range(2 * i, 5000001, i): state[j] = Falseres = 0for prime in primes: if n % prime == 0: res += 1print(res) ！！数学优化（90%） 123456789101112n = int(input())res = 0i = 2while i * i &lt; n: if n % i == 0: res += 1 while n % i == 0: n //= i i += 1 if n &gt; 1: res += 1print(res) 全排列的价值12345678910n = int(input())nums = [0] + [0] * nMOD = 998244353 fac, sum1 = [1] * (n + 1), [1] * (n + 1)for i in range(2, n + 1): fac[i] = fac[i - 1] * i % MOD sum1[i] = sum1[i - 1] + i % MODfor i in range(2, n + 1): nums[i] = (i * nums[i - 1] + fac[i - 1] * sum1[i - 1]) % MODprint(nums[n]) 混乱的数组123456789101112131415161718192021222324252627282930313233343536n = int(input())if n == 10: print(5) print(&#x27;5 4 3 2 1&#x27;)elif n == 9: print(5) print(&#x27;4 3 2 1 1&#x27;)elif n == 8: print(5) print(&#x27;3 2 2 1 1&#x27;)elif n == 7: print(5) print(&#x27;3 2 1 1 1&#x27;)elif n == 6: print(4) print(&#x27;4 3 2 1&#x27;)elif n == 5: print(4) print(&#x27;3 2 1 1&#x27;)elif n == 4: print(4) print(&#x27;2 2 1 1&#x27;)elif n == 3: print(3) print(&#x27;3 2 1&#x27;)elif n == 2: print(3) print(&#x27;2 1 1&#x27;)elif n == 1: print(2) print(&#x27;2 1&#x27;)else: for i in range(100): if i * (i - 1) // 2 == n: print(i) print(*range(i, 0, -1)) 完全日期1234567891011from datetime import datetime, timedeltastart = datetime(2001, 1, 1)end = datetime(2021, 12, 31)res = 0while start &lt;= end: t = start.strftime(&quot;%Y%m%d&quot;) a = sum([int(i) for i in t]) if a in [4, 9, 16, 25, 36]: res += 1 start += timedelta(days=1)print(res) 带宽1print(200 // 8) 小蓝的旅行计划123456789101112131415161718192021222324252627282930import heapq, sysn, m = map(int, input().split())left = [0]oils = [0] * (n + 1)oils[0] = mcost = []consume = 0for i in range(1, n + 1): a, b, c = map(int, input().split()) left.append(c) if a &gt; m: print(-1) sys.exit(0) if oils[i - 1] &lt; a: while cost and oils[i - 1] &lt; a: price, idx = cost[0] maxadd = min(left[idx], m - oils[i - 1]) if maxadd &gt;= a - oils[i - 1]: maxadd = a - oils[i - 1] consume += price * maxadd oils[i - 1] += maxadd left[idx] -= maxadd if left[idx] == 0: heapq.heappop(cost) if oils[i - 1] &lt; a: print(-1) sys.exit(0) heapq.heappush(cost, (b, i)) oils[i] = oils[i - 1] - aprint(consume) 斐波那契与7123# 14, 16, 17, 23, 34, 37, 43, 56 从14开始，60个循环，# (202202011200 - 14) % 60 = 46print((202202011200 - 14) // 60 * 8 + 8) GCD！！暴力（20%） 1234567891011def gcd(a, b): return gcd(b, a % b) if b else aa, b = map(int, input().split())res = 1maxgcd = 0for i in range(1, 1000000): t = gcd(a + i, b + i) if t &gt; maxgcd: res = i maxgcd = tprint(res) ！！数学 12345678a, b = map(int, input().split())if a &gt; b: a, b = b, ac = b - aif c &lt; a: c = (a // c + 1) * ck = c - aprint(k) 最小权值1234567dp = [float(&#x27;inf&#x27;)] * 2022dp[0] = 0for i in range(1, 2022): for j in range(i): l, r = j, i - j - 1 dp[i] = min(dp[i], 1 + 2 * dp[l] + 3 * dp[r] + l * l * r)print(dp[2021]) 二进制问题！！暴力（40%） 12345678910111213n, k = map(int, input().split())def check(x): cnt = 0 while x: if x &amp; 1: cnt += 1 x &gt;&gt;= 1 return cnt == kres = 0for i in range(1, n + 1): if check(i): res += 1print(res) 最优清零方案！！暴力（60%） 12345678910111213141516171819n, k = map(int, input().split())nums = list(map(int, input().split()))res = 0for _ in range(1000): for i in range(n - k + 1): a = min(nums[i: i + k]) if a: for j in range(i, i + k): nums[j] -= a res += a else: res += nums[i] nums[i] = 0 if all(nums): break for i in range(n - k + 1, n): res += nums[i] nums[i] = 0print(res) ！！优化 12345678910111213n, k = map(int, input().split())nums = list(map(int, input().split()))idx =res = 0while idx + k - 1 &lt; n: mint = min(nums[idx: idx + k]) imint = nums[idx: idx + k].index(mint) if mint &gt; 0: for j in range(idx, idx + k): nums[j] -= mint res += mint idx += imint + 1res += sum(nums)print(res) 本质上升序列！！暴力 1234567891011121314s = &#x27;tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl&#x27;n = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] &lt; s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) ！！动态规划 1234567891011121314s = &#x27;tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl&#x27;n = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] &lt; s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) 矩形拼接123456789101112131415161718192021222324252627282930T = int(input())def check4(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j == k: return True if i == j and a1 + b1 + a2 + b2 - i - j == k: return True if i == k and a1 + b1 + a3 + b3 - i - k == j: return True if j == k and a2 + b2 + a3 + b3 - j - k == i: return True return Falsedef check6(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j or j == k or i == k: return True if i + j == k or i + k == j or j + k == i: return Truefor _ in range(T): a1, b1, a2, b2, a3, b3 = map(int, input().split()) if check4(a1, b1, a2, b2, a3, b3): print(4) elif check6(a1, b1, a2, b2, a3, b3): print(6) else: print(8) 重复字符串1234567891011121314151617k = int(input())s = input()nums = []res = 0if len(s) % k: print(-1)else: n = len(s) // k for i in range(0, len(s), n): nums.append(s[i: i + n]) a = [[0] * 27 for _ in range(n)] for i in range(n): for j in range(k): a[i][ord(nums[j][i]) - 97] += 1 for i in a: res += sum(i) - max(i) print(res) 小蓝做实验1234567891011121314151617181920212223n = 100000000state = [True] * (n + 1)def check(x): for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return Truefor i in range(2, n + 1): if state[i]: for i in range(i * 2, n + 1, i): state[i] = Falseres = 0with open(&#x27;primes_2.txt&#x27;) as f: for i in f.readlines(): i = int(i.strip(&#x27; &#x27;)) if i &gt; 1e8: if check(i): res += 1 else: if state[i]: res += 1print(res)print(342693) 近似gcd1234567891011121314def gcd(a, b): return gcd(b, a % b) if b else an, g = map(int, input().split())nums = list(map(int, input().split()))l = r = res = 0t = -1for r in range(n): a = gcd(g, nums[r]) if a != g: l = t + 1 t = r if r - l + 1 &gt;= 2: res += r - lprint(res) 环境治理1234567891011121314151617181920212223242526n, q = map(int, input().split())D = [list(map(int, input().split())) for _ in range(n)]L = [list(map(int, input().split())) for _ in range(n)]def check(mid): g = [[D[i][j] for j in range(n)] for i in range(n)] circle, remain = mid // n, mid % n for i in range(n): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - circle) for i in range(remain): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - 1) for k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[k][j]) p = sum([sum(i) for i in g]) return p &lt;= ql, r = 0, 10000000while l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l if l &lt; 10000000 else -1) 取模！！暴力（35%） 12345678910111213T = int(input())def check(n, m): for x in range(1, m): for y in range(x + 1, m + 1): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) ！！暴力换个顺序就全通过了 12345678910111213T = int(input())def check(n, m): for y in range(2, m + 1): for x in range(1, y): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) ！！反证法 12345678910111213import sysT = int(input())def check(n, m): for i in range(1, m + 1): if n % i != i - 1: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) 和与乘积！！暴力（30%） 123456789101112n = int(input())nums = list(map(int, input().split()))muls, sums = [1] * (n + 1), [0] * (n + 1)for i in range(1, n + 1): muls[i] = muls[i - 1] * nums[i - 1] sums[i] = sums[i - 1] + nums[i - 1]res = 0for r in range(1, n + 1): for l in range(1, i + 1): if sums[r] - sums[l - 1] == muls[r] // muls[l - 1]: res += 1print(res) ！！优化–处理连续的1 1234567891011121314151617181920212223242526272829303132n = int(input())nums = list(map(int, input().split()))res = cnt = 0preone = [0] * (n) # 前面有多少个1for i in range(n): preone[i] = cnt if nums[i] == 1: cnt += 1 else: cnt = 0for r in range(n): he, ji = 0, 1 l = r while l &gt;= 0: he += nums[l] ji *= nums[l] if he == ji: res += 1 if ji - he &gt; l: break if preone[l] == 0: l -= 1 continue if ji &lt;= he: he += preone[l] else: he += preone[l] if ji &lt;= he: res += 1 l -= preone[l] l -= 1print(res) 替换字符！！暴力（40%） 123456789s = list(input())n = len(s)m = int(input())for _ in range(m): l, r, x, y = input().split() for i in range(int(l), int(r) + 1): if s[i - 1] == x: s[i - 1] = yprint(&#x27;&#x27;.join(map(str, s))) ！！用replace方法 1234567891011s = input()m = int(input())for _ in range(m): l, r, x, y = input().split() l, r = int(l), int(r) s1 = s[: l - 1] s2 = s[l - 1: r] s2 = s2.replace(x, y) s3 = s[r:] s = s1 + s2 + s3print(s) 打折！！暴力（40%） 123456789101112131415161718n, m = map(int, input().split())nums = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(1001)]for _ in range(m): s, t, p, c = map(int, input().split()) tmps = [] for _ in range(c): a, b = map(int, input().split()) tmps.append((a, b * p // 100, b)) for i in range(1, 1001): for tmp in tmps: if s &lt;= i &lt;= t: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[1]) else: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[2])res = float(&#x27;inf&#x27;)for num in nums: res = min(res, sum(num[1:]))print(res) 翻转括号序列123456789101112131415161718192021222324n, m = map(int, input().split())s = input()nums = [0] * nfor i in range(n): if s[i] == &#x27;(&#x27;: nums[i] = 1 else: nums[i] = -1for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: l, r = int(li[1]), int(li[2]) for i in range(l - 1, r): nums[i] *= -1 if li[0] == 2: l = int(li[1]) - 1 res = t = 0 for i in range(l, n): t += nums[i] if t &lt; 0: break elif t == 0: res = i + 1 print(res) 斐波那契数组12345678910111213n = int(input())fib = [1, 1]res = 0nums = list(map(int, input().split()))dic = &#123;&#125;for i in range(2, 30): fib.append(fib[i - 1] + fib[i - 2])for i in range(n): if i &gt;= 30: res += 1 else: dic[nums[i] / fib[i]] = dic.get(nums[i] / fib[i], 0) + 1print(res + min(30, n) - max(dic.values())) 最少的1！！暴力（30%） 1234567891011121314def fun(x): cnt = 0 while x: if x &amp; 1: cnt += 1 x &gt;&gt;= 1 return cntn = int(input())res = float(&#x27;inf&#x27;)for i in range(2, 1000): cnt = fun(n) n *= i res = min(res, cnt)print(res) 冰山！！暴力（80%） 1234567891011121314151617181920n, m, k = map(int, input().split())nums = &#123;&#125;a = list(map(int, input().split()))for i in a: nums[i] = nums.get(i, 0) + 1MOD = 998244353for _ in range(m): x, y = map(int, input().split()) nums = &#123;k + x: v for k, v in nums.items() if k + x &gt; 0&#125; for key, value in nums.copy().items(): if key &gt; k: del nums[key] nums[k] = (nums.get(k, 0) + value) % MOD nums[1] = (nums.get(1, 0) +(key - k) * value) % MOD if y: nums[y] = nums.get(y, 0) + 1 res = 0 for key, value in nums.items(): res = (res + key * value) % MOD print(res) 六六大顺！！暴力（30%） 123456n = int(input())res = 0for i in range(n): t = i * &#x27;4&#x27; + &#x27;3&#x27; + i * &#x27;5&#x27; + &#x27;6&#x27; res += int(t)print(res) 补给12345678910111213141516171819202122232425n, d = map(int, input().split())g = [[0] * n for _ in range(n)]p = [list(map(int, input().split())) for _ in range(n)]for i in range(n): for j in range(i + 1, n): t = ((p[i][0] - p[j][0])**2 + (p[i][1] - p[j][1])**2) ** 0.5 if t &gt; d: g[i][j] = g[j][i] = float(&#x27;inf&#x27;) else: g[i][j] = g[j][i] = t# floydfor k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[j][k])f = [[float(&#x27;inf&#x27;)] * n for j in range(1 &lt;&lt; n)]f[1][0] = 0for j in range(1, 1 &lt;&lt; n): for i in range(n): if (j &gt;&gt; i) &amp; 1: for k in range(n): if k != i and (j &gt;&gt; k) &amp; 1: f[j][i] = min(f[j][i], f[j - (1 &lt;&lt; i)][k] + g[k][i])res = min(f[(1 &lt;&lt; n) - 1][i] + g[i][0] for i in range(n))print(f&quot;&#123;res:.2f&#125;&quot;) 分石头12345678910111213141516171819202122232425262728293031323334t=int(input())def is_prime(i): count=0 j=3 while 1: if(i%j==0): count+=1 i//=j j=2 j+=1 if(i==1):break if(j*j&gt;=i): if(j*j==i): count+=1 count+=1 break return count%2for _ in range(t): n=int(input()) a=list(map(int,input().split())) ou=0;ji=0 s=0 for i in a: while i%2==0: i//=2 if(is_prime(i)==0): ou+=1 else:ji+=1 # 如果石子堆数是奇数，或者质数的数量是奇数，则小蓝有必胜策略 if(len(a)%2==1 or ji%2==1): print(1) else: print(0) 注意二分找左边界l=mid+1,找右边界r=mid-1，并且mid=l+r+1&gt;&gt;1","tags":["算法","Python","蓝桥杯"],"categories":["算法"]},{"title":"蓝桥杯辅导课","path":"/2024/03/29/蓝桥杯辅导课/","content":"蓝桥杯算法递归与递推递归实现指数型枚举92. 递归实现指数型枚举 1234567891011n = int(input())st = []def dfs(u): if u == n + 1: print(&#x27; &#x27;.join(map(str, st))) return dfs(u + 1) st.append(u) dfs(u + 1) st.pop()dfs(1) 递归实现排列型枚举94. 递归实现排列型枚举 1234567891011121314n = int(input())st = [0] * (n + 1)used = [False] * (n + 1)def dfs(u): if u == n + 1: print(&#x27; &#x27;.join(map(str, st[1:]))) return for i in range(1, n + 1): if not used[i]: st[u] = i used[i] = True dfs(u + 1) used[i] = Falsedfs(1) 递归实现组合型枚举93. 递归实现组合型枚举 123456789101112n, m = map(int, input().split())st = [0] * (m + 1)def dfs(u, start): if n + u - start &lt; m: return if u == m + 1: print(&#x27; &#x27;.join(map(str, st[1:]))) return for i in range(start, n + 1): st[u] = i dfs(u + 1, i + 1)dfs(1, 1) 带分数1209. 带分数 1234567891011121314151617181920212223242526272829n = int(input())st = [0] * 10res = 0def check(a, c): b = n * c - a * c nums = set(&#x27;123456789&#x27;) return set(str(a) + str(b) + str(c)) == numsdef dfs_c(u, a, c): b = n * c - a * c if len(str(a) + str(b) + str(c)) &gt; 9: return global res res += check(a, c) for i in range(1, 10): if not st[i]: st[i] = True dfs_c(u + 1, a, c * 10 + i) st[i] = Falsedef dfs_a(u, a): if a &gt;= n: return dfs_c(u, a, 0) for i in range(1, 10): if not st[i]: st[i] = True dfs_a(u + 1, a * 10 + i) st[i] = Falsedfs_a(0, 0)print(res) 简单斐波那契717. 简单斐波那契 12345n = int(input())nums = [0, 1] + [0] * nfor i in range(2, n + 1): nums[i] = nums[i - 1] + nums[i - 2]print(&#x27; &#x27;.join(map(str, nums[:n]))) 费解的开关95. 费解的开关 12345678910111213141516171819202122232425262728t = int(input())dirs = [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)]def turn(a, b): for i in range(5): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; 5 and 0 &lt;= y &lt; 5: g[x][y] = &#x27;1&#x27; if g[x][y] == &#x27;0&#x27; else &#x27;0&#x27;for idx in range(t): g = [list(input()) for _ in range(5)] if idx &lt; t - 1: input() res = 10 tmp = [i[:] for i in g] for x in range(32): stp = 0 for i in range(5): if x &gt;&gt; i &amp; 1: turn(0, i) stp += 1 for i in range(4): for j in range(5): if g[i][j] == &#x27;0&#x27;: turn(i + 1, j) stp +=1 if &#x27;0&#x27; not in g[4]: res = min(res, stp) g = [i[:] for i in tmp] print(-1 if res &gt; 6 else res) 翻硬币1208. 翻硬币 1234567a, b = list(input()), list(input())res = 0for i in range(len(a) - 1): if a[i] != b[i]: a[i+1] = &#x27;o&#x27; if a[i+1] == &#x27;*&#x27; else &#x27;*&#x27; res += 1print(res) 飞行员兄弟116. 飞行员兄弟 1234567891011121314151617181920212223g = [list(input()) for _ in range(4)]res = []def turn(x, y): backup[x][y] = &#x27;-&#x27; if backup[x][y] == &#x27;+&#x27; else &#x27;+&#x27;def turn_all(x, y): for i in range(4): turn(x, i) turn(i, y) turn(x, y)for x in range(1 &lt;&lt; 16): tmp = [] backup = [i[:] for i in g] for i in range(4): for j in range(4): if x &gt;&gt; (4 * i + j) &amp; 1: turn_all(i, j) tmp.append((i+1, j+1)) if not any(&#x27;+&#x27; in i for i in backup): if len(res) &lt; len(tmp): res = [i[:] for i in tmp]print(len(res))for i in res: print(i[0], i[1]) 二分与前缀和数的范围789. 数的范围 123456789101112131415161718192021222324n, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l, r = 0, n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &gt;= k: r = mid else: l = mid + 1 if nums[l] == k: print(l, end=&#x27; &#x27;) r = n - 1 while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if nums[mid] &lt;= k: l = mid else: r = mid - 1 if nums[l] == k: print(l) else: print(-1, -1) bisect 1234567891011import bisectn, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l = bisect.bisect_left(nums, k) r = bisect.bisect_right(nums, k) if l != r: print(l, r - 1) else: print(-1, -1) 数的三次方根790. 数的三次方根 123456789n = float(input())l, r = -10000, 10000while r - l &gt; 1e-8: mid = (l + r) / 2 if mid * mid * mid &lt;= n: l = mid else: r = midprint(f&#x27;&#123;l:.6f&#125;&#x27;) 机器人跳跃问题730. 机器人跳跃问题 12345678910111213141516171819n = int(input())nums = list(map(int, input().split()))h = max(nums)def check(e): for num in nums: e = 2 * e - num if e &gt; h: return True elif e &lt; 0: return False return Truel, r = 0, hwhile l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) 四平方和1221. 四平方和 暴力 12345678910import mathn = int(input())def fun(): for i in range(int((n/4) ** 0.5) + 1): for j in range(i, int(((n - i*i) / 3) ** 0.5) + 1): for k in range(j, int(((n - i*i - j*j) / 2) ** 0.5) + 1): l = int(math.sqrt(n - i*i - j*j - k*k)) if i*i + j*j + k*k + l*l == n: return i, j, k, lprint(*fun()) 哈希表 12345678910111213n = int(input())dic = &#123;&#125;for c in range(int(n ** 0.5) + 1): for d in range(int((n - c*c) ** 0.5) + 1): t = c*c + d*d if t not in dic: dic[t] = (c, d)for a in range(int(n ** 0.5) + 1): for b in range(int((n - a*a) ** 0.5) + 1): t = n - a*a - b*b if t in dic: print(a, b, dic[t][0], dic[t][1]) exit() 分巧克力1227. 分巧克力 1234567891011121314151617n, k = map(int, input().split())chocolates = [list(map(int, input().split())) for _ in range(n)]def check(x): t = 0 for chocolate in chocolates: t += (chocolate[0] // x) * (chocolate[1] // x) if t &gt;= k: return True return Falsel, r = 1, 100000while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if check(mid): l = mid else: r = mid - 1print(l) 前缀和795. 前缀和 12345678n, m = map(int, input().split())nums = list(map(int, input().split()))sums = [0] + nums[:]for i in range(1, n+1): sums[i] += sums[i-1]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l-1]) 子矩阵的和796. 子矩阵的和 1234567891011from sys import stdininput = lambda: stdin.readline().strip()n, m, q = map(int, input().split())nums = [[0] * (m+1)] + [[0] + list(map(int, input().split())) for _ in range(n)]sums = [num[:] for num in nums]for i in range(1, n+1): for j in range(1, m+1): sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1-1][y2] - sums[x2][y1-1] + sums[x1-1][y1-1]) 激光炸弹99. 激光炸弹 - AcWing题 12345678910111213141516171819cnt, r = map(int, input().split())values = [[0] * 5002 for _ in range(5002)]r = min(r, 5001)n = m = rfor _ in range(cnt): x, y, w = map(int, input().split()) x += 1 y += 1 n, m = max(n, x), max(m, y) values[x][y] += wfor i in range(1, n+1): for j in range(1, m+1): values[i][j] += values[i-1][j] + values[i][j-1] - values[i-1][j-1]res = 0for i in range(r, n+1): for j in range(r, m+1): t = values[i][j] - values[i-r][j] - values[i][j-r] + values[i-r][j-r] res = max(res, t)print(res) K倍区间1230. K倍区间 12345678910n, k = map(int, input().split())sums = [0] + [int(input()) for _ in range(n)]for i in range(1, n+1): sums[i] += sums[i-1]cnt = [0] * (n+1)res = 0for i in range(n+1): res += cnt[sums[i] % k] cnt[sums[i] % k] += 1print(res) 数学与简单DP买不到的数目AcWing 1205. 买不到的数目 暴力 1234567891011121314n, m = map(int, input().split())def check(i, n, m): if not i: return True if i &gt;= n and check(i-n, n, m): return True if i &gt;= m and check(i-m, n, m): return True return Falseres = 0for i in range(1, 1000): if not check(i, n, m): res = iprint(res) 优化 12345678910111213n, m = map(int, input().split())dp = [False] * (1000001)dp[0] = Truefor i in range(1, 1000001): if i &gt;= m: dp[i] |= dp[i-m] if i &gt;= n: dp[i] |= dp[i-n]res = 0for i in range(1, 1000001): if not dp[i]: res = iprint(res) 公式 12n, m = map(int, input().split())print((n-1) * (m-1) - 1) 蚂蚁感冒1211. 蚂蚁感冒 123456789101112n = int(input())nums = list(map(int, input().split()))left = right = 0for i in range(1, n): if abs(nums[0]) &gt; abs(nums[i]) and nums[i] &gt; 0: left += 1 elif abs(nums[0]) &lt; abs(nums[i]) and nums[i] &lt; 0: right += 1if nums[0] &gt; 0 and not right or nums[0] &lt; 0 and not left: print(1)else: print(1 + left + right) 饮料换购1216. 饮料换购 123456n = int(input())res = nwhile n &gt; 2: res += n // 3 n = n // 3 + n % 3print(res) 背包问题2. 01背包问题 123456789n, v = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0] * (v+1) for _ in range(n+1)]for i in range(1, n+1): for j in range(1, v+1): dp[i][j] = dp[i-1][j] if j &gt;= nums[i-1][0]: dp[i][j] = max(dp[i][j], dp[i-1][j-nums[i-1][0]] + nums[i-1][1])print(dp[n][v]) 摘花生1015. 摘花生 123456789t = int(input())for _ in range(t): r, c = map(int, input().split()) g = [list(map(int, input().split())) for _ in range(r)] dp = [[0] * (c+1) for _ in range(r+1)] for i in range(1, r+1): for j in range(1, c+1): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + g[i-1][j-1] print(dp[i][j]) 最长上升子序列895. 最长上升子序列 12345678n = int(input())nums = [0] + list(map(int, input().split()))dp = [1] * (n+1)for i in range(1, n+1): for j in range(1, i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1)print(max(dp)) 地宫取宝1212. 地宫取宝 1234567891011121314151617n, m, k = map(int, input().split())MOD = 1000000007g = [[0] * (m+1)] + [[0] + list(map(lambda x: int(x) + 1, input().split())) for _ in range(n)]dp = [[[[0] * 14 for _ in range(k+1)] for _ in range(m+1)] for _ in range(n+1)]dp[1][1][1][g[1][1]] = 1dp[1][1][0][0] = 1for i in range(1, n+1): for j in range(1, m+1): if i == 1 and j == 1: continue for u in range(k+1): for v in range(14): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u][v] + dp[i][j-1][u][v]) % MOD if u &gt; 0 and v == g[i][j]: for t in range(v): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u-1][t] + dp[i][j-1][u-1][t])print(sum(dp[i][j][k]) % MOD) 波动数列1214. 波动数列 12345678n, s, a, b = map(int, input().split())dp = [[0] * n for _ in range(n)]dp[0][0] = 1MOD = 100000007for i in range(1, n): for j in range(n): dp[i][j] = (dp[i-1][(j-i*a) % n] + dp[i-1][(j+i*b) % n]) % MODprint(dp[n-1][s%n]) 枚举、模拟与排序连号区间数1210. 连号区间数 1234567891011n = int(input())nums = list(map(int, input().split()))res = 0for i in range(n): minv, maxv = float(&#x27;inf&#x27;), float(&#x27;-inf&#x27;) for j in range(i, n): minv = min(minv, nums[j]) maxv = max(maxv, nums[j]) if maxv - minv == j - i: res += 1print(res) 递增三元组1236. 递增三元组 前缀和 1234567891011121314151617n = int(input())a = list(map(lambda x: int(x) + 1, input().split()))b = list(map(lambda x: int(x) + 1, input().split()))c = list(map(lambda x: int(x) + 1, input().split()))cnta, cntc, suma, sumc = [0] * 100002, [0] * 100002, [0] * 100002, [0] * 100002for i in range(n): cnta[a[i]] += 1for i in range(1, 100002): suma[i] = suma[i-1] + cnta[i]for i in range(n): cntc[c[i]] += 1for i in range(1, 100002): sumc[i] = sumc[i-1] + cntc[i]res = 0for i in b: res += suma[i-1] * (n - sumc[i])print(res) 二分 12345678910111213import bisectn = int(input())a = list(map(int, input().split()))b = list(map(int, input().split()))c = list(map(int, input().split()))a.sort()c.sort()res = 0for i in b: l = bisect.bisect_left(a, i) r = bisect.bisect_right(c, i) res += l * (n-r)print(res) 特别数的和1245. 特别数的和 123456n = int(input())res = 0for i in range(1, n+1): if &#x27;0&#x27; in str(i) or &#x27;1&#x27; in str(i) or &#x27;2&#x27; in str(i) or &#x27;9&#x27; in str(i): res += iprint(res) 错误票据1204. 错误票据 123456789101112n = int(input())nums = []for _ in range(n): nums.extend(map(int, input().split()))nums.sort()a = b = 0for i in range(1, len(nums)): if nums[i] == nums[i-1] + 2: a = nums[i] - 1 elif nums[i] == nums[i-1]: b = nums[i]print(a, b) 回文日期466. 回文日期 123456789101112date1, date2 = input(), input()days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]rev = [&#x27;92200229&#x27;]for i in range(1, 13): for j in range(1, days[i] + 1): t = f&#x27;&#123;i:02d&#125;&#123;j:02d&#125;&#x27; rev.append(t[::-1] + t)res = 0for i in rev: if date1 &lt;= i &lt;= date2: res += 1print(res) 移动距离1219. 移动距离 1234567w, m, n = map(int, input().split())m, n = m - 1, n - 1x1, x2 = m // w, n // wy1, y2 = m % w, n % wif x1 % 2: y1 = w - 1 - y1if x2 % 2: y2 = w - 1 - y2print(abs(x1 - x2) + abs(y1 - y2)) 日期问题1229. 日期问题 1234567891011121314151617from time import strptimel, r, s = &#x27;1960-01-01&#x27;, &#x27;2059-12-31&#x27;, input().split(&#x27;/&#x27;)res = []def check(date): if l &lt;= date &lt;= r: try: strptime(date, &#x27;%Y-%m-%d&#x27;) res.append(date) except: passfor i in [&#x27;19&#x27;, &#x27;20&#x27;]: check(i + s[0] + &#x27;-&#x27; + s[1] + &#x27;-&#x27; + s[2]) check(i + s[2] + &#x27;-&#x27; + s[1] + &#x27;-&#x27; + s[0]) check(i + s[2] + &#x27;-&#x27; + s[0] + &#x27;-&#x27; + s[1])res.sort()for i in set(res): print(i) 航班时间1231. 航班时间 12345678910111213t = int(input())for _ in range(t): res = 0 for _ in range(2): a = input().split() for i in range(len(a)): if i == 2: res += int(a[2][2]) * 24 * 3600 else: b = list(map(int, a[i].split(&#x27;:&#x27;))) res += (-1) ** (i+1) * (b[0] * 3600 + b[1] * 60 + b[2]) res //= 2 print(f&#x27;&#123;res // 3600:02d&#125;:&#123;res % 3600 // 60:02d&#125;:&#123;res % 60:02d&#125;&#x27;) 外卖店优先级1241. 外卖店优先级 12345678910111213141516n, m, t = map(int, input().split())a, st, last = [0] * (n+1), [0] * (n+1), [0] * (n+1)b = [list(map(int, input().split())) for _ in range(m)]b.sort()for i, j in b: a[j] = max(0, a[j] - max(0, i - last[j] - 1)) if a[j] &lt;= 3: st[j] = 0 a[j], last[j] = a[j] + 2, i if a[j] &gt; 5: st[j] = 1for i in range(1, n+1): a[i] = max(0, a[i] - t + last[i]) if a[i] &lt;= 3: st[i] = 0print(sum(st)) 归并排序787. 归并排序 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l &gt;= r: return mid = l + r &gt;&gt; 1 merge_sort(l, mid) merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt; nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmpmerge_sort(0, n - 1)print(*nums) 逆序对的数量788. 逆序对的数量 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l &gt;= r: return 0 mid = l + r &gt;&gt; 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt;= nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) 树状数组与线段树动态求连续区间和树状数组 1264. 动态求连续区间和 1234567891011121314151617181920212223n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [0] * (n+1)def lowbit(x): return x &amp; -xdef add(x, v): while x &lt;= n: tree[x] += v x += lowbit(x)def query(x): res = 0 while x &gt; 0: res += tree[x] x -= lowbit(x) return resfor i in range(1, n+1): add(i, nums[i])for _ in range(m): k, a, b = map(int, input().split()) if k: add(a, b) else: print(query(b) - query(a-1)) 线段树 1234567891011121314151617181920212223242526272829303132333435363738394041n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): tree[u][2] = tree[u &lt;&lt; 1][2] + tree[u &lt;&lt; 1 | 1][2]def build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r &gt;&gt; 1 build(u &lt;&lt; 1, l, mid) build(u &lt;&lt; 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] &gt;= l and tree[u][1] &lt;= r: return tree[u][2] mid = tree[u][0] + tree[u][1] &gt;&gt; 1 res = 0 if l &lt;= mid: res += query(u &lt;&lt; 1, l, r) if r &gt; mid: res += query(u &lt;&lt; 1 | 1, l, r) return resdef modify(u, x, v): if tree[u][0] == tree[u][1]: tree[u][2] += v else: mid = tree[u][0] + tree[u][1] &gt;&gt; 1 if x &lt;= mid: modify(u &lt;&lt; 1, x, v) else: modify(u &lt;&lt; 1 | 1, x, v) pushup(u)build(1, 1, n)for _ in range(m): k, a, b = map(int, input().split()) if k: modify(1, a, b) else: print(query(1, a, b)) 数星星1265. 数星星 123456789101112131415161718192021n = int(input())tree = [0] * 32002res = [0] * ndef lowbit(x): return x &amp; -xdef add(x): while x &lt;= 32001: tree[x] += 1 x += lowbit(x)def query(x): res = 0 while x &gt; 0: res += tree[x] x -= lowbit(x) return resfor _ in range(n): x, y = map(int, input().split()) res[query(x+1)] += 1 add(x+1)for i in res: print(i) 数列区间最大值1270. 数列区间最大值 dp(爆空间) 123456789n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))dp = [[0] * (n+1) for _ in range(n+1)]for i in range(1, n + 1): for j in range(i, n + 1): dp[i][j] = max(dp[i][j - 1], nums[j])for _ in range(m): x, y = map(int, input().split()) print(dp[x][y]) 线段树(TLE) 1234567891011121314151617181920212223242526272829n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): t = max(tree[u &lt;&lt; 1][2], tree[u &lt;&lt; 1 | 1][2]) tree[u][2] = tdef build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r &gt;&gt; 1 build(u &lt;&lt; 1, l, mid) build(u &lt;&lt; 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] &gt;= l and tree[u][1] &lt;= r: return tree[u][2] mid = tree[u][0] + tree[u][1] &gt;&gt; 1 left = right = 0 if l &lt;= mid: left = query(u &lt;&lt; 1, l, r, ) if r &gt; mid: right = query(u &lt;&lt; 1 | 1, l, r) return max(left, right)build(1, 1, n)for _ in range(m): x, y = map(int, input().split()) print(query(1, x, y)) 小朋友排队1215. 小朋友排队 12345678910111213141516171819202122232425262728N = 1000001n = int(input())nums = [0] + list(map(lambda x: int(x) + 1, input().split()))ct = [0] * (n + 1)def lowbit(x): return x &amp; -xdef add(x, v): while x &lt;= N: tree[x] += v x += lowbit(x)def query(x): res = 0 while x &gt; 0: res += tree[x] x -= lowbit(x) return restree = [0] * (N + 1)for i in range(1, n + 1): ct[i] = query(N) - query(nums[i]) add(nums[i], 1)tree = [0] * (N + 1)for i in range(n, 0, -1): ct[i] += query(nums[i] - 1) add(nums[i], 1)res = 0for i in ct[1:]: res += i * (i + 1) &gt;&gt; 1print(res) 油漆面积1228. 油漆面积 12线段树太难，跳过！ 三体攻击1232. 三体攻击 二分 + 三维差分 (难) 12345678910111213141516171819202122232425262728293031323334353637383940414243from sys import stdininput = lambda: stdin.readline().strip()def get(i, j, k): return (i * B + j) * C + kdef check(mid): b = [0]*N for i in range(1, mid + 1): x1, x2, y1, y2, z1, z2, c = op[i] b[get(x1, y1, z1)] -= c b[get(x1, y1, z2 + 1)] += c b[get(x1, y2 + 1, z1)] += c b[get(x1, y2 + 1, z2 + 1)] -= c b[get(x2 + 1, y1, z1)] += c b[get(x2 + 1, y1, z2 + 1)] -= c b[get(x2 + 1, y2 + 1, z1)] -= c b[get(x2 + 1, y2 + 1, z2 + 1)] += c # 对b求一下三维前缀和 arr = s[:] for i in range(1, A + 1): for j in range(1, B + 1): for k in range(1, C + 1): b[get(i, j, k)] += b[get(i - 1, j, k)] + b[get(i,j-1,k)] + b[get(i,j,k-1)] + b[get(i-1,j-1,k-1)] - \\ b[get(i - 1, j - 1, k)] - b[get(i - 1, j, k - 1)] - b[get(i, j - 1, k - 1)] arr[get(i, j, k)] += b[get(i,j,k)] if arr[get(i, j, k)] &lt; 0: return True return FalseA, B, C, m = map(int, input().split())N = (A+1)*(B+1)*(C+1)s, b, bp = [0]*N, [0]*N, [0]*Narr = list(map(int, input().split()))t = 0for i in range(1, A+1): for j in range(1, B+1): for k in range(1, C+1): s[get(i,j,k)] = arr[t] # 把地球军队的生命值给赋值 t += 1op = [[]] + [list(map(int, input().split())) for _ in range(m)]l, r = 1, mwhile l &lt; r: mid = l + r &gt;&gt; 1 if check(mid): r = mid else: l = mid + 1print(l) 差分797. 差分 1234567891011121314n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diff = [0] * (n + 2)def insert(l, r, c): diff[l] += c diff[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diff[i]print(*nums[1:]) 差分矩阵798. 差分矩阵 1234567891011121314151617n, m, q = map(int, input().split())nums = [[0] * (m + 1)] + [[0] + list(map(int, input().split())) for _ in range(n)]diff = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += c diff[x1][y2 + 1] -= c diff[x2 + 1][y1] -= c diff[x2 + 1][y2 + 1] += cfor _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): insert(i, j, i, j, nums[i][j]) nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diff[i][j] print(nums[i][j], end=&#x27; &#x27;) print() 螺旋折线1237. 螺旋折线 123456789x, y = map(int, input().split())if abs(x) &lt;= y: print(2 * y * (2 * y - 1) + x + y)elif abs(y) &lt;= x: print(2 * x * 2 * x + x - y)elif abs(x) &lt;= -y + 1: print(2 * -y * (2 * -y + 1) - x - y)else: print((2 * -x - 1) * (2 * -x - 1) - x + y - 1) 双指针、BFS与图论日志统计1238. 日志统计 12345678910111213141516n, d, k = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort()cnt, st = [0] * 100001, [False] * 100001j = 0for i in range(n): idx = nums[i][1] cnt[idx] += 1 while nums[i][0] - nums[j][0] &gt;= d: cnt[nums[j][1]] -= 1 j += 1 if cnt[idx] &gt;= k: st[idx] = Truefor i in range(100001): if st[i]: print(i) 献给阿尔吉侬的花束1101. 献给阿尔吉侬的花束 1234567891011121314151617181920212223242526272829from collections import dequet = int(input())dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(start, end, g): q = deque() q.append(start) dist = [[-1] * c for _ in range(r)] dist[start[0]][start[1]] = 0 while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; r and 0 &lt;= y &lt; c and g[x][y] != &#x27;#&#x27; and dist[x][y] == -1: dist[x][y] = dist[a][b] + 1 if x == end[0] and y == end[1]: print(dist[x][y]) return q.append((x, y)) print(&#x27;oop!&#x27;)for _ in range(t): r, c = map(int, input().split()) g = [input() for _ in range(r)] for i in range(r): for j in range(c): if g[i][j] == &#x27;S&#x27;: start = (i, j) elif g[i][j] == &#x27;E&#x27;: end = (i, j) bfs(start, end, g) 红与黑1113. 红与黑 dfs 123456789101112131415161718192021dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dfs(a, b): cnt = 1 st[a][b] = True for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and g[x][y] == &#x27;.&#x27; and not st[x][y]: st[x][y] = True cnt += dfs(x, y) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == &#x27;@&#x27;: print(dfs(i, j)) break bfs 123456789101112131415161718192021222324252627from collections import dequedirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) cnt = 1 st[a][b] = True while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and g[x][y] == &#x27;.&#x27; and not st[x][y]: st[x][y] = True cnt += 1 q.append((x, y)) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == &#x27;@&#x27;: print(bfs(i, j)) break 交换瓶子1224. 交换瓶子 贪心 12345678910111213n = int(input())nums = [0] + list(map(int, input().split()))st = [False] * (n + 1)cnt = 0for i in range(1, n + 1): t = nums[i] if not st[t]: st[t] = True cnt += 1 while not st[nums[t]]: st[nums[t]] = True t = nums[t]print(n - cnt) 并查集 12345678910111213141516171819n = int(input())nums = [0] + list(map(int, input().split()))fa = [i for i in range(n + 1)]s = [0] * (n + 1)def find(x): if fa[x] == x: return x fa[x] = find(fa[x]) return fa[x]for i in range(1, n + 1): fx, fy = find(nums[i]), find(nums[nums[i]]) fa[fx] = fyfor i in range(1, n + 1): s[find(i)] += 1res = 0for i in range(1, n + 1): if s[i]: res += s[i] - 1print(res) 完全二叉树的权值1240. 完全二叉树的权值 前缀和 1234567891011121314n = int(input())nums = [0] + list(map(int, input().split()))for i in range(1, n + 1): nums[i] += nums[i - 1]res, depth = float(&#x27;-inf&#x27;), 1i = j = 1while i &lt;= n: t = nums[min(n, i * 2 - 1)] - nums[i - 1] if t &gt; res: res = t depth = j i *= 2 j += 1print(depth) 地牢大师1096. 地牢大师 12345678910111213141516171819202122232425262728293031323334from collections import dequedirs = [(1, 0 ,0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]def bfs(start, end): q = deque() q.append(start) dist = [[[-1] * c for _ in range(r)] for _ in range(l)] dist[start[0]][start[1]][start[2]] = 0 while q: a, b, d = q.popleft() for i in range(6): x, y, z = a + dirs[i][0], b + dirs[i][1], d + dirs[i][2] if 0 &lt;= x &lt; l and 0 &lt;= y &lt; r and 0 &lt;= z &lt; c and g[x][y][z] != &#x27;#&#x27; and dist[x][y][z] == -1: dist[x][y][z] = dist[a][b][d] + 1 if x == end[0] and y == end[1] and z == end[2]: print(f&#x27;Escaped in &#123;dist[x][y][z]&#125; minute(s).&#x27;) return q.append((x, y, z)) print(&#x27;Trapped!&#x27;)while True: l, r, c = map(int, input().split()) if not l: break g = [0] * l for i in range(l): g[i] = [input() for _ in range(r)] input() for i in range(l): for j in range(r): for k in range(c): if g[i][j][k] == &#x27;S&#x27;: start = (i, j, k) elif g[i][j][k] == &#x27;E&#x27;: end = (i, j, k) bfs(start, end) 全球变暖1233. 全球变暖 123456789101112131415161718192021222324252627282930313233from collections import dequen = int(input())g = [input() for _ in range(n)]st = [[False] * n for _ in range(n)]dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) total = bound = 0 st[a][b] = True while q: a, b = q.popleft() total += 1 is_bound = False for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; n: if g[x][y] == &#x27;.&#x27;: is_bound = True elif g[x][y] == &#x27;#&#x27; and not st[x][y]: st[x][y] = True q.append((x, y)) if is_bound: bound += 1 if total == bound: global res res += 1res = 0for i in range(n): for j in range(n): if g[i][j] == &#x27;#&#x27; and not st[i][j]: bfs(i, j)print(res) 大臣的旅费1207. 大臣的旅费 dfs(爆栈) 12345678910111213141516171819import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]dist = [0] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def dfs(u, father, distance): dist[u] = distance for i, j in g[u]: if i != father: dfs(i, u, distance + j)dfs(1, -1, 0)t = dist.index(max(dist))dfs(t, -1, 0)t = max(dist)print(10 * t + t * (t + 1) // 2) bfs 1234567891011121314151617181920212223from collections import dequen = int(input())g = [[] for _ in range(n + 1)]dist = [-1] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def bfs(u): q = deque([u]) dist[u] = 0 while q: u = q.popleft() for i, j in g[u]: if dist[i] == -1: dist[i] = dist[u] + j q.append(i)bfs(1)t = dist.index(max(dist))dist = [-1] * (n + 1)bfs(t)t = max(dist)print(t * 10 + t * (t + 1) // 2) 贪心股票买卖 II1055. 股票买卖 II 123456n = int(input())nums = list(map(int, input().split()))res = 0for i in range(1, n): res += max(0, nums[i] - nums[i - 1])print(res) 货仓选址104. 货仓选址 12345678n = int(input())nums = list(map(int, input().split()))nums.sort()a = nums[n // 2]res = 0for num in nums: res += abs(a - num)print(res) 糖果传递122. 糖果传递 12345678910111213n = int(input())nums = [0] + [int(input()) for _ in range(n)]sums = [0] * (n + 2)avg = sum(nums) // nfor i in range(n, 1, -1): sums[i] = sums[i + 1] - nums[i] + avgsums = sums[1: n + 1]sums.sort()res = 0a = sums[n // 2]for i in sums: res += abs(i - a)print(res) 123456789101112n = int(input())nums = [int(input()) for _ in range(n)]avg = sum(nums) // na = [0] + [i - avg for i in nums]for i in range(1, n + 1): a[i] += a[i - 1]a = sorted(a[1:])t = a[n // 2]res = 0for i in a: res += abs(t - i)print(res) 雷达设备112. 雷达设备 123456789101112131415161718n, d = map(int, input().split())g = []for _ in range(n): x, y = map(int, input().split()) if y &gt; d: print(-1) exit(0) else: x1 = x - (d * d - y * y) ** 0.5 x2 = x + (d * d - y * y) ** 0.5 g.append((x1, x2))g.sort(key=lambda x: x[1])res, last = 0, float(&#x27;-inf&#x27;)for i in range(n): if g[i][0] &gt; last: res += 1 last = g[i][1]print(res) 付账问题1235. 付账问题 1234567891011121314n, s = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, avg = 0, s / nfor i, num in enumerate(nums): cur = s / (n - i) if num &lt; cur: res += (avg - num) ** 2 s -= num else: res += (cur - avg) ** 2 * (n - i) breakres = (res / n) ** 0.5print(f&#x27;&#123;res:.4f&#125;&#x27;) 乘积最大1239. 乘积最大 12345678910111213141516171819202122n, k = map(int, input().split())nums = [int(input()) for _ in range(n)]MOD = 1000000009nums.sort()res = sign = 1l, r = 0, n - 1if k % 2: res = nums[r] r, k = r - 1, k - 1 if res &lt; 0: sign = -1while k: x, y = nums[l] * nums[l + 1], nums[r] * nums[r - 1] if x * sign &gt; y * sign: res *= x l += 2 else: res *= y r -= 2 res = res % MOD if res &gt; 0 else -(-res % MOD) k -= 2print(res) 后缀表达式1247. 后缀表达式 12345678910n, m = map(int, input().split())nums = list(map(int, input().split()))if not m: print(sum(nums))else: nums.sort() res = nums[-1] - nums[0] for num in nums[1: -1]: res += abs(num) print(res) 灵能传输1248. 灵能传输 123456789101112131415161718192021222324252627282930t = int(input())for _ in range(t): n = int(input()) nums = [0] + list(map(int, input().split())) for i in range(1, n + 1): nums[i] += nums[i - 1] s0, sn = nums[0], nums[-1] if s0 &gt; sn: s0, sn = sn, s0 nums.sort() s0, sn = nums.index(s0), nums.index(sn) l, r = 0, n res = [0] * (n + 1) st = [0] * (n + 1) for i in range(s0, -1, -2): res[l] = nums[i] st[i] = True l += 1 for i in range(sn, n + 1, 2): res[r] = nums[i] st[i] = True r -= 1 for i in range(n + 1): if not st[i]: res[l] = nums[i] l += 1 ans = 0 for i in range(1, n + 1): ans = max(ans, abs(res[i] - res[i - 1])) print(ans) 数论等差数列1246. 等差数列 123456789101112n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else ad = 0for i in range(1, n): d = gcd(nums[i] - nums[0], d)if d: print((nums[-1] - nums[0]) // d + 1)else: print(n) X的因子链1295. X的因子链 12345678910111213141516171819202122232425262728293031323334353637N = (1 &lt;&lt; 20) + 10primes, st, minp = [], [False] * N, [0] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) minp[i] = i j = 0 while i * primes[j] &lt;= n and j &lt; len(primes): st[primes[j] * i] = True minp[primes[j] * i] = primes[j] if i % primes[j] == 0: break j += 1get_prime(N - 1)fact, sums = [0] * 30, [0] * Nwhile True: try: x = int(input()) k = total = 0 while x &gt; 1: p = minp[x] fact[k], sums[k] = p, 0 while x % p == 0: x //= p sums[k] += 1 total += 1 k += 1 res = 1 for i in range(1, total + 1): res *= i for i in range(k): for j in range(1, sums[i] + 1): res //= j print(total, res) except: break 聪明的燕姿1296. 聪明的燕姿 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849N = 50000primes, st = [], [False] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) j = 0 while i * primes[j] &lt;= n: st[i * primes[j]] = True if i % primes[j] == 0: break j += 1def is_prime(x): if x &lt; N: return not st[x] i = 0 while primes[i] &lt;= x / primes[i]: if x % primes[i] == 0: return False i += 1 return Truedef dfs(last, prod, s): if s == 1: res.append(prod) return if s - 1 &gt; (0 if last &lt; 0 else primes[last]) and is_prime(s - 1): res.append(prod * (s - 1)) i = last + 1 while primes[i] &lt;= s / primes[i]: p = primes[i] j, t = 1 + p, p while t &lt;= s: if s % j == 0: dfs(i, prod * t, s // j) t *= p j += t i += 1get_prime(N - 1)while True: try: x = int(input()) res = [] dfs(-1, 1, x) print(len(res)) if res: res.sort() print(*res) except: break 五指山1299. 五指山 123456789101112131415t = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(t): n, d, x, y = map(int, input().split()) gcd, a, b = exgcd(n, d) if (y - x) % gcd: print(&quot;Impossible&quot;) else: b *= (y - x) // gcd print(b % (n // gcd)) 最大比例1223. 最大比例 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else adef gcd_sub(a, b): if a &lt; b: a, b = b, a if b == 1: return a return gcd_sub(b, a // b)a, b = [], []for i in range(1, n): if nums[i] != nums[i - 1]: d = gcd(nums[i], nums[0]) a.append(nums[i] // d) b.append(nums[0] // d)up, down = a[0], b[0]for i in range(1, len(a)): up = gcd_sub(up, a[i]) down = gcd_sub(down, b[i])print(f&#x27;&#123;up&#125;/&#123;down&#125;&#x27;) C 循环1301. C 循环 1234567891011121314151617def exgcd(a, b): if b == 0: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ywhile True: a, b, c, k = map(int, input().split()) if a == 0 and b == 0 and c == 0 and k == 0: break k = 1 &lt;&lt; k gcd, x, y = exgcd(c, k) if (b - a) % gcd: print(&quot;FOREVER&quot;) else: x *= (b - a) // gcd print(x % (k // gcd)) 正则问题1225. 正则问题 1234567891011121314151617181920s = input().strip()i = 0def dfs(): global i res = 0 while i &lt; len(s): if s[i] == &#x27;(&#x27;: i += 1 res += dfs() i += 1 elif s[i] == &#x27;|&#x27;: i += 1 res = max(res, dfs()) elif s[i] == &#x27;)&#x27;: break else: i += 1 res += 1 return resprint(dfs()) 糖果1243. 糖果 IDA* 12345678910111213141516171819202122232425262728293031323334353637383940414243def lowbit(x): return x &amp; -xdef h(st): t = (1 &lt;&lt; m) - 1 - st res = 0 while t: res += 1 i = lowbit(t) t -= i for row in col[log2[i]]: t &amp;= ~row return resdef dfs(depth, st): if depth == 0 or h(st) &gt; depth: return st == (1 &lt;&lt; m) - 1 t = -1 i = (1 &lt;&lt; m) - 1 - st while i: j = lowbit(i) i -= j if t == -1 or len(col[log2[j]]) &lt; len(col[t]): t = log2[j] for row in col[t]: if dfs(depth - 1, row | st): return True return Falsen, m, k = map(int, input().split())log2 = [0] * (1 &lt;&lt; m + 1)for i in range(m): log2[1 &lt;&lt; i] = icol = [[] for _ in range(m + 1)]for _ in range(n): t = list(map(int, input().split())) tt = 0 for ti in t: tt |= 1 &lt;&lt; (ti - 1) for i in range(m): if (tt &gt;&gt; i) &amp; 1: col[i].append(tt)depth = 0while depth &lt;= m and not dfs(depth, 0): depth += 1print(-1 if depth &gt; m else depth) dp 1234567891011121314151617n, m, k = map(int, input().split())dp = [-1] * ((1 &lt;&lt; m) + 1)val = [0] * nfor i in range(n): t = list(map(int, input().split())) for j in t: val[i] |= 1 &lt;&lt; (j - 1) dp[val[i]] = 1for i in range(n): for j in range(1 &lt;&lt; m): if dp[j] == -1: continue if dp[j | val[i]] == -1: dp[j | val[i]] = dp[j] + dp[val[i]] else: dp[j | val[i]] = min(dp[j | val[i]], dp[j] + dp[val[i]])print(dp[(1 &lt;&lt; m) - 1]) 复杂DP鸣人的影分身1050. 鸣人的影分身 1234567891011t = int(input())for _ in range(t): m, n = map(int, input().split()) dp = [[0] * (n + 1) for _ in range(m + 1)] dp[0][0] = 1 for i in range(m + 1): for j in range(1, n + 1): dp[i][j] = dp[i][j - 1] if i &gt;= j: dp[i][j] += dp[i - j][j] print(dp[m][n]) 糖果1047. 糖果 12345678n, k = map(int, input().split())dp = [[float(&#x27;-inf&#x27;)] * (k + 1) for _ in range(n + 1)]dp[0][0] = 0for i in range(1, n + 1): x = int(input()) for j in range(k + 1): dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - x) % k] + x)print(dp[n][0]) 密码脱落1222. 密码脱落 12345678910111213s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]for i in range(n): for l in range(n - i): r = l + i if i == 0: dp[l][r] = 1 else: if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] + 2 dp[l][r] = max(dp[l][r], dp[l + 1][r], dp[l][r - 1])print(n - dp[0][n - 1]) 生命之树1220. 生命之树 123456789101112131415161718import syssys.setrecursionlimit(100000)n = int(input())w = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]dp = [float(&#x27;-inf&#x27;)] * (n + 1)for _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, fa): dp[u] = w[u] for v in adj_list[u]: if v != fa: dfs(v, u) dp[u] += max(0, dp[v])dfs(1, -1) print(max(dp)) 包子凑数1226. 包子凑数 12345678910111213141516171819202122n = int(input())dp = [[0] * 10000 for _ in range(n + 1)]w = [0] + [int(input()) for _ in range(n)]def gcd(a, b): return gcd(b, a % b) if b else ad = w[1]for i in range(2, n + 1): d = gcd(d, w[i])if d == 1: dp[0][0] = 1 for i in range(1, n + 1): for j in range(10000): dp[i][j] = dp[i - 1][j] if j &gt;= w[i]: dp[i][j] |= dp[i][j - w[i]] res = 0 for i in range(10000): if not dp[n][i]: res += 1 print(res)else: print(&quot;INF&quot;) 括号配对1070. 括号配对 12345678910111213141516s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]def check(l, r): if s[l - 1] == &#x27;(&#x27; and s[r - 1] == &#x27;)&#x27;: return True if s[l - 1] == &#x27;[&#x27; and s[r - 1] == &#x27;]&#x27;: return True return Falsefor i in range(n, 0, -1): for j in range(i + 1, n + 1): if check(i, j): dp[i][j] = dp[i + 1][j - 1] + 2 for k in range(i, j): dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j])print(n - dp[1][n]) 斐波那契前 n 项和1303. 斐波那契前 n 项和 1234567891011121314151617181920212223n, m = map(int, input().split())f1 = [1, 1, 1]a = [[0, 1, 0], [1, 1, 1], [0, 0, 1]]def mul1(b, c): tmp = [0] * 3 for i in range(3): for j in range(3): tmp[i] = (tmp[i] + b[j] * c[j][i]) % m return tmpdef mul2(b, c): tmp = [[0] * 3 for _ in range(3)] for i in range(3): for j in range(3): for k in range(3): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % m return tmpn -= 1while n: if n &amp; 1: f1 = mul1(f1, a) a = mul2(a, a) n &gt;&gt;= 1print(f1[2]) 垒骰子1217. 垒骰子 123456789101112131415161718192021222324252627282930313233n, m = map(int, input().split())MOD = int(1e9) + 7op = [3, 4, 5, 0, 1, 2]f1 = [4, 4, 4, 4, 4, 4]d = [[4] * 6 for _ in range(6)]st = [[False] * 6 for _ in range(6)]for _ in range(m): a, b = map(lambda x: int(x) - 1, input().split()) st[a][b] = st[b][a] = Truefor i in range(6): for j in range(6): if st[j][op[i]]: d[j][i] = 0def mul1(b, c): tmp = [0] * 6 for i in range(6): for j in range(6): tmp[i] = (tmp[i] + b[j] * c[j][i]) % MOD return tmpdef mul2(b, c): tmp = [[0] * 6 for _ in range(6)] for i in range(6): for j in range(6): for k in range(6): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % MOD return tmpn -= 1while n: if n &amp; 1: f1 = mul1(f1, d) d = mul2(d, d) n &gt;&gt;= 1print(sum(f1) % MOD) 疑难杂题修改数组1242. 修改数组 123456789101112131415import syssys.setrecursionlimit(100000)n = int(input())nums = list(map(int, input().split()))p = [i for i in range(1100001)]res = []def find(x): if x != p[x]: p[x] = find(p[x]) return p[x]for num in nums: x = find(num) res.append(x) p[x] = x + 1print(*res) 倍数问题1234. 倍数问题 1234567891011121314n, K = map(int, input().split())nums = list(map(int, input().split()))dp = [[float(&#x27;-inf&#x27;)] * K for _ in range(4)]dp[0][0] = 0a = [[] for _ in range(K)]for num in nums: a[num % K].append(num)for i in range(K): tmp = sorted(a[i], reverse = True) for i in range(min(3, len(tmp))): for j in range(3, 0, -1): for k in range(K): dp[j][k] = max(dp[j][k], dp[j - 1][(k - tmp[i]) % K] + tmp[i])print(dp[3][0]) 组合数问题523. 组合数问题 12345678910111213141516171819202122t, k = map(int, input().split())c = [[0] * 2001 for _ in range(2001)]s = [[0] * 2001 for _ in range(2001)]for i in range(2001): for j in range(i + 1): if j == 0: c[i][j] = 1 else: c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % k if c[i][j] == 0: s[i][j] = 1for i in range(2001): for j in range(2001): if i: s[i][j] += s[i - 1][j] if j: s[i][j] += s[i][j - 1] if i and j: s[i][j] -= s[i - 1][j - 1]for _ in range(t): n, m = map(int, input().split()) print(s[n][m]) 模拟散列表840. 模拟散列表 1234567891011n = int(input())dicts = &#123;&#125;for _ in range(n): op, x = input().split() if op == &#x27;I&#x27;: dicts[x] = dicts.get(x, 0) + 1 elif op == &#x27;Q&#x27;: if dicts.get(x): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)","tags":["算法","Python","蓝桥杯"],"categories":["算法"]},{"title":"PAT 乙级","path":"/2024/01/29/pat乙级/","content":"PAT 乙级1001 害死人不偿命的(3n+1)猜想123456789n = int(input())num = 0while n != 1: if n % 2 == 0: n = n // 2 else: n = (3 * n + 1) // 2 num += 1print(num) 1002 写出这个数123456789n = input()res = 0for char in n: res += int(char)dicts = [&#x27;ling&#x27;, &#x27;yi&#x27;, &#x27;er&#x27;, &#x27;san&#x27;, &#x27;si&#x27;, &#x27;wu&#x27;, &#x27;liu&#x27;, &#x27;qi&#x27;, &#x27;ba&#x27;, &#x27;jiu&#x27;]ans = []for char in str(res): ans.append(dicts[int(char)])print(&#x27; &#x27;.join(map(str, ans))) 1003 我要通过！12345678910111213141516171819202122232425262728n = int(input())def check(arg): length = len(arg) idx = cnt1 = cnt2 = cnt3 = 0 while idx &lt; length and arg[idx] == &#x27;A&#x27;: cnt1 += 1 idx += 1 if idx &lt; length and arg[idx] == &#x27;P&#x27;: idx += 1 else: return False while idx &lt; length and arg[idx] == &#x27;A&#x27;: idx += 1 cnt2 += 1 if idx &lt; length and arg[idx] == &#x27;T&#x27;: idx += 1 else: return False while idx &lt; length and arg[idx] == &#x27;A&#x27;: idx += 1 cnt3 += 1 if idx == length and cnt1 * cnt2 == cnt3 and cnt2: return True else: return Falsefor _ in range(n): a = input() print(&#x27;YES&#x27; if check(a) else &#x27;NO&#x27;) 1004 成绩排名12345678n = int(input())students = []for i in range(n): name, number, grade = input().split() students.append([name, number, grade])students.sort(key=lambda x: int(x[2]))print(students[-1][0], students[-1][1])print(students[0][0], students[0][1]) 1005 继续(3n+1)猜想12345678910111213141516n = int(input())nums = list(map(int, input().split()))res = nums[:]def check(num): while num != 1: if num % 2 == 0: num = num // 2 else: num = (3 * num + 1) // 2 if num in res: res.remove(num) returnfor num in nums: check(num)res.sort(reverse=True)print(&#x27; &#x27;.join(map(str, res))) 1006 换个格式输出整数123n = &#x27;00&#x27; + input()res = &#x27;B&#x27; * int(n[-3]) + &#x27;S&#x27; * int(n[-2]) + &#x27;&#x27;.join([str(i) for i in range(1, int(n[-1]) + 1)])print(res) 1007 素数对猜想12345678910111213n = int(input())state = [True] * (n + 1)primes = []for i in range(2, n + 1): if state[i]: primes.append(i) for j in range(i * 2, n + 1, i): state[j] = Falseres = 0for i in range(len(primes) - 1): if primes[i + 1] - primes[i] == 2: res += 1print(res) 1008 数组元素循环右移问题1234n, m = map(int, input().split())nums = list(map(int, input().split()))nums = nums[n - m: ] + nums[: n - m]print(&#x27; &#x27;.join(map(str, nums))) 1009 说反话12s = list(input().split())print(&#x27; &#x27;.join(map(str, s[::-1]))) 1010 一元多项式求导12345678910nums = list(map(int, input().split()))res = []for i in range(0, len(nums), 2): a = nums[i] * nums[i + 1] b = nums[i + 1] - 1 if a: res.extend((a, b))if not res: res.extend((0, 0))print(&#x27; &#x27;.join(map(str, res))) 1011 A+B 和 C1234567t = int(input())for i in range(1, t + 1): a, b, c = map(int, input().split()) if a + b &gt; c: print(f&#x27;Case #&#123;i&#125;: true&#x27;) else: print(f&#x27;Case #&#123;i&#125;: false&#x27;) 1012 数字分类12345678910111213141516171819202122232425262728nums = list(map(int, input().split()))res1 = res2 = len2 = res3 = res4 = len4 = res5 = 0for num in nums[1: ]: if num % 10 == 0: res1 += num elif num % 5 == 1: res2 += (-1) ** (len2 % 2) * num len2 += 1 elif num % 5 == 2: res3 += 1 elif num % 5 == 3: res4 += num len4 += 1 elif num % 5 == 4: res5 = num if num &gt; res5 else res5if not res1: res1 = &#x27;N&#x27;if not len2: res2 = &#x27;N&#x27;if not res3: res3 = &#x27;N&#x27;if len4: res4 = round(res4 / len4, 1)else: res4 = &#x27;N&#x27;if not res5: res5 = &#x27;N&#x27;print(res1, res2, res3, res4, res5) 1013 数素数1234567891011m, n = map(int, input().split())state = [True] * 600000for i in range(2, int(600000**0.5) + 1): if state[i]: for j in range(i * i, 600000, i): state[j] = Falseprimes = [num for num in range(2, 600000) if state[num]]tmps = primes[m - 1: n]ress = [tmps[i:i+10] for i in range(0, len(tmps), 10)]for res in ress: print(&#x27; &#x27;.join(map(str, res))) 1014 福尔摩斯的约会1234567891011121314151617181920212223s1, s2, s3, s4 = input(), input(), input(), input()len1, len2 = min(len(s1), len(s2)), min(len(s3), len(s4))res = []DAY = &#123;&#x27;A&#x27;: &quot;MON&quot;, &#x27;B&#x27;: &quot;TUE&quot;, &#x27;C&#x27;: &quot;WED&quot;, &#x27;D&#x27;: &quot;THU&quot;, &#x27;E&#x27;: &quot;FRI&quot;, &#x27;F&#x27;: &quot;SAT&quot;, &#x27;G&#x27;: &quot;SUN&quot;&#125;for i in range(len1): if s1[i] == s2[i] and &#x27;A&#x27; &lt;= s1[i] &lt;= &#x27;G&#x27;: res.append(DAY[s1[i]]) breakfor j in range(i + 1, len1): if s1[j] == s2[j]: if &#x27;0&#x27; &lt;= s1[j] &lt;= &#x27;9&#x27;: res.append(&#x27;0&#x27; + s1[j]) break if &#x27;A&#x27; &lt;= s1[j] &lt;= &#x27;N&#x27;: res.append(str(ord(s1[j]) - 55)) breakfor i in range(len2): if s3[i] == s4[i] and (97 &lt;= ord(s3[i]) &lt;= 122 or 65 &lt;= ord(s3[i]) &lt;= 90): if i &lt; 10: res.append(&#x27;0&#x27; + str(i)) else: res.append(str(i))print(f&#x27;&#123;res[0]&#125; &#123;res[1]&#125;:&#123;res[2]&#125;&#x27;) 1015 德才论（部分通过）123456789101112131415161718192021222324252627from sys import stdininput = lambda: stdin.readline().strip()n, l, h = map(int, input().split())res1, res2, res3, res4 = [], [], [], []for _ in range(n): a, b, c = map(int, input().split()) if b &gt;= h and c &gt;= h: res1.append([a, b, c, b + c]) elif b &gt;= h and c &gt;= l: res2.append([a, b, c, b + c]) elif b &gt;= l and c &gt;= l and b &gt;= c: res3.append([a, b, c, b + c]) elif b &gt;= l and c &gt;= l: res4.append([a, b, c, b + c])print(len(res1) + len(res2) + len(res3) + len(res4))res1.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res2.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res3.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res4.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)for res in res1: print(&#x27; &#x27;.join(map(str, res[: -1])))for res in res2: print(&#x27; &#x27;.join(map(str, res[: -1])))for res in res3: print(&#x27; &#x27;.join(map(str, res[: -1])))for res in res4: print(&#x27; &#x27;.join(map(str, res[: -1]))) 1016 部分A+B1234A, Da, B, Db = input().split()Pa = Da * A.count(Da) if A.count(Da) else &#x27;0&#x27;Pb = Db * B.count(Db) if A.count(Da) else &#x27;0&#x27;print(int(Pa) + int(Pb)) 1017 A除以B12a, b = map(int, input().split())print(a // b, a % b) 1018 锤子剪刀布1234567891011121314151617181920212223242526272829303132n = int(input())a = b = c = 0jia, yi = [], []for _ in range(n): x, y = input().split() jia.append(x) yi.append(y) if x == y: c += 1 elif x == &#x27;C&#x27; and y == &#x27;J&#x27; or x == &#x27;J&#x27; and y == &#x27;B&#x27; or x == &#x27;B&#x27; and y == &#x27;C&#x27;: a += 1 jia.append(x) else: b += 1 yi.append(y)print(a, c, b)print(n - a - c, c, n - b - c)b1, c1, j1 = jia.count(&#x27;B&#x27;), jia.count(&#x27;C&#x27;), jia.count(&#x27;J&#x27;)b2, c2, j2 = yi.count(&#x27;B&#x27;), yi.count(&#x27;C&#x27;), yi.count(&#x27;J&#x27;)t1, t2 = max(b1, c1, j1), max(b2, c2, j2)if b1 == t1: print(&#x27;B&#x27;, end=&#x27; &#x27;)elif c1 == t1: print(&#x27;C&#x27;, end=&#x27; &#x27;)else: print(&#x27;J&#x27;, end=&#x27; &#x27;)if b2 == t2: print(&#x27;B&#x27;)elif c2 == t2: print(&#x27;C&#x27;)else: print(&#x27;J&#x27;) 1019 数字黑洞12345678910111213n = input()def fun(n): n = map(int, list(str(n).zfill(4))) b = list(map(str, sorted(n))) a = b[::-1] c = &#x27;&#x27;.join(a) d = &#x27;&#x27;.join(b) e = int(c) - int(d) e = str(e).zfill(4) print(f&#x27;&#123;c&#125; - &#123;d&#125; = &#123;e&#125;&#x27;) if e != &#x27;0000&#x27; and e != &#x27;6174&#x27;: fun(e)fun(n) 020 月饼12345678910111213N, D = map(int, input().split())stocks = list(map(float, input().split()))prices = list(map(float, input().split()))profits = [price / stock for stock, price in zip(stocks, prices)]yuebings = sorted(zip(stocks, prices, profits), key=lambda x: x[2], reverse=True)res = 0for stock, price, profit in yuebings: a = min(stock, D) res += a * profit D -= a if not D: breakprint(f&#x27;&#123;res:.2f&#125;&#x27;) 1021 个位数统计12345n = input()nums = &#x27;0123456789&#x27;for num in nums: if n.count(num): print(f&#x27;&#123;num&#125;:&#123;n.count(num)&#125;&#x27;) 1022 D进制的A+B12345678910a, b, d = map(int, input().split())c = a + bres = []while c: res.append(c % d) c //= dif res: print(&#x27;&#x27;.join(map(str, res[::-1])))else: print(0) 1023 组个最小数123456789nums = list(map(int, input().split()))res = &#x27;&#x27;for i in range(1, 10): if nums[i]: nums[i] -= 1 res = str(i) breaknums = [str(num) * nums[num] for num in range(10) if nums[num]]print(res + &#x27;&#x27;.join(map(str, nums))) 1024 科学计数法12345678910111213141516171819202122a = input()res = []if a[0] == &#x27;-&#x27;: res.append(&#x27;-&#x27;)e = a.find(&#x27;E&#x27;)exp = int(a[e+2:])if a[e + 1] == &#x27;+&#x27;: res.append(a[1]) if exp &gt;= e - 3: res.append(a[3: e]) res.append(&#x27;0&#x27; * (exp - e + 3)) else: res.append(a[3: 3 + exp]) res.append(&#x27;.&#x27;) res.append(a[3 + exp: e])elif a[e + 1] == &#x27;-&#x27;: res.append(&#x27;0.&#x27;) if exp &gt; 1: res.append(&#x27;0&#x27; * (exp - 1)) res.append(a[1]) res.append(a[3: e])print(&#x27;&#x27;.join(res)) 1025 反转链表1234567891011121314start, n, k = map(int, input().split())datas, nexts, lst = [0] * 100001, [0] * 100001, []for _ in range(n): a, b, c = map(int, input().split()) datas[a], nexts[a] = b, cwhile start != -1: lst.append(start) start = nexts[start]cnt = len(lst)for i in range(0, cnt - cnt % k, k): lst[i: i + k] = lst[i: i + k][::-1]for i in range(cnt - 1): print(f&#x27;&#123;lst[i]:05d&#125; &#123;datas[lst[i]]&#125; &#123;lst[i + 1]:05d&#125;&#x27;)print(f&#x27;&#123;lst[-1]:05d&#125; &#123;datas[lst[-1]]&#125; -1&#x27;) 1026 程序运行时间123456789101112c1, c2 = map(int, input().split())t = (c2 - c1 + 50) // 100res = []while t: if t % 60 &lt; 10: res.append(&#x27;0&#x27; + str(t % 60)) else: res.append(str(t % 60)) t //= 60while len(res) &lt; 3: res.append(&#x27;00&#x27;)print(&#x27;:&#x27;.join( res[::-1])) 1027 打印沙漏123456789101112131415n, symbol = input().split()shalous = []shalou = -1for i in range(30): shalou += 2 * (2 * i + 1) shalous.append(shalou)for i in range(30): if int(n) &lt; shalous[i]: breaka = 2 * (i - 1) + 1for j in range(a, 1, -2): print(&#x27; &#x27; * ((a - j) // 2) + symbol * j)for j in range(1, a + 1, 2): print(&#x27; &#x27; * ((a - j) // 2) + symbol * j)print(int(n) - shalous[i - 1]) 1028 人口普查（部分通过）1234567891011121314from sys import stdininput = lambda: stdin.readline().strip()n = int(input())nums = []for _ in range(n): name, birth = input().split() y, m, d = birth.split(&#x27;/&#x27;) if &#x27;18140906&#x27; &lt;= y + m + d &lt;= &#x27;20140906&#x27;: nums.append([name, int(y), int(m), int(d)])nums.sort(key=lambda x: (x[1], x[2], x[3]))if nums: print(len(nums), nums[0][0], nums[-1][0])else: print(0) 1029 旧键盘1234567891011a, b = input(), input()dicts = &#123;&#125;for char in b: dicts[char] = 1res = []for char in a: if not dicts.get(char, 0): if char.isalpha(): char = char.upper() res.append(char)print(&#x27;&#x27;.join(&#123;&#125;.fromkeys(res).keys())) 1030 完美数列123456789n, p = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, j = 1, 0for i in range(n): while j &lt; n and nums[j] &lt;= nums[i] * p: j += 1 res = max(res, j - i)print(res) 1031 查验身份证1234567891011121314151617181920n = int(input())dicts = [1, 0, &#x27;X&#x27;, 9, 8, 7, 6, 5, 4, 3, 2]weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]def check(id_card): check_num = 0 for i in range(17): if 48 &lt;= ord(id_card[i]) &lt;= 57: check_num += int(id_card[i]) * weights[i] else: return False check_num %= 11 return id_card[-1] == str(dicts[check_num])res = 0for _ in range(n): id_card = input() if not check(id_card): print(id_card) res += 1if not res: print(&#x27;All passed&#x27;) 1032 挖掘机技术哪家强123456n = int(input())nums = [-1] + [0] * 100000for _ in range(n): a, b = map(int, input().split()) nums[a] += bprint(nums.index(max(nums)), max(nums)) 1033 旧键盘打字123456789101112bad, string = list(input()), input()shift = Falsefor i in bad: if i == &#x27;+&#x27;: shift = True if 65 &lt;= ord(i) &lt;= 90: bad.append(i.lower())for i in string: if 65 &lt;= ord(i) &lt;= 90 and shift: continue if i not in bad: print(i, end=&#x27;&#x27;) 1034 有理数四则运算123456789101112131415161718192021222324252627282930313233343536373839404142import matha, b = input().split()def simplify(a): x, y = map(int, a.split(&#x27;/&#x27;)) return str(x // math.gcd(x, y)) + &#x27;/&#x27; + str(y // math.gcd(x, y))a, b = simplify(a), simplify(b)def calculate(a, b): x1, y1 = map(int, a.split(&#x27;/&#x27;)) x2, y2 = map(int, b.split(&#x27;/&#x27;)) t = str(x1 * y2 + x2 * y1) + &#x27;/&#x27; + str(y1 * y2) res.append(simplify(t)) t = str(x1 * y2 - x2 * y1) + &#x27;/&#x27; + str(y1 * y2) res.append(simplify(t)) t = str(x1 * x2) + &#x27;/&#x27; + str(y1 * y2) res.append(simplify(t)) if not x2: res.append(&#x27;1/0&#x27;) else: if x2 &lt; 0: x2, y2 = -x2, -y2 t = str(x1 * y2) + &#x27;/&#x27; + str(y1 * x2) res.append(simplify(t))res = []calculate(a, b)def simplify2(a): x, y = map(int, a.split(&#x27;/&#x27;)) if not y: return &#x27;Inf&#x27; ans = &#x27;&#x27; t = abs(x) // y if not x % y: ans = str(t) elif t: ans = str(t) + &#x27; &#x27; + str(abs(x - t * y * x // abs(x))) + &#x27;/&#x27; + str(y) else: ans = str(abs(x)) + &#x27;/&#x27; + str(y) return &#x27;(-&#x27; + ans + &#x27;)&#x27; if x &lt; 0 else ansa, b, res = simplify2(a), simplify2(b), [simplify2(i) for i in res]print(f&#x27;&#123;a&#125; + &#123;b&#125; = &#123;res[0]&#125;&#x27;)print(f&#x27;&#123;a&#125; - &#123;b&#125; = &#123;res[1]&#125;&#x27;)print(f&#x27;&#123;a&#125; * &#123;b&#125; = &#123;res[2]&#125;&#x27;)print(f&#x27;&#123;a&#125; / &#123;b&#125; = &#123;res[3]&#125;&#x27;) 1035 插入与归并123456789101112131415161718192021222324252627282930313233n = int(input())start = list(map(int, input().split()))mid = list(map(int, input().split()))for i in range(n - 1, -1, -1): if start[i] != mid[i]: breakif sorted(mid[:i + 1]) == mid[:i + 1]: print(&#x27;Insertion Sort&#x27;) a = start[i + 1] while a &gt; start[i]: i += 1 a = start[i + 1] for j in range(i + 1): if a &lt; mid[j]: print(&#x27; &#x27;.join(map(str, (mid[: j] + [a] + mid[j:i + 1] + mid[i+2:])))) breakelse: print(&#x27;Merge Sort&#x27;) i = 1 flag = True while i &lt; n and flag: i *= 2 for j in range(i, n, i): if sorted(mid[j-i: j]) != mid[j-i: j]: flag = False break if i &gt; j: mid.sort() else: for j in range(i, n, i): mid[j-i: j] = sorted(mid[j-i: j]) mid[j:] = sorted(mid[j:]) print(&#x27; &#x27;.join(map(str, mid))) 1036 跟奥巴马一起编程1234567n, c = input().split()n = int(n)row = int(n / 2 + 0.5) - 2print(c * n)for _ in range(row): print(c + &#x27; &#x27; * (n - 2) + c)print(c * n) 1037 在霍格沃茨找零钱12345678910111213p, a = input().split()g1, s1, k1 = map(int, p.split(&#x27;.&#x27;))g2, s2, k2 = map(int, a.split(&#x27;.&#x27;))t1 = (g1 * 17 + s1) * 29 + k1t2 = (g2 * 17 + s2) * 29 + k2t3 = abs(t2 - t1)k3 = t3 % 29s3 = t3 // 29 % 17g3 = (t3 // 29 - s3) // 17if t2 &gt;= t1: print(f&#x27;&#123;g3&#125;.&#123;s3&#125;.&#123;k3&#125;&#x27;)else: print(f&#x27;-&#123;g3&#125;.&#123;s3&#125;.&#123;k3&#125;&#x27;) 1038 统计同成绩学生12345678910n = int(input())nums = list(map(int, input().split()))checks = list(map(int, input().split()))scores = [0] * 101for num in nums: scores[num] += 1res = []for check in checks[1:]: res.append(scores[check])print(&#x27; &#x27;.join(map(str, res))) 1039 到底买不买123456789101112s, t = input(), input()a, dict1 = 0, &#123;&#125;for char in s: dict1[char] = dict1.get(char, 0) + 1for char in t: if dict1.get(char, 0): a += 1 dict1[char] -= 1if a == len(t): print(f&#x27;Yes &#123;len(s) - len(t)&#125;&#x27;)else: print(f&#x27;No &#123;len(t) - a&#125;&#x27;) 1040 有几个PAT123456789101112131415161718192021import bisects = input()p, a, pa, t = [], [], [], []for idx, char in enumerate(s): if char == &#x27;P&#x27;: p.append(idx) elif char == &#x27;A&#x27;: a.append(idx) elif char == &#x27;T&#x27;: t.append(idx)tmp = 0for i in a: x = bisect.bisect(p, i) tmp += x pa.append(tmp)res = 0for i in t: x = bisect.bisect(a, i) if x: res += pa[x-1]print(res % 1000000007) 1041 考试座位号123456789n = int(input())nums = [0] * 10001for _ in range(n): a, b, c = map(int, input().split()) nums[b] = (a, c)m = int(input())inqurie = map(int, input().split())for i in inqurie: print(nums[i][0], nums[i][1]) 1042 字符统计1234567891011from collections import Counters = input()t = []for char in s: if 65 &lt;= ord(char) &lt;= 90: char = char.lower() if 97 &lt;= ord(char) &lt;= 122: t.append(char)t.sort()t = Counter(t)print(t.most_common(1)[0][0], t.most_common(1)[0][1]) 1043 输出PATest1234567891011from collections import Counters = input()t = [char for char in s if char in &#x27;PATest&#x27;]counter = Counter(t)res = &#x27;&#x27;for _ in range(counter.most_common(1)[0][1]): for char in &#x27;PATest&#x27;: if counter[char]: counter[char] -= 1 res += charprint(res) 1044 火星数字12345678910111213141516171819202122232425n = int(input())units = [&#x27;tret&#x27;, &#x27;jan&#x27;, &#x27;feb&#x27;, &#x27;mar&#x27;, &#x27;apr&#x27;, &#x27;may&#x27;, &#x27;jun&#x27;, &#x27;jly&#x27;, &#x27;aug&#x27;, &#x27;sep&#x27;, &#x27;oct&#x27;, &#x27;nov&#x27;, &#x27;dec&#x27;]tens = [&#x27;tam&#x27;, &#x27;hel&#x27;, &#x27;maa&#x27;, &#x27;huh&#x27;, &#x27;tou&#x27;, &#x27;kes&#x27;, &#x27;hei&#x27;, &#x27;elo&#x27;, &#x27;syy&#x27;, &#x27;lok&#x27;, &#x27;mer&#x27;, &#x27;jou&#x27;]for _ in range(n): a = input() try: a = int(a) except ValueError: if len(a) &gt; 4: x, y = a.split() ten, unit = tens.index(x) + 1, units.index(y) print(ten * 13 + unit) else: if a in units: print(units.index(a)) else: print((tens.index(a) + 1) * 13) else: unit, ten = a % 13, a // 13 if ten &gt; 0 and unit &gt; 0: print(tens[ten - 1], units[unit]) elif ten &gt; 0: print(tens[ten - 1]) else: print(units[unit]) 1045 快速排序1234567891011121314151617n = int(input())nums = list(map(int, input().split()))lefts, rights, res = [], [], []left, right = 0, float(&#x27;inf&#x27;)for num in nums: if left &lt; num: left = num lefts.append(left)for num in nums[::-1]: if right &gt; num: right = num rights.append(right)for left, num, right in zip(lefts, nums, rights[::-1]): if left &lt;= num &lt;= right: res.append(num)print(len(res))print(&#x27; &#x27;.join(map(str, res))) 1046 划拳1234567891011n = int(input())a = b = 0for _ in range(n): x1, x2, y1, y2 = map(int, input().split()) if x2 == y2: continue if x1 + y1 == x2: b += 1 elif x1 + y1 == y2: a += 1print(a, b) 1047 编程团体赛12345678n = int(input())nums = [0] * 1001for _ in range(n): num, score = input().split() a, b = map(int, num.split(&#x27;-&#x27;)) nums[a] += int(score)res = max(nums)print(nums.index(res), res) 1048 数字加密1234567891011121314a, b = input().split()l = max(len(a), len(b))a = list(map(int, a[::-1])) + [0] * (l - len(a))b = list(map(int, b[::-1])) + [0] * (l - len(b))dicts = [&#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;]res = []for i in range(l): if i % 2 == 0: t = (a[i] + b[i]) % 13 res.append(dicts[t - 10] if t &gt;= 10 else t) else: res.append((b[i] - a[i] + 10) % 10)print(&#x27;&#x27;.join(map(str, res[::-1]))) 1049 数列的片段和（部分通过）12345678n = int(input())nums = list(map(float, input().split()))res, a = 0, 1for num in nums: res += num * a * n n -= 1 a += 1print(f&#x27;&#123;res:.2f&#125;&#x27;) 1050 螺旋矩阵123456789101112131415161718192021222324252627282930313233343536import mathN = int(input())nums = list(map(int, input().split()))nums.sort(reverse=True)m = n = 0for i in range(1, int(math.sqrt(N)) + 1): if N % i == 0: n, m = i, N // ires = [[0] * n for _ in range(m)]u, d, l, r = 0, m, 0, nidx = 0while True: res[u][l:r] = nums[idx: idx+r-l] u += 1 idx += r-l if u == d or l == r: break for i in range(u, d): res[i][r-1] = nums[idx] idx += 1 r -= 1 if u == d or l == r: break res[d-1][l:r] = nums[idx: idx+r-l][::-1] idx += r-l d -= 1 if u == d or l == r: break for i in range(d-1, u-1, -1): res[i][l] = nums[idx] idx += 1 l += 1 if u == d or l == r: breakfor row in res: print(&#x27; &#x27;.join(map(str, row))) 1051 复数乘法12345678910111213141516import mathr1, p1, r2, p2 = map(float, input().split())a1 = r1 * math.cos(p1)b1 = r1 * math.sin(p1)a2 = r2 * math.cos(p2)b2 = r2 * math.sin(p2)a3 = a1*a2-b1*b2 b3 = a1*b2+a2*b1if abs(a3) &lt; 0.005: a3 = 0if abs(b3) &lt; 0.005: print(f&#x27;&#123;a3:.2f&#125;+0.00i&#x27;)elif b3 &gt; 0: print(f&#x27;&#123;a3:.2f&#125;+&#123;b3:.2f&#125;i&#x27;)else: print(f&#x27;&#123;a3:.2f&#125;&#123;b3:.2f&#125;i&#x27;) 1052 卖个萌1看不懂题 1053 住房空置率1234567891011n, e, d = map(float, input().split())maybe_vacant = vacant = 0for _ in range(int(n)): nums = list(map(float, input().split())) t = sum(1 for i in nums[1:] if i &lt; e) if t / nums[0] &gt; 0.5: if nums[0] &gt; d: vacant += 1 else: maybe_vacant += 1print(f&#x27;&#123;maybe_vacant / n * 100:.1f&#125;% &#123;vacant / n * 100:.1f&#125;%&#x27;)","tags":["算法","PAT","Python"],"categories":["算法"]},{"title":"算法基础课","path":"/2024/01/29/算法基础课/","content":"算法基础课基础算法快速排序785. 快速排序 12345678910111213141516171819202122n = int(input())nums = list(map(int, input().split()))def quick_sort(l, r): if l &gt;= r: return i, j = l - 1, r + 1 x = nums[l + r &gt;&gt; 1] while i &lt; j: while True: i += 1 if nums[i] &gt;= x: break while True: j -= 1 if nums[j] &lt;= x: break if i &lt; j: nums[i], nums[j] = nums[j], nums[i] quick_sort(l, j) quick_sort(j + 1, r)quick_sort(0, n - 1)print(*nums) 786. 第k个数 12345678910111213141516171819202122232425n, k = map(int, input().split())nums = list(map(int, input().split()))def quick_select(l, r, k): if l &gt;= r: return nums[l] x = nums[(l + r) // 2] i, j = l - 1, j + 1 while i &lt; j: while True: i += 1 if nums[i] &lt;= x: break while True: j -= 1 if nums[j] &gt;= x: break if i &lt; j: nums[i], nums[j] = nums[j], nums[i] sl = j - l + 1 if k &lt;= sl: return quick_select(l, j, k) else: return quick_select(j + 1, r, k - sl) print(quick_select(0, n - 1, k)) 归并排序787. 归并排序 1234567891011121314151617181920212223n = int(input())nums = [int(x) for x in input().split()]def merge_sort(nums, l, r): if l &gt;= r: return mid = (l + r) // 2 merge_sort(nums, l, mid) merge_sort(nums, mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt;= nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp merge_sort(nums, 0, n - 1)print(&#x27; &#x27;.join(list(map(str, nums)))) 788. 逆序对的数量 1234567891011121314151617181920212223n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l &gt;= r: return 0 mid = l + r &gt;&gt; 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i &lt;= mid and j &lt;= r: if nums[i] &lt;= nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) 二分789. 数的范围 123456789101112131415161718192021222324n, q = map(int, input().split())nums = [int(x) for x in input().split()]while q &gt; 0: q -= 1 x = int(input()) l, r = 0, n - 1 while l &lt; r: mid = (l + r) // 2 if nums[mid] &gt;= x: r = mid else: l = mid + 1 if nums[l] != x: print(&#x27;-1 -1&#x27;) continue left = l l, r = 0, n - 1 while l &lt; r: mid = (l + r + 1) // 2 if nums[mid] &lt;= x: l = mid else: r = mid - 1 print(f&#x27;&#123;left&#125; &#123;l&#125;&#x27;) 790. 数的三次方根 123456789n = float(input())l, r = -100, 100while abs(l - r) &gt; 1e-8: mid = (l + r) / 2 if mid ** 3 &gt; n: r = mid else: l = midprint(f&#x27;&#123;l:.6f&#125;&#x27;) 前缀和795. 前缀和 12345678n, m = map(int, input().split())nums = [int(x) for x in input().split()]sums = [0] * (n + 1)for i in range(n): sums[i + 1] = sums[i] + nums[i]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l - 1]) 796. 子矩阵的和 12345678910111213n, m, q = map(int, input().split())nums = [[0] * (m + 1) for _ in range(n + 1)]sums = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:]for i in range(1, n + 1): for j in range(1, m + 1): sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1 - 1][y2] - sums[x2][y1 - 1] + sums[x1 - 1][y1 - 1]) 差分797. 差分 1234567891011121314n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diffs = [0] * (n + 2)def insert(l, r, c): diffs[l] += c diffs[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diffs[i] print(nums[i], end=&#x27; &#x27;) 798. 差分矩阵 123456789101112131415161718192021n, m, q = map(int, input().split())nums = [[0] * (m + 2) for _ in range(n + 2)]diffs = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diffs[x1][y1] += c diffs[x1][y2 + 1] -= c diffs[x2 + 1][y1] -= c diffs[x2 + 1][y2 + 1] += cfor i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:] for j in range(1, m + 1): insert(i, j, i, j, tmps[j - 1])for _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diffs[i][j] print(nums[i][j], end=&#x27; &#x27;) print() 双指针799. 最长连续不重复子序列 1234567891011n = int(input())nums = list(map(int, input().split()))dic = dict.fromkeys(nums, 0)j = res = 0for i in range(n): dic[nums[i]] += 1 while dic[nums[i]] &gt; 1: dic[nums[j]] -= 1 j += 1 res = max(res, i - j + 1)print(res) 800. 数组元素的目标和 12345678910n, m, x = map(int, input().split())a = list(map(int, input().split()))b = list(map(int, input().split()))j = m - 1for i in range(n): while j and a[i] + b[j] &gt; x: j -= 1 if a[i] + b[j] == x: print(i, j) break 二进制801. 二进制中1的个数 1234567891011n = int(input())nums = list(map(int, input().split()))def lowbit(x): return x &amp; -xfor num in nums: res = 0 while num: num -= lowbit(num) res += 1 print(res, end=&#x27; &#x27;) 离散化802. 区间和 12345678910111213141516171819202122232425262728293031323334353637n, m = map(int, input().split())# adds = [list(map(int, input().split())) for _ in range(n)]# querys = [list(map(int, input().split())) for _ in range(m)]# indexs = [add[0] for add in adds]# for l, r in querys:# indexs += [l, r]adds, querys, indexs = [], [], []for i in range(n): x, c = map(int, input().split()) adds.append([x, c]) indexs.append(x)for i in range(m): l, r = map(int, input().split()) querys.append([l, r]) indexs.append(l) indexs.append(r)indexs.sort()indexs = list(set(indexs))n = len(indexs)def find(x): l, r = 0, n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if indexs[mid] &gt;= x: r = mid else: l = mid + 1 return l + 1nums = [0] * (n + 1)sums = [0] * (n + 1)for x, c in adds: nums[find(x)] += cfor i in range(1, n + 1): sums[i] = sums[i - 1] + nums[i]for l, r in querys: print(sums[find(r)] - sums[find(l) - 1]) 区间合并803. 区间合并 12345678910111213n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key=lambda x: x[0])st, ed = float(&#x27;-inf&#x27;), float(&#x27;-inf&#x27;)res = 0for l, r in nums: if ed &lt; l: res += 1 st = l ed = r else: ed = max(ed, r)print(res) 数据结构单链表826. 单链表 1234567891011121314151617181920212223242526272829303132333435363738def insert_head(x): global head, idx e[idx] = x ne[idx] = head head = idx idx += 1 def insert(k, x): global idx e[idx] = x ne[idx] = ne[k] ne[k] = idx idx += 1 def remove(k): ne[k] = ne[ne[k]] N = 100010e, ne = [0] * N, [0] * Nhead, idx = -1, 0n = int(input())for _ in range(n): ops = input().split() if ops[0] == &#x27;H&#x27;: insert_head(int(ops[1])) elif ops[0] == &#x27;I&#x27;: insert(int(ops[1]) - 1, int(ops[2])) else: k = int(ops[1]) if not k: head = ne[head] remove(k - 1)i = headres = []while i != -1: res.append(e[i]) i = ne[i]print(&#x27; &#x27;.join(map(str, res))) 双链表827. 双链表 123456789101112131415161718192021222324252627282930313233N = 100010e, l, r = [0] * N, [0] * N, [0] * Nr[0], l[1], idx = 1, 0, 2def insert(k, x): global idx e[idx] = x r[idx] = r[k] l[idx] = k l[r[k]] = idx r[k] = idx idx += 1def remove(k): r[l[k]] = r[k] l[r[k]] = l[k]n = int(input())for _ in range(n): ops = input().split() if ops[0] == &#x27;L&#x27;: insert(0, int(ops[1])) elif ops[0] == &#x27;R&#x27;: insert(l[1], int(ops[1])) elif ops[0] == &#x27;IL&#x27;: insert(l[int(ops[1]) + 1], int(ops[2])) elif ops[0] == &#x27;IR&#x27;: insert(int(ops[1]) + 1, int(ops[2])) else: remove(int(ops[1]) + 1)i = r[0]res = []while i != 1: res.append(e[i]) i = r[i]print(&#x27; &#x27;.join(map(str, res))) 栈828. 模拟栈 123456789101112n = int(input())stack = []for _ in range(n): ops = input().split() if ops[0] == &#x27;push&#x27;: stack.append(ops[1]) elif ops[0] == &#x27;pop&#x27;: stack.pop() elif ops[0] == &#x27;query&#x27;: print(stack[-1]) elif ops[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if stack else &#x27;YES&#x27;) 3302. 表达式求值 12345678910111213141516171819202122232425262728293031323334353637383940dic = &#123;&#x27;(&#x27;: 0, &#x27;+&#x27;: 1, &#x27;-&#x27;: 1, &#x27;*&#x27;: 2, &#x27;/&#x27;: 2&#125;ops, nums = [], []def new_eval(): b = nums.pop() a = nums.pop() o = ops.pop() if o == &#x27;+&#x27;: nums.append(a + b) elif o == &#x27;-&#x27;: nums.append(a - b) elif o == &#x27;*&#x27;: nums.append(a * b) elif o == &#x27;/&#x27;: nums.append(int(a / b))a = input()n = len(a)i = 0while i &lt; n: c = a[i] if c.isdigit(): j, x = i, 0 while j &lt; n and a[j].isdigit(): x = x * 10 + int(a[j]) j += 1 i = j - 1 nums.append(x) elif c == &#x27;(&#x27;: ops.append(c) elif c == &#x27;)&#x27;: while ops[-1] != &#x27;(&#x27;: new_eval() ops.pop() else: while ops and dic[ops[-1]] &gt;= dic[c]: new_eval() ops.append(c) i += 1while ops: new_eval()print(nums[-1]) 队列829. 模拟队列 12345678910111213import collectionsn = int(input())queue = collections.deque()for _ in range(n): ops = input().split() if ops[0] == &#x27;push&#x27;: queue.append(ops[1]) elif ops[0] == &#x27;pop&#x27;: queue.popleft() elif ops[0] == &#x27;query&#x27;: print(queue[0]) elif ops[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if queue else &#x27;YES&#x27;) 单调栈830. 单调栈 12345678910111213141516n = int(input())nums = list(map(int, input().split()))stack, res = [], []for num in nums: if not stack: stack.append(num) res.append(-1) continue while stack and num &lt;= stack[-1]: stack.pop() if not stack: res.append(-1) else: res.append(stack[-1]) stack.append(num)print(&#x27; &#x27;.join(map(str, res))) 单调队列154. 滑动窗口 1234567891011121314151617181920212223242526n, k = map(int, input().split())nums = list(map(int, input().split()))q = [0] * 1000010hh, tt = 0, -1res1, res2 = [], []for i in range(n): if hh &lt;= tt and i - k + 1 &gt; q[hh]: hh += 1 while hh &lt;= tt and nums[q[tt]] &gt; nums[i]: tt -= 1 tt += 1 q[tt] = i if i &gt;= k - 1: res1.append(nums[q[hh]])hh, tt = 0, -1for i in range(n): if hh &lt;= tt and i - k + 1 &gt; q[hh]: hh += 1 while hh &lt;= tt and nums[q[tt]] &lt; nums[i]: tt -= 1 tt += 1 q[tt] = i if i &gt;= k - 1: res2.append(nums[q[hh]])print(&#x27; &#x27;.join(map(str, res1)))print(&#x27; &#x27;.join(map(str, res2))) KMP831. KMP字符串 1234567891011121314151617181920212223n = int(input())p = &#x27; &#x27; + input()m = int(input())s = &#x27; &#x27; + input()ne = [0] * 1000010j = 0for i in range(2, n + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = jj = 0res = []for i in range(1, m + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == n: res.append(i - j) j = ne[j]print(&#x27; &#x27;.join(map(str, res))) Trie835. Trie字符串统计 1234567891011121314151617181920212223242526272829N = 10010tries = [[0] * 26 for _ in range(N)]cnt = [0] * Nidx = 1def insert(string): global idx p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: tries[p][t] = idx idx += 1 p = tries[p][t] cnt[p] += 1def query(string): p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: return 0 p = tries[p][t] return cnt[p]n = int(input())for _ in range(n): op, string = input().split() if op == &#x27;I&#x27;: insert(string) elif op == &#x27;Q&#x27;: print(query(string)) 143. 最大异或对 1234567891011121314151617181920212223242526272829303132N = 100010M = 31 * Ntries = [[0] * 2 for _ in range(M)]n = int(input())nums = list(map(int, input().split()))idx, res = 0, 0def insert(x): global idx p = 0 for i in range(32)[::-1]: u = x &gt;&gt; i &amp; 1 if not tries[p][u]: idx += 1 tries[p][u] = idx p = tries[p][u]def query(x): p, res = 0, 0 for i in range(32)[::-1]: u = x &gt;&gt; i &amp; 1 if tries[p][u^1]: res = res * 2 + u^1 p = tries[p][u^1] else: res = res * 2 + u p = tries[p][u] return resfor num in nums: insert(num) t = query(num) res = max(res, t^num)print(res) 并查集836. 合并集合 12345678910111213141516n, m = map(int, input().split())p = [i for i in range(n + 1)]def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): op, a, b = input().split() a, b = int(a), int(b) if op == &#x27;M&#x27;: p[find(a)] = find(b) elif op == &#x27;Q&#x27;: if find(a) == find(b): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) 837. 连通块中点的数量 1234567891011121314151617181920212223n, m = map(int, input().split())p = [i for i in range(n + 1)]size = [1] * (n + 1)def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): ops = input().split() if ops[0] == &#x27;C&#x27;: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): continue size[find(b)] += size[find(a)] p[find(a)] = find(b) elif ops[0] == &#x27;Q1&#x27;: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) elif ops[0] == &#x27;Q2&#x27;: print(size[find(int(ops[1]))]) 240. 食物链 1234567891011121314151617181920212223242526272829n, m = map(int, input().split())p, d = [i for i in range(n + 1)], [0] * (n + 1)res = 0def find(x): if p[x] != x: t = find(p[x]) d[x] += d[p[x]] p[x] = t return p[x]for _ in range(m): op, x, y = map(int, input().split()) if x &gt; n or y &gt; n: res += 1 continue px, py = find(x), find(y) diff = (d[x] - d[y]) % 3 if op == 1: if px == py and diff: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] elif op == 2: if px == py and diff != 1: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] + 1print(res) 堆838. 堆排序 123456789101112131415161718n, m = map(int, input().split())heap = [0] + list(map(int, input().split()))def down(k): t = k if 2 * k &lt;= n and heap[2 * k] &lt; heap[t]: t = 2 * k if 2 * k + 1 &lt;= n and heap[2 * k + 1] &lt; heap[t]: t = 2 * k + 1 if t != k: heap[t], heap[k] = heap[k], heap[t] down(t)for i in range(int(n / 2), -1, -1): down(i)for _ in range(m): print(heap[1], end=&#x27; &#x27;) heap[1] = heap[n] n -= 1 down(1) 839. 模拟堆 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647N = 100010heap, ph, hp = [0] * N, [0] * N, [0] * Nsize, idx = 0, 0n = int(input())def swap(a, b): ph[hp[a]], ph[hp[b]] = b, a hp[a], hp[b] = hp[b], hp[a] heap[a], heap[b] = heap[b], heap[a]def down(k): t = k if 2 * k &lt;= size and heap[2 * k] &lt; heap[t]: t = 2 * k if 2 * k + 1 &lt;= size and heap[2 * k + 1] &lt; heap[t]: t = 2 * k + 1 if t != k: swap(t, k) down(t)def up(k): while k // 2 and heap[k // 2] &gt; heap[k]: swap(k // 2, k) k //= 2for _ in range(n): ops = input().split() if ops[0] == &#x27;I&#x27;: size += 1 idx += 1 heap[size] = int(ops[1]) ph[idx] = size hp[size] = idx up(size) elif ops[0] == &#x27;PM&#x27;: print(heap[1]) elif ops[0] == &#x27;DM&#x27;: swap(1, size) size -= 1 down(1) elif ops[0] == &#x27;D&#x27;: k = ph[int(ops[1])] swap(k, size) size -= 1 down(k) up(k) elif ops[0] == &#x27;C&#x27;: k, x = ph[int(ops[1])], int(ops[2]) heap[k] = x down(k) up(k) 哈希表840. 模拟散列表 拉链法 12345678910111213141516171819202122232425262728N = 100003h, e, ne = [-1] * N, [0] * N, [0] * Nn = int(input())idx = 0def insert(x): global idx k = x % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1def find(x): k = x % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return Falsefor _ in range(n): op, x = input().split() if op == &#x27;I&#x27;: insert(int(x)) elif op == &#x27;Q&#x27;: if find(int(x)): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) 开放寻址法 123456789101112131415161718192021N = 200003null = 0x3f3f3f3fh = [null] * Nn = int(input())def find(x): k = x % N while h[k] != null and h[k] != x: k += 1 if k == N: k = 0 return kfor _ in range(n): op, x = input().split() k = find(int(x)) if op == &#x27;I&#x27;: h[k] = int(x) elif op == &#x27;Q&#x27;: if h[k] == int(x): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) python 自带 123456789from collections import defaultdictdic = defaultdict(int)n = int(input())for _ in range(n): op, x = input().split() if op == &#x27;I&#x27;: dic[x] += 1 elif op == &#x27;Q&#x27;: print(&#x27;Yes&#x27; if dic[x] else &#x27;No&#x27;) 841. 字符串哈希 123456789101112131415n, m = map(int, input().split())s = input()Q, P = 1 &lt;&lt; 64, 131h, p = [0] * (n + 1), [1] * (n + 1)def get(l, r): return (h[r] - h[l - 1] * p[r - l + 1]) % Qfor i in range(1, n + 1): h[i] = (h[i - 1] * P + ord(s[i - 1])) % Q p[i] = (p[i - 1] * P) % Qfor _ in range(m): l1, r1, l2, r2 = map(int, input().split()) if get(l1, r1) == get(l2, r2): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) 搜索与图论DFS842. 排列数字 dfs 做法 1234567891011121314n = int(input())path = [0] * nst = [False] * (n + 1)def dfs(x): if x == n: print(&#x27; &#x27;.join(map(str, path))) return for i in range(1, n + 1): if not st[i]: path[x] = i st[i] = True dfs(x + 1) st[i] = Falsedfs(0) python permutation方法 12345import itertoolsn = int(input())nums = [i for i in range(1, n + 1)]for res in itertools.permutations(nums, n): print(&#x27; &#x27;.join(map(str, res))) 843. n-皇后问题 全排列 1234567891011121314151617n = int(input())g = [[&#x27;.&#x27; for _ in range(n)] for _ in range(n)]col, dg, udg = [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x): if x == n: for i in range(n): print(&#x27;&#x27;.join(map(str, g[i]))) print() return for y in range(n): if not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = &#x27;Q&#x27; col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x + 1) g[x][y] = &#x27;.&#x27; col[y] = dg[x + y] = udg[n - x + y] = 0dfs(0) 原始暴力枚举 123456789101112131415161718192021n = int(input())g = [[&#x27;.&#x27; for _ in range(n)] for _ in range(n)]row, col, dg, udg = [0] * n, [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x, y, s): if y == n: y = 0 x += 1 if x == n: if s == n: for i in range(n): print(&#x27;&#x27;.join(map(str, g[i]))) print() return if not row[x] and not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = &#x27;Q&#x27; row[x] = col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x, y + 1, s + 1) g[x][y] = &#x27;.&#x27; row[x] = col[y] = dg[x + y] = udg[n - x + y] = 0 dfs(x, y + 1, s)dfs(0, 0, 0) BFS844. 走迷宫 12345678910111213141516171819202122from collections import dequen, m = map(int, input().split())g = [list(map(int, input().split())) for _ in range(n)]path = [[-1] * m for _ in range(n)]prev = [[0] * m for _ in range(n)]q = deque()q.append((0, 0))path[0][0] = 0while q: a, b = q.popleft() for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): x = a + l y = b + r if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and not g[x][y] and path[x][y] == -1: q.append((x, y)) path[x][y] = path[a][b] + 1 prev[x][y] = (a, b)print(path[-1][-1])x, y = n - 1, m - 1while x &gt; 0 or y &gt; 0: x,y = prev[x][y] print(x,y) 845. 八数码 1234567891011121314151617181920212223242526from collections import dequestart = &#x27;&#x27;.join(input().split())queue = deque([start])d = &#123;start: 0&#125;target = &#x27;12345678x&#x27;def swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 &lt; idx2 else(idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:]def bfs(): while queue: t = queue.popleft() distance = d[t] if t == target: return distance idx = t.find(&#x27;x&#x27;) x, y = idx // 3, idx % 3 for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): a, b = x + l, y + r if 0 &lt;= a &lt; 3 and 0 &lt;= b &lt; 3: t = swap(t, a * 3 + b, idx) if t not in d: d[t] = distance + 1 queue.append(t) t = swap(t, a * 3 + b, idx) return -1print(bfs()) 树与图的深度优先遍历846. 树的重心 用链表作为邻接表 12345678910111213141516171819202122232425262728293031n = int(input())h, e, ne = [-1] * (n + 1), [0] * (2 * n), [0] * (2 * n)state = [False] * (n + 1)idx, ans = 0, ndef add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxdef dfs(u): global ans state[u] = True size, res = 1, 0 cur = h[u] while cur != -1: j = e[cur] if not state[j]: s = dfs(j) res = max(res, s) size += s cur = ne[cur] res = max(res, n - size) ans = min(ans, res) return sizefor _ in range(n - 1): a, b = map(int, input().split()) add(a, b) add(b, a)dfs(1)print(ans) 使用python的list[list] 12345678910111213141516171819202122n = int(input())adj_list = [[] for _ in range(n + 1)]state = [False] * (n + 1)ans = nfor _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u): global ans state[u] = True size, res = 1, 0 for j in adj_list[u]: if not state[j]: s = dfs(j) res = max(res, s) size += s res = max(res, n - size) ans = min(ans, res) return sizedfs(1)print(ans) 树与图的广度优先遍历847. 图中点的层次 12345678910111213141516171819202122232425262728293031from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)dist = [-1] * (n + 1)queue = deque([1])dist[1] = 0idx = 0def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b)def bfs(): while queue: node = queue.popleft() d = dist[node] if node == n: return d cur = h[node] while cur != -1: j = e[cur] if dist[j] == -1: queue.append(j) dist[j] = d + 1 cur = ne[cur] return -1print(bfs()) 使用python的list[list] 1234567891011121314151617181920from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]d = [0] * (n + 1)queue = deque([1])for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def bfs(): while queue: cur = queue.popleft() distance = d[cur] if cur == n: return distance for j in adj_list[cur]: if not d[j]: d[j] = distance + 1 queue.append(j) return -1print(bfs()) 拓扑排序848. 有向图的拓扑序列 123456789101112131415161718192021222324252627282930313233343536from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)d = [0] * (n + 1)idx = 0queue = deque()def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b) d[b] += 1def topsort(): for i in range(1, n + 1): if not d[i]: queue.append(i) res = [] while queue: node = queue.popleft() res.append(node) t = h[node] while t != -1: j = e[t] d[j] -= 1 if d[j] == 0: queue.append(j) t = ne[t] if len(res) == n: print(&#x27; &#x27;.join(map(str, res))) else: print(&#x27;-1&#x27;)topsort() 使用python的list[list] 123456789101112131415161718192021222324from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]in_degree = [0] * (n + 1)queue = deque()for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) in_degree[b] += 1for i in range(1, n + 1): if not in_degree[i]: queue.append(i)res = []while queue: node = queue.popleft() res.append(node) for j in adj_list[node]: in_degree[j] -= 1 if not in_degree[j]: queue.append(j)if len(res) == n: print(&#x27; &#x27;.join(map(str, res)))else: print(-1) Dijkstra849. Dijkstra求最短路 I 12345678910111213141516n, m = map(int, input().split())g = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)]dist = [float(&#x27;inf&#x27;)] * (n + 1)state = [False] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)def dijkstra(): for _ in range(1, n + 1): t = min((j for j in range(1, n + 1) if not state[j]), key=lambda j: dist[j]) state[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], dist[t] + g[t][j]) print(dist[n] if dist[n] != float(&#x27;inf&#x27;) else -1)dijkstra() 850. Dijkstra求最短路 II 123456789101112131415161718192021import heapqn, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(&#x27;inf&#x27;)] * (n + 1)dist[1] = 0heap = []heapq.heappush(heap, (0, 1))s = set()for _ in range(m): x, y, z = map(int, input().split()) adj_list[x].append((y, z))while heap: d, node = heapq.heappop(heap) if node in s: continue s.add(node) for neighbor, weight in adj_list[node]: if dist[neighbor] &gt; dist[node] + weight: dist[neighbor] = dist[node] + weight heapq.heappush(heap, (dist[neighbor], neightbor))print(dist[n] if dist[n] != float(&#x27;inf&#x27;) else -1) bellman-ford853. 有边数限制的最短路 123456789101112n, m, k = map(int, input().split())e = []dist = [float(&#x27;inf&#x27;)] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) e.append((a, b, c))for _ in range(k): backup = dist.copy() for a, b, w in e: dist[b] = min(dist[b], backup[a] + w)print(dist[n] if dist[n] != float(&#x27;inf&#x27;) else &#x27;impossible&#x27;) spfa851. spfa求最短路 123456789101112131415161718192021from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(&#x27;inf&#x27;)] * (n + 1)state = [False] * (n + 1)queue = deque([1])dist[1] = 0state[1] = Truefor _ in range(m): a, b, w = map(int, input().split()) adj_list[a].append((b, w))while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] &gt; dist[cur] + weight: dist[neighbor] = dist[cur] + weight if not state[neighbor]: queue.append(neighbor) state[neighbor] = Trueprint(dist[n] if dist[n] != float(&#x27;inf&#x27;) else &#x27;impossible&#x27;) 852. spfa判断负环 123456789101112131415161718192021222324from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist, cnt = [0] * (n + 1), [0] * (n + 1)state = [True] * (n + 1)queue = deque([i for i in range(1, n + 1)])for _ in range(m): a, b, c = map(int, input().split()) adj_list[a].append((b, c))def spfa(): while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] &gt; dist[cur] + weight: dist[neighbor] = dist[cur] + weight cnt[neighbor] = cnt[cur] + 1 if cnt[neighbor] &gt;= n: return True if not state[neighbor]: queue.append(neighbor) state[neighbor] = True return Falseprint(&#x27;Yes&#x27; if spfa() else &#x27;No&#x27;) Floyd854. Floyd求最短路 1234567891011121314n, m, q = map(int, input().split())g = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): g[i][i] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = min(g[i][j], g[i][k] + g[k][j])for _ in range(q): a, b = map(int, input().split()) print(g[a][b] if g[a][b] != float(&#x27;inf&#x27;) else &#x27;impossible&#x27;) Prim858. Prim算法求最小生成树 123456789101112131415161718192021n, m = map(int, input().split())g = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)]state = [False] * (n + 1)dist = [float(&#x27;inf&#x27;)] * (n + 1)for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c) g[b][a] = g[a][b]def prim(): res = 0 for i in range(n): t = min((j for j in range(1, n + 1) if not state[j]), key = lambda x: dist[x]) if i and dist[t] == float(&#x27;inf&#x27;): return &#x27;impossible&#x27; if i: res += dist[t] for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) state[t] = True return resprint(prim()) Krustal859. Kruskal算法求最小生成树 12345678910111213141516171819n, m = map(int, input().split())e = []p = [i for i in range(n + 1)]res, cnt = 0, 0def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m):\ta, b, c = map(int, input().split())\te.append((a, b, c))e.sort(key=lambda x: x[2])for a, b, c in e: a, b = find(a), find(b) if a != b: p[a] = b res += c cnt += 1print(res if cnt == n - 1 else &#x27;impossible&#x27;) 染色法判定二分图860. 染色法判定二分图 dfs会爆栈 1234567891011121314151617181920212223n, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, c): color[u] = c for neighbor in adj_list[u]: if not color[neighbor]: if not dfs(neighbor, c * -1): return False elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not colort[i]: if not dfs(i, 1): print(&#x27;No&#x27;) breakelse: print(&#x27;Yes&#x27;) bfs 123456789101112131415161718192021222324252627from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def bfs(u): queue = deque() queue.append((u, 1)) while queue: node, c = queue.popleft() color[node] = c for neighbor in adj_list[node]: if not color[neighbor]: queue.append((neighbor, c * -1)) elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not color[i]: if not bfs(i): print(&#x27;No&#x27;) breakelse: print(&#x27;Yes&#x27;) 匈牙利算法861. 二分图的最大匹配 1234567891011121314151617181920n1, n2, m = map(int, input().split())n = max(n1, n2)adj_list = [[] for _ in range(n + 1)]match = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def find(u): for neighbor in adj_list[u]: if not state[neighbor]: state[neighbor] = True if not match[neighbor] or find(match[neighbor]): match[neighbor] = u return True return Falseres = 0for i in range(1, n1 + 1): state = [0] * (n + 1) if find(i): res += 1print(res) 数学知识质数866. 试除法判定质数 12345678910import mathn = int(input())def prime(x): if x &lt; 2: return False for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: return False return Truefor _ in range(n): x = int(input()) print(&#x27;Yes&#x27; if prime(x) else &#x27;No&#x27;) 867. 分解质因数 123456789101112131415import mathn = int(input())def divid(x): for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: s = 0 while x % i == 0: x //= i s += 1 print(i, s) if x &gt; 1: print(x, 1)for _ in range(n): x = int(input()) divid(x) print() 868. 筛质数 线性筛法–每个合数只能被自己的最小质因数删除O(n) 12345678910111213n = int(input())state = [True] * (n + 1)res = []for i in range(2, n + 1): if state[i]: res.append(i) j = 0 while res[j] * i &lt;= n: state[res[j] * i] = False if i % res[j] == 0: break j += 1print(len(res)) 埃氏筛法O(n lognlogn) 123456789n = int(input())state = [True] * (n + 1)res = 0for i in range(2, n + 1): if state[i]: res += 1 for j in range(2 * i, n + 1, i): state[j] = Falseprint(res) 约数869. 试除法求约数 1234567891011121314import mathn = int(input())def divisor(x): res = [] for i in range(1, int(math.sqrt(x) + 1)): if x % i == 0: res.append(i) if i * i != x: res.append(x // i) res.sort() print(&#x27; &#x27;.join(map(str, res)))for _ in range(n): a = int(input()) divisor(a) 870. 约数个数 $N &#x3D; p^{\\alpha1}{1} * p^{\\alpha2}{2} * \\cdots * p^{\\alpha k}_{k}$ 约数个数$res &#x3D; (a_{1} + 1) (a_{2} + 1) \\cdots (a_{k} + 1)$ 1234567891011121314151617import mathn = int(input())dict = &#123;&#125;def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x &gt; 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for v in dict.values(): res = res * (v + 1) % (1e9 + 7)print(int(res)) 871. 约数之和 约数之和$res &#x3D; (p^{0}{1} + p^{1}{1} + \\cdots p^{a_{1}}{1}) * (p^{0}{2} + p^{1}{2} + \\cdots p^{a{2}}{2}) * \\cdots *(p^{0}{k} + p^{1}{k} + \\cdots p^{a{k}}_{k})$ 12345678910111213141516171819202122import mathn = int(input())dict = &#123;&#125;MOD = int(1e9 + 7)def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x &gt; 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for p, a in dict.items(): t = 1 while a: t = (t * p + 1) % MOD a -= 1 res = res * t % MODprint(res) 872. 最大公约数 辗转相除法 123456n = int(input())def gcd(a, b): return gcd(b, a % b) if b else afor _ in range(n): a, b = map(int, input().split()) print(gcd(a, b)) python自带 12345import mathn = int(input())for _ in range(n): a, b = map(int, input().split()) print(math.gcd(a, b)) 欧拉函数873. 欧拉函数 $\\varphi(1) &#x3D; 1$ 当n不是质数：$\\varphi(n) &#x3D; n * \\sum^{x}{i&#x3D;1}(1 - \\frac{1}{p{k}})$ 当n是质数：$\\varphi(n) &#x3D; n - 1$ 123456789101112131415import mathn = int(input())def euler(x): res = x for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x &gt; 1: res *= (1 - 1 / x) print(int(res))for _ in range(n): x = int(input()) euler(x) 874. 筛法求欧拉函数 1234567891011121314151617181920n = int(input())state = [False] * (n + 1)phi = [0] * (n + 1)phi[1] = 1primes = []def euler(x): for i in range(2, n + 1): if not state[i]: primes.append(i) phi[i] = i - 1 j = 0 while primes[j] * i &lt;= n: state[primes[j] * i] = True if i % primes[j] == 0: phi[primes[j] * i] = phi[i] * primes[j] break phi[primes[j] * i] = phi[i] * (primes[j] - 1) j += 1 print(sum(phi))euler(n) 快速幂875. 快速幂 费马小定理$a^{p - 1} \\equiv 1 \\ (mod \\enspace p)$ 123456789n = int(input())for _ in range(n): a, k, p = map(int, input().split()) res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p print(res) 876. 快速幂求逆元 当n为质数时，b的乘法逆元$x &#x3D; b^{(n - 2)}$ 当n不是质数时，使用拓展欧几里得求逆元 $a * x \\equiv 1 \\ (mod \\ p)$ 1234567891011n = int(input())def quick_mi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resfor _ in range(n): a, p = map(int, input().split()) print(quick_mi(a, p - 2, p) if a % p else &#x27;impossible&#x27;) 扩展欧几里得算法877. 扩展欧几里得算法 求解$ax + by &#x3D; gcd(a, b)$ 当b&#x3D;0时 $ax+by&#x3D;a$ 故而 $x&#x3D;1, y&#x3D;0$ 当$b eq 0$时$x &#x3D; y \\prime, \\quad y &#x3D; x \\prime - \\lfloor\\frac{a}{b}\\rfloor * y \\prime$ 12345678910n = int(input())def exgcd(a, b): if not b: return 1, 0 y, x = exgcd(b, a % b) y -= a // b * x return x, yfor _ in range(n): a, b = map(int, input().split()) print(*exgcd(a, b)) 878. 线性同余方程 当$gcd(a,m) \\mid b$有解，求出以一组解使得$a * x_{0} + m * y_{0} &#x3D; gcd(a,m)$， 所以$x &#x3D; x_{0} * \\frac{b}{gcd(a,m)} % m$ 1234567891011n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(n): a, b, m = map(int, input().split()) d, x, _ = exgcd(a, m) print(&#x27;impossible&#x27; if b % d else x * b // d % m) 中国剩余定理$M&#x3D;m_{1} \\cdot m_{2} \\cdot \\cdots \\cdot m_{R}, \\quad M_{i} &#x3D; \\frac{M}{m_{i}}$, $M^{-1}{i}$表示$M_i$模$m{i}$的逆，即$M_i \\cdot m^{-1}{i} \\equiv 1 \\ (mod \\ m{i})$ $x &#x3D; a_1 \\cdot M_1 \\cdot M^{-1}{1} + a_2 \\cdot M_2 \\cdot M^{-1}{2} + \\cdots + a_k \\cdot M_k \\cdot M^{-1}_{k}$ 204. 表达整数的奇怪方式 注 $m_1,m_2 \\cdots m_k$ 不两两互质 1234567891011121314151617181920n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ya1, m1 = map(int, input().split())for _ in range(n - 1): a2, m2 = map(int, input().split()) d, k1, _ = exgcd(a1, a2) if (m2 - m1) % d: print(-1) break k1 *= (m2 - m1) // d k1 %= a2 // d m1 += a1 * k1 a1 = a1 * a2 // delse: print(m1 % a1) 高斯消元883. 高斯消元解线性方程组 1234567891011121314151617181920212223242526272829n = int(input())g = [list(map(float, input().split())) for _ in range(n)]def gauss(): idx, zero = 0, 1e-6 for c in range(n): t = max(range(c, n), key=lambda x: abs(g[x][c])) if abs(g[t][c]) &lt; zero: continue g[idx][c:], g[t][c:] = g[t][c:], g[idx][c:] for i in range(n, c, -1): g[idx][i] /= g[idx][c] for i in range(idx + 1, n): if abs(g[i][c]) &gt; zero: for j in range(n, c - 1, -1): g[i][j] -= g[idx][j] * g[i][c] idx += 1 if idx &lt; n: for i in range(idx, n): if abs(g[i][n]) &gt; zero: print(&#x27;No solution&#x27;) return print(&#x27;Infinite group solutions&#x27;) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] -= g[i][j] * g[j][n] for i in range(n): print(f&#x27;&#123;g[i][n]:.2f&#125;&#x27;)gauss() 884. 高斯消元解异或线性方程组 12345678910111213141516171819202122232425262728293031n = int(input())g = [list(map(int, input().split())) for _ in range(n)]def gauss(): idx = 0 for c in range(n): t = idx for i in range(idx, n): if g[i][c]: t = i break if not g[t][c]: continue g[t][c:], g[idx][c:] = g[idx][c:], g[t][c:] for i in range(idx + 1, n): if g[i][c]: for j in range(c, n + 1): g[i][j] ^= g[idx][j] idx += 1 if idx &lt; n: for i in range(idx, n): if g[i][n]: print(&#x27;No solution&#x27;) return print(&#x27;Multiple sets of solutions&#x27;) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] ^= g[i][j] &amp; g[j][n] for i in range(n): print(g[i][n])gauss() 求组合数885. 求组合数 I $C^{b}{a} &#x3D; C^{b - 1}{a - 1} + C^{b}_{a - 1}$ 123456789n = int(input())N, MOD = 2010, int(1e9+7)g = [[1] + [0] * N for _ in range(N)]for i in range(N): for j in range(i + 1): g[i][j] = (g[i - 1][j] + g[i - 1][j - 1]) % MODfor _ in range(n): a, b = map(int, input().split()) print(g[a][b]) 886. 求组合数 II 注 $\\frac{a}{b} \\enspace mod \\enspace p eq \\frac{a \\enspace mod \\enspace p}{b \\enspace mod \\enspace p}$ 可以用逆元计算 $\\frac{a}{b} \\enspace mod \\enspace p &#x3D; a \\times b^{-1} \\enspace mod \\enspace p$ $C^{b}_{a} &#x3D; \\frac{a!}{b! * (a - b)!} &#x3D; a! * infact(b!) * infact((a - b)!)$ 1234567891011121314151617n = int(input())N, MOD = 100010, int(1e9 + 7)fact, infact = [1] * N, [1] * Ndef qmi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resfor i in range(1, N): fact[i] = fact[i - 1] * i % MOD infact[i] = infact[i - 1] * qmi(i, MOD - 2, MOD) % MODfor _ in range(n): a, b = map(int, input().split()) print(fact[a] * infact[b] * infact[a - b] % MOD) 887. 求组合数 III 卢卡斯定理 Lucas $O(logpNplogp)$ $C^{b}{a} \\equiv C^{\\frac{b}{p}}{\\frac{a}{p}} C^{b \\ mod \\ p}_{a \\ mod \\ p} \\ (mod \\ p)$ 1234567891011121314151617181920212223242526n = int(input())def qmi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resdef C(a, b): res = 1 i, j = 1, a while i &lt;= b: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1 return resdef lucas(a, b, p): if a &lt; p and b &lt; p: return C(a, b) else: return C(a % p, b % p) * lucas(a // p, b // p, p) % pfor _ in range(n): a, b, p = map(int, input().split()) print(lucas(a, b, p)) 888. 求组合数 IV 123import matha, b = map(int, input().split())print(math.factorial(a) // math.factorial(b) // math.factorial(a - b)) 889. 满足条件的01序列 卡特兰数 $ans &#x3D; C^{n}{2n} - C^{n - 1}{2n} &#x3D; \\frac{C^{n}_{2n}}{n + 1}$ 123456789101112131415161718n = int(input())p = int(1e9 + 7)def qmi(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k &gt;&gt;= 1 a = a * a % p return resres = 1i, j = 1, 2 * nwhile i &lt;= n: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1print(res * qmi(n + 1, p - 2, p) % p) 使用公式+python硬解(很慢） 123import mathn = int(input())print(math.factorial(2 * n) // (math.factorial(n) ** 2 * (n + 1)) % int(1e9 + 7)) 容斥原理$$\\bigcup_{i&#x3D;1}^{m} S_{i}&#x3D;S_{1}+S_{2}+\\cdots+S_{m}-(S_{1} \\bigcap S_{2}+S_{1} \\bigcap S_{3}+\\ldots+S_{m-1} \\bigcap S_{m})+(S_{1} \\bigcap S_{2} \\bigcap S_{3}+\\ldots+S_{m-2} \\bigcap S_{m-1} \\bigcap S_{m})+\\ldots+(-1)^{m-1}(\\bigcap_{i&#x3D;1}^{m} S)$$ 890. 能被整除的数 123456789101112131415n, m = map(int, input().split())p = list(map(int, input().split()))res = 0for i in range(1, 1 &lt;&lt; m): t, s = 1, 0 for j in range(m): if i &gt;&gt; j &amp; 1: if t * p[j] &gt; n: break t *= p[j] s += 1 else: if s &amp; 1: res += n // t else: res -= n // tprint(res) 博弈论891. Nim游戏 mex(S)为求出不属于集合S的最小非负整数 123456n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(1, n): res ^= nums[i]print(&#x27;Yes&#x27; if res else &#x27;No&#x27;) 892. 台阶-Nim游戏 123456n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(2, n, 2): res ^= nums[i]print(&#x27;Yes&#x27; if res else &#x27;No&#x27;) 893. 集合-Nim游戏 $SG(x)&#x3D;mex({SG(y_{1}),SG(y_{2})····SG(y_{k})})$ $SG(G)&#x3D;SG(G_{1})\\oplus SG(G_{2}) \\oplus \\cdots \\oplus SG(G_{m})$ 1234567891011121314151617181920k = int(input())s = list(map(int, input().split()))n = int(input())nums = list(map(int, input().split()))f = [-1] * 10010def sg(x): if f[x] != -1: return f[x] S = &#123;sg(x - i) for i in s if x &gt;= i&#125; i = 0 while i in S: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(&#x27;Yes&#x27; if nim(n, nums) else &#x27;No&#x27;) 894. 拆分-Nim游戏 123456789101112131415161718192021n = int(input())nums = list(map(int, input().split()))f = [-1] * 101def sg(x): if f[x] != -1: return f[x] s = set() for i in range(x): for j in range(i + 1): s.add(sg(i) ^ sg(j)) i = 0 while i in s: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(&#x27;Yes&#x27; if nim(n, nums) else &#x27;No&#x27;) 动态规划背包问题2. 01背包问题 二维dp 12345678910111213n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j &gt;= v[i]: f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])print(f[n][m]) 一维dp 1234567891011n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 3. 完全背包问题 二维dp 12345678910111213n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j &gt;= v[i]: f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])print(f[n][m]) 一维dp 123456789101112n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): if j &gt;= v[i]: f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 4. 多重背包问题 I 12345678910111213141516n, m = map(int, input().split())v, w, s = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b, c = map(int, input().split()) v[i] = a w[i] = b s[i] = cfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] k = 0 while k &lt;= s[i] and j &gt;= k * v[i]: f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) k += 1print(f[n][m]) 5. 多重背包问题 II 123456789101112131415161718192021n, m = map(int, input().split())N = 20010v, w, f = [0] * (N + 1), [0] * (N + 1), [0] * (N + 1)idx = 1for _ in range(n): a, b, c = map(int, input().split()) k = 1 while k &lt; c: v[idx] = a * k w[idx] = b * k c -= k k *= 2 idx += 1 if c: v[idx] = a * c w[idx] = b * c idx += 1for i in range(1, idx): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 9. 分组背包问题 123456789101112131415n, m = map(int, input().split())N = 101v = [[0] * N for _ in range(N)]w = [[0] * N for _ in range(N)]s, f = [0] * N, [0] * Nfor i in range(1, n + 1): s[i] = int(input()) for j in range(1, s[i] + 1): v[i][j], w[i][j] = map(int, input().split())for i in range(1, n + 1): for j in range(m, 0, -1): for k in range(1, s[i] + 1): if j &gt;= v[i][k]: f[j] = max(f[j], f[j - v[i][k]] + w[i][k])print(f[m]) 线性DP898. 数字三角形 1234567891011n = int(input())INF = -1e9a = [[INF] * (n + 1) for _ in range(n + 1)]f = [[INF] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): a[i] = [INF] + list(map(int, input().split()))f[1][1] = a[1][1]for i in range(2, n + 1): for j in range(1, i + 1): f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]print(max(f[n])) 895. 最长上升子序列 12345678n = int(input())a = [0] + list(map(int, input().split()))f = [1] * (n + 1)for i in range(1, n + 1): for j in range(1, i): if a[i] &gt; a[j]: f[i] = max(f[i], f[j] + 1)print(max(f)) 897. 最长公共子序列 123456789n, m = map(int, input().split())a, b = &#x27; &#x27; + input(), &#x27; &#x27; + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = max(f[i - 1][j], f[i][j - 1]) if a[i] == b[j]: f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)print(f[n][m]) 902. 最短编辑距离 12345678910111213141516n = int(input())a = &#x27; &#x27; + input()m = int(input())b = &#x27; &#x27; + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): f[i][0] = ifor i in range(1, m + 1): f[0][i] = ifor i in range(1, n + 1): for j in range(1, m + 1): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1print(f[n][m]) 899. 编辑距离 123456789101112131415161718192021222324252627n, m = map(int, input().split())N = 11a = [[0] * N for _ in range(n + 1)]f = [[0] * N for _ in range(N)]for i in range(n): a[i] = &#x27; &#x27; + input()def distance(a, b): la, lb = len(a), len(b) for i in range(1, la): f[i][0] = i for i in range(1, lb): f[0][i] = i for i in range(1, la): for j in range(1, lb): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1 return f[la - 1][lb - 1]for _ in range(m): b, limit = input().split() b, limit = &#x27; &#x27; + b, int(limit) res = 0 for i in range(n): if distance(a[i], b) &lt;= limit: res += 1 print(res) 896. 最长上升子序列 II 123456789101112131415n = int(input())a = list(map(int, input().split()))q = [0] * (n + 1)res = 0for i in range(n): l, r = 0, res while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if q[mid] &lt; a[i]: l = mid else: r = mid - 1 q[r + 1] = a[i] res = max(res, r + 1)print(res) 区间DP282. 石子合并 123456789101112n = int(input())s = [0] + list(map(int, input().split()))f = [[0] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): s[i] += s[i - 1]for length in range(2, n + 1): for i in range(1, n - length + 2): l, r = i, i + length - 1 f[l][r] = float(&#x27;inf&#x27;) for k in range(l, r): f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1])print(f[1][n]) 计数类DP900. 整数划分 12345678n = int(input())MOD = int(1e9 + 7)f = [0] * (n + 1)f[0] = 1for i in range(1, n + 1): for j in range(i, n + 1): f[j] = (f[j] + f[j - i]) % MODprint(f[n]) 数位统计DP338. 计数问题 12345678910111213141516171819202122232425262728293031323334def power10(x): res = 1 while x: res *= 10 x -= 1 return resdef count(n, x): res = cnt = 0 m = n while m: cnt += 1 m //= 10 for i in range(1, cnt + 1): r = power10(i - 1) l = n // (r * 10) if x: res += l * r else: res += (l - 1) * r d = n // r % 10 if d == x: res += n % r + 1 elif d &gt; x: res += r return reswhile True: a, b = map(int, input().split()) if not a and not b: break if a &gt; b: a, b = b, a for i in range(10): print(count(b, i) - count(a - 1, i), end=&#x27; &#x27;) print() 状态压缩DP291. 蒙德里安的梦想 1234567891011121314151617181920212223def fun(n, m): f = [[0] * (1 &lt;&lt; 12) for _ in range(12)] st = [False] * (1 &lt;&lt; 12) for i in range(1 &lt;&lt; n): cnt = 0 st[i] = True for j in range(n): if i &gt;&gt; j &amp; 1: if cnt &amp; 1: st[i] = False cnt = 0 else: cnt += 1 if cnt &amp; 1: st[i] = False f[0][0] = 1 for i in range(1, m + 1): for j in range(1 &lt;&lt; n): for k in range(1 &lt;&lt; n): if not (j &amp; k) and st[j | k]: f[i][j] += f[i - 1][k] return f[m][0]while True: a, b = map(int, input().split()) if not a and not b: break print(fun(a, b)) 91. 最短Hamilton路径 1234567891011n = int(input())g = [list(map(int, input().split())) for _ in range(n)]f = [[float(&#x27;inf&#x27;)] * n for _ in range(1 &lt;&lt; n)]f[1][0] = 0for i in range(1 &lt;&lt; n): for j in range(n): if i &gt;&gt; j &amp; 1: for k in range(n): if i &gt;&gt; k &amp; 1: f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + g[k][j])print(f[i - (1 &lt;&lt; n)][n - 1]) 树形DP285. 没有上司的舞会 123456789101112131415161718192021222324import syssys.setrecursionlimit(3000)n = int(input())f = [[0] * 2 for _ in range(n + 1)]parent = [False] * (n + 1)happy = [0] * (n + 1)adj_list = [[] for _ in range(n + 1)]for i in range(1, n + 1): happy[i] = int(input())for _ in range(n - 1): a, b = map(int, input().split()) parent[a] = True adj_list[b].append(a)root = 1while parent[root]: root += 1def dfs(u): f[u][1] = happy[u] for j in adj_list[u]: dfs(j) f[u][0] += max(f[j][1], f[j][0]) f[u][1] += f[j][0]dfs(root)print(max(f[root][0], f[root][1])) 记忆化搜索901. 滑雪 123456789101112131415161718n, m = map(int, input().split())f = [[0] * m for _ in range(n)]g = [list(map(int, input().split())) for _ in range(n)]dircts = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dp(x, y): if f[x][y]: return f[x][y] f[x][y] = 1 for l, r in dircts: a, b = x + l, b + r if 0 &lt;= a &lt; n and 0 &lt;= b &lt; m and g[a][b] &lt; g[x][y]: f[x][y] = max(f[x][y], dp(a, b) + 1) return f[x][y]res = 0for i in range(n): for j in range(m): res = max(res, dp(i, j))print(res) 贪心区间问题905. 区间选点 123456789n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x:x[1])res, end = 0, float(&#x27;-inf&#x27;)for a, b in g: if a &gt; end: res += 1 end = bprint(res) 908. 最大不相交区间数量 123456789n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[1])res, end = 0, float(&#x27;-inf&#x27;)for a, b in g: if a &gt; end: res += 1 end = bprint(res) 906. 区间分组 12345678910import heapqn = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()res = []for a, b in g: if res and a &gt; res[0]: heapq.heappop(res) heapq.heappush(res, b)print(len(res)) 907. 区间覆盖 12345678910111213141516171819s, t = map(int, input().split())n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()idx = res = 0flag = Falsewhile idx &lt; n: r = float(&#x27;-inf&#x27;) while idx &lt; n and g[idx][0] &lt;= s: r = max(r, g[idx][1]) idx += 1 if r &lt; s: break s = r res += 1 if r &gt;= t: flag = True breakprint(res if flag else &#x27;-1&#x27;) Huffman树148. 合并果子 12345678910import heapqn = int(input())nums = list(map(int, input().split()))heapq.heapify(nums)res = 0while len(nums) &gt; 1: a, b = heapq.heappop(nums), heapq.heappop(nums) res += a + b heapq.heappush(nums, a + b)print(res) 排序不等式913. 排队打水 1234567n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for i, num in enumerate(nums): res += num * (n - i - 1)print(res) 绝对值不等式104. 货仓选址 1234567n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for num in nums: res += abs(num - nums[n // 2])print(res) 推公式125. 耍杂技的牛 12345678n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[0] + x[1])res, pre_sum = float(&#x27;-inf&#x27;), 0for w, s in g: res = max(res, pre_sum - s) pre_sum += wprint(res) Python注意容易爆栈12import sys sys.setrecursionlimit(100000) ​ python语言并不适合递归算法，因为其递归深度，语言自身就有限制，就算去除限制，其也会开辟大量空间 交换str两个字符的位置123def swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 &lt; idx2 else (idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:] 增强函数记忆力123import functools#lru_cache，可以为函数自动增加记忆化的能力，在递归算法中非常实用@functools.lru_cache() 科学计数法要用int12# 默认的科学计数法是小数表示MOD = int(1e9 + 7) 取模%运算c++中 1234cout&lt;&lt; 7 % 4 &lt;&lt; endl; // 3cout&lt;&lt; -7 % 4 &lt;&lt; endl; // -3cout&lt;&lt; 7 % -4 &lt;&lt; endl; // 3cout&lt;&lt; -7 % -4 &lt;&lt; endl; // -3 python中 1234print(7 % 4) // 3print(-7 % 4) // 1print(7 % -4) // -1print(-7 % -4) // -3 C 语言和 Python 在涉及有负数取余运算时，结果可能不同的本质原因是：C 语言中是向0取整，而 Python 是向负无穷取整。 输入123from sys import stdininput = lambda: stdin.readline().strip()n, m = map(int, input().split()) 常用函数123import mathmath.factorial(x)math.gcd(a, b) 二分二分找左边界l=mid+1,找右边界r=mid-1，并且mid=l+r+1&gt;&gt;1","tags":["算法","Python","AcWing"],"categories":["算法"]},{"title":"labuladong算法小抄","path":"/2023/05/17/labuladong算法小抄/","content":"第零章 核心框架双指针-&gt;单链表 合并两个有序链表 LeetCode21 合并两个有序链表 链表的分解 LeetCode86 分割链表 合并k个有序链表 LeetCode23 合并k个升序链表 寻找单链表的倒数第k个节点 LeetCode19 删除链表倒数第N个节点 寻找单链表的中点 LeetCode976 链表的中间结点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 LeetCode160 相交链表 双指针-&gt;数组快慢指针 原地修改数组 LeetCode26 删除有序数组中的重复项 对数组某些元素进行原地删除 LeetCode27 移除元素 LeetCode283 移动零 左右指针 二分查找 二分查找框架 两数之和 LeetCode167 两数之和2 反转数组 LeetCode344 反转字符串 回文串判断 LeetCode5 最长回文子串 二叉树(纲要篇)Tips:快速排序就是二叉树的前序遍历,归并排序是二叉树的后序遍历 快速排序框架: 1234567def sort(nums, lo, hi)&#123; # 前序遍历位置 # 通过交换元素构建分界点 p p = partition(nums, lo, hi) sort(nums, lo, p-1) sort(nums, p+1, hi)&#125; 归并排序框架: 123456789def sort(nums, lo, hi)&#123;\tint mid = (lo + hi) / 2\t# 排序nums[lo..mid]\tsort(nums, lo, mid)\t# 排序nums[mid+1..hi]\tsort(nums, mid+1, hi)\t# 合并nums[lo..mid] 和 nums[mid+1..hi]\tmerge(nums, lo, mid, hi)&#125; 二叉树遍历框架:12345678def traverse(root)&#123;\tif not root: return\t# 前序位置\ttraverse(root.left)\t# 中序位置\ttraverse(root.right)\t# 后序位置&#125; 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据 两种解题思路: 遍历一遍二叉树得出答案 回溯算法框架 LeetCode104 二叉树的最大深度 分解问题计算出答案 动态规划核心框架 后序位置的特殊之处:​ LeetCode543 二叉树的直径 层序遍历:123456789101112131415def levelTraverse(root)&#123;\tif not root: return\tque = deque()\tque.append(root) # 从上到下遍历二叉树的每一层\twhile que: # 从左到右遍历每一层的每个结点 for i in range(len(que)): cur = que.popleft() # 将下一层结点放入队列 if cur.left: que.append(cur.left) if cur.right: que.append(cur.right)&#125; ​ BFS算法框架 动态规划(框架)动态规划框架:1234567891011121314# 自顶向下递归的动态规划def dp(状态1, 状态2, ...):\tfor 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...))\treturn result# 自底向上迭代的动态规划# 初始化 base casedp[0][0][...] = base case# 进行状态转移for 状态1 in 状态1的所有取值: for 状态2 in 状态2的所有取值: for ... dp[状态1][状态2][...] = 求最值(选择1, 选择2...) 解题思路:暴力穷举,带备忘录的递归和dp数组的迭代(可降空间复杂度为O(1)) 斐波那契数列 LeetCode509 斐波那契数列 凑零钱 LeetCode322 零钱兑换 总结计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举， 穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。 列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。 备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？ 回溯算法(框架)Tips:回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 回溯算法框架123456789res = []def backtrack(路径, 选择列表):\tif 满足结束条件: res.add(路径) return\tfor 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销xrz 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」 全排列问题 LeetCode46 全排列 全排列详解 N皇后问题 LeetCode51 N皇后 总结 时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。 回溯-&gt;排列,组合,子集无论是排列、组合还是子集问题，简单说无非就是让你从序列 nums 中以给定规则取若干元素，主要有以下几种变体： 元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。 ​ 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该只有 [7]。 元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次。 ​ 以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。 元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次。 ​ 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]。 ​\t但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽。 ​\t回溯算法核心 子集(元素无重不可复选) LeetCode78 子集 组合(元素无重不可复选) LeetCode77 组合 排列(元素无重不可复选) LeetCode46 全排列 子集&#x2F;组合(元素可重不可复选) LeetCode 子集2 LeetCode 组合总和2 排列(元素可重不可复选) 全排列2 子集&#x2F;组合(元素无重可复选) LeetCode39 组合总和 排列(元素无重可复选) 总结 元素无重复不可复选 12345678910111213141516171819202122232425# 组合/子集问题回溯算法框架def backtrack(nums, start)&#123;\tfor i in range(start, len(nums))&#123; # 做选择 tarck.addLast(nums[i]) # 注意参数 backtrack(nums, i+1) # 撤销选择 track.removeLast()\t&#125;&#125;# 排列问题回溯算法框架def backtrack(nums)&#123; for i in range(len(nums))&#123; # 剪枝逻辑 if used[i]: continue # 做选择 used[i] = true track.addLast(nums[i]) backtrack(nums) # 撤销选择 track.removeLast() used[i] = false &#125;&#125; 元素可重不可复选 123456789101112131415161718192021222324252627282930313233nums.sort()# 组合/子集问题回溯算法框架def backtrack(nums, start)&#123; # 回溯算法标准框架 for i in range(start, len(nums))&#123; # 剪枝逻辑,跳过相同的相邻树枝 if i&gt;start and nums[i]==nums[i-1]: continue # 做选择 track.addLast(nums[i]) # 注意参数 backtrack(nums, i+1) # 撤销选择 track.removeLast() &#125;&#125;nums.sort()# 排列问题回溯算法框架def backtrack(nums)&#123; for i in range(len(nums))&#123; # 剪枝逻辑 if used[i]:continue # 剪枝逻辑,固定相同的元素在排列中的相对位置 if i&gt;0 and nums[i]==nums[i-1] and not used[i-1]: continue # 做选择 used[i] = true track.addLast(nums[i]) backtrack(nums) #撤销选择 track.removeLast() used[i] = false &#125;&#125; 元素无重可复选 12345678910111213141516171819202122# 组合/子集问题回溯框架def backtrack(nums, start)&#123; # 回溯算法标准框架\tfor i in range(start, len(nums))&#123; # 做选择 track.addLast(nums[i]) # 注意参数 backtrack(nums, i) # 撤销选择 track.removeLase()\t&#125;&#125;# 排列问题回溯算法框架def backtrack(nums)&#123;\tfor i in range(len(nums))&#123; # 做选择 track.addLast(nums[i]) backtrack(nums) # 撤销选择 track.removeLast() &#125;&#125; BFS(框架) BFS框架: 层序遍历 二叉树的最小高度 LeetCode111 二叉树的最小高度 解开密码锁的最少次数 LeetCode752 打开转盘锁 双向BFS优化 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。 二分搜索 寻找一个数(基本的二分搜索) LeetCode704 二分查找 1234567891011121314def binarySearch(nums, target)&#123;\tleft, right = 0, len(nums)-1\twhile(left&lt;=right): mid = left+(right-left)//2 if(nums[mid]==target): # 直接返回 return mid elif nums[mid]&gt;target: right = mid-1 elif nums[mid]&lt;target: left = mid+1 # 直接返回\treturn -1&#125; 寻找左侧边界的二分搜索 1234567891011121314151617181920def left_bound(nums, target)&#123; left, right = 0, len(nums)-1 # 搜索区间为[left, right] while left&lt;=right: mid = left + (right-left)//2 if nums[mid]==target: # 收缩右侧边界 right = mid+1 elif nums[mid]&lt;target: # 搜索区间变为[mid+1, right] left = mid+1 elif nums[mid]&gt;target: # 搜索区间变为[left, mid-1] right = mid # 判断target是否存在于nums中 # 此时target比所有数都大,返回-1 if left==len(nums): return -1 # 判断一下nums[left]是不是target return nums[left]==target ? left : -1&#125; 寻找右侧边界的二分查找 123456789101112131415def right_bound(nums, target)&#123; left, right = 0, len(nums)-1 while left&lt;=right: mid = left+(right-left)//2 if nums[mid]&lt;target: left=mid+1 elif nums[mid]&gt;target: right = mid-1 elif nums[mid]==target: # 收缩左边界 left = mid+1 # 最后改成返回left-1 if left-1 &lt; 0: return -1 return nums[left-1]==target ? left-1 :-1&#125; 总结: ​\tLeetCode34 在排序数组中查找元素的第一个和最后一个位置 最基本的二分查找算法 1234567因为我们初始化 right = nums.length - 1所以决定了我们的「搜索区间」是 [left, right]所以决定了 while (left &lt;= right)同时也决定了 left = mid+1 和 right = mid-1因为我们只需找到一个 target 的索引即可所以当 nums[mid] == target 时可以立即返回 寻找左侧边界的二分查找 12345678因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left &lt; right)同时也决定了 left = mid + 1 和 right = mid因为我们需找到 target 的最左侧索引所以当 nums[mid] == target 时不要立即返回而要收紧右侧边界以锁定左侧边界 寻找右侧边界的二分查找 1234567891011因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left &lt; right)同时也决定了 left = mid + 1 和 right = mid因为我们需找到 target 的最右侧索引所以当 nums[mid] == target 时不要立即返回而要收紧左侧边界以锁定右侧边界又因为收紧左侧边界时必须 left = mid + 1所以最后无论返回 left 还是 right，必须减一 滑动窗口 滑动窗口框架 123456789101112131415161718left, right = 0,0while right&lt;len(s): # c是将移入窗口的字符 window.add(s[right]) # 增大窗口 right += 1 # 进行窗口内数据的一系列更新 ... # debug输出的位置 printf(&quot;Window:[%d, %d] &quot;, left, right) # 判断左侧窗口是否要收缩 while window needs shrink: # d是将移出窗口的字符 char d = s[left] # 缩小窗口 left+=1 # 进行窗口内数据的一系列更新 ... 最小覆盖子串 LeetCode76 最小覆盖子串 字符串排列 LeetCode567 字符串的排列 找所有字母异位词 LeetCode438 找到字符串中所有字母异位词 最长无重复子串 LeetCode3 无重复字符的最长子串 总结: 1. 什么时候应该扩大窗口? 1. 什么时候应该缩小窗口? 1. 什么时候应该更新答案? 买股票(DP) 状态转移方程 1234567base case：dp[-1][...][0] = dp[...][0][0] = 0dp[-1][...][1] = dp[...][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) base case 12345678910111213dp[-1][...][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。dp[-1][...][1] = -infinity解释：还没开始的时候，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。dp[...][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。dp[...][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。 LeetCode121 买卖股票的最佳时机 LeetCode122 买卖股票的最佳时机2 LeetCode309 最佳买卖股票含冷冻期 LeetCode714 买卖股票的最佳时机含手续费 LeetCode123 买卖股票的最佳时机3 LeetCode188 买卖股票的最佳时机4 打家劫舍(DP) 打家劫舍1 LeetCode198 打家劫舍 12345678910111213141516# 带备忘录def rob(nums): n = len(nums) if n==0: return 0\tif n==1: return nums[0]\tdp = [0]*n dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2]+nums[i]) return dp[n-1]# 优化空间def rob(nums): prev, curr = 0, 0 for i in nums: prev, curr = curr, max(curr, prev+1) return curr 打家劫舍2 LeetCode213 打家劫舍2 打家劫舍3 LeetCode337 打家劫舍3 nSum 两数之和 LeetCode1 两数之和 3Sum LeetCode15 三数之和 4Sum LeetCode18 四数之和 第一章 数据结构链表1拉宾-卡普 数组二叉树图设计数据结构","tags":["算法","数据结构","leetcode","python"],"categories":["算法"]},{"title":"蓝桥杯备赛","path":"/2023/04/19/蓝桥杯备赛/","content":"蓝桥杯暴力dfsbfs回溯动态规划背包问题数论最大公约数12345def gcd(a, b): if b == 0: reutrn a a, b = b, a % b return gcd(a, b) 中国剩余定理12345678910111213141516171819202122def exgcd(a, b): if b == 0: return 1, 0 else: x, y = exgcd(b, a % b) return y, (x - a // b * y)def CRT(k, a, r): n = 1; ans = 0 for i in range(1, k + 1): n = n * r[i] for i in range(1, k + 1): m = n // r[i] b, y = exgcd(m, r[i]) # b * m mod r[i] = 1 while b &lt; 0: b += r[i] ans = (ans + a[i] * m * b) % n return (ans % n + n) % nr = [0, 3, 5, 7]a = [0, 2, 3, 2]print(CRT(3, a, r)) 筛法求素数12345678def isPrime(n):\tprime = [True] * n for i in range(2, n + 1): if prime[i]: for i in range(i * 2, n + 1, i): prime[i] = False return [i for i in range(2, n) if prime[i]] 图论图论基础及遍历构建图(邻接表) 123456789def buildGraph(numCourses: int, prerequisites: List[List[int]]) -&gt; List[List[int]]: # 图中共有 numCourses 个节点 graph = [[] for _ in range(numCourses)] for edge in prerequisites: from_, to_ = edge[1], edge[0] # 添加一条从 from 指向 to 的有向边 # 如果是无向图，则再反向添加一次 graph[from_].append(to_) return graph 图的遍历 12345678910111213141516# 记录被遍历过的节点visited = []# 记录从起点到当前节点的路径onPath = []def traverse(graph, s): if visited[s]: return # 经过节点 s，标记为已遍历 visited[s] = True # 做选择：标记节点 s 在路径上 onPath[s] = True for neighbor in graph.neighbors(s): traverse(graph, neighbor) # 撤销选择：节点 s 离开路径 onPath[s] = False 环检测及拓扑排序环检测 12345678910111213141516171819202122def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: graph = self.buildGraph(numCourses, prerequisites) self.visited = [False] * numCourses self.onPath = [False] * numCourses self.hasCycle = False for i in range(numCourses): self.traverse(graph, i) return not self.hasCycledef traverse(self, graph, s): if self.onPath[s]: self.hasCycle = True if self.visited[s] or self.hasCycle: return self.visited[s] = True self.onPath[s] = True for t in graph[s]: self.traverse(graph, t) self.onPath[s] = Falsedef buildGraph(self, numCourses, prerequisites): # 代码见前文 拓扑排序 1234567891011121314151617181920212223242526272829303132333435363738def findOrder(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: # 记录后序遍历结果 postorder = [] # 记录是否存在环 hasCycle = False visited = [False] * numCourses onPath = [False] * numCourses # 建图函数 def buildGraph(numCourses, prerequisites): # 代码见前文 pass # 图遍历函数 def traverse(graph, s): if onPath[s]: # 发现环 hasCycle = True if visited[s] or hasCycle: return # 前序遍历位置 onPath[s] = True visited[s] = True for t in graph[s]: traverse(graph, t) # 后序遍历位置 postorder.append(s) onPath[s] = False graph = buildGraph(numCourses, prerequisites) # 遍历图 for i in range(numCourses): traverse(graph, i) # 有环图无法进行拓扑排序 if hasCycle[0]: return [] # 逆后序遍历结果即为拓扑排序结果 return postorder[::-1] 二分图判定1234567891011121314151617181920212223242526272829303132333435363738394041424344def __init__(self): # 记录图是否符合二分图性质 self.ok = True # 记录图中节点的颜色，False和True代表两种不同颜色 self.color = [] # 记录图中节点是否被访问过 self.visited = []# 主函数，输入邻接表，判断是否是二分图def isBipartite(self, graph: List[List[int]]) -&gt; bool: n = len(graph) self.color = [False] * n self.visited = [False] * n # 因为图不一定是联通的，可能存在多个子图 # 所以要把每个节点都作为起点进行一次遍历 # 如果发现任何一个子图不是二分图，整幅图都不算二分图 for v in range(n): if not self.visited[v]: self.traverse(graph, v) if not self.ok: break return self.ok# DFS 遍历框架def traverse(self, graph: List[List[int]], v: int) -&gt; None: # 如果已经确定不是二分图了，就不用浪费时间再递归遍历了 if not self.ok: return self.visited[v] = True for w in graph[v]: if not self.visited[w]: # 相邻节点 w 没有被访问过 # 那么应该给节点 w 涂上和节点 v 不同的颜色 self.color[w] = not self.color[v] # 继续遍历 w self.traverse(graph, w) else: # 相邻节点 w 已经被访问过 # 根据 v 和 w 的颜色判断是否是二分图 if self.color[w] == self.color[v]: # 若相同，则此图不是二分图 self.ok = False return Prim最小生成树123456789101112131415161718192021222324252627282930313233343536373839404142import heapqclass Prim: # 核心数据结构，存储「横切边」的优先级队列 def __init__(self, graph: List[List[int]]): self.graph = graph self.pq = [] # PriorityQueue&lt;int[]&gt; 的实现 self.inMST = [False] * len(graph) # 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分 self.weightSum = 0 # 记录最小生成树的权重和 self.inMST[0] = True # 随便从一个点开始切分都可以，我们不妨从节点 0 开始 self.cut(0) # 不断进行切分，向最小生成树中添加边 while self.pq: # 按照边的权重从小到大排序 edge = heapq.heappop(self.pq) to = edge[1] # 表示相邻节点 weight = edge[2] # 表示这条边的权重 if self.inMST[to]: # 节点 to 已经在最小生成树中，跳过。否则这条边会产生环 continue self.weightSum += weight # 将边 edge 加入最小生成树 self.inMST[to] = True self.cut(to) # 节点 to 加入后，进行新一轮切分，会产生更多横切边 # 将 s 的横切边加入优先队列 def cut(self, s): for edge in self.graph[s]: # 遍历 s 的邻边 to = edge[1] # 相邻的节点 if self.inMST[to]: # 相邻接点 to 已经在最小生成树中，跳过 continue heapq.heappush(self.pq, edge) # 加入横切边队列 # 最小生成树的权重和 def weightSum(self) -&gt; int: return self.weightSum # 判断最小生成树是否包含图中的所有节点 def allConnected(self) -&gt; bool: for i in range(len(self.inMST)): if not self.inMST[i]: return False return True Dijstra最短路径12345678910111213141516171819import heapqfrom typing import List# 假设 graph 是一个邻接矩阵，graph[i][j] 是从节点 i 到节点 j 的距离def dijkstra(start: int, graph: List[List[int]]) -&gt; List[int]: V = len(graph) distTo = [float(&#x27;inf&#x27;)] * V distTo[start] = 0 pq = [(0, start)] # 使用元组 (distance, node)，以便按照 distance 进行排序 while pq: (dist, curNodeID) = heapq.heappop(pq) if dist &gt; distTo[curNodeID]: continue for weight, nextNodeID in graph[curNodeID]: if weight is not None: # 如果两个节点之间有边 distToNextNode = distTo[curNodeID] + weight if distTo[nextNodeID] &gt; distToNextNode: distTo[nextNodeID] = distToNextNode heapq.heappush(pq, (distToNextNode, nextNodeID)) return distTo","tags":["算法","Python","蓝桥杯"],"categories":["算法"]},{"title":"Hello World","path":"/2023/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["Hexo"],"categories":["Hexo"]},{"title":"关于","path":"/about/index.html","content":"🔭 I’m currently studying in CQUPT and will soon go to Zhejiang University 🌱 I’m good at C++ and Python 👯 I’m familiar with computer networks, data structures and operating systems 🤔 I understand network structure models such as RNN, LSTM, and Transformer, and have a basic understanding of deep learning. ⚡ Fun fact: mobile and algorithm 📫 How to reach me: Email: &#x31;&#52;&#52;&#x38;&#51;&#55;&#53;&#50;&#x34;&#57;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;","tags":[null],"categories":[null]}]